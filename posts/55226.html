<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>洛谷2022七月月赛 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Better_OIer&#039;s Blog"><meta name="msapplication-TileImage" content="image/site_logo_used.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Better_OIer&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="A题目描述15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。"><meta property="og:type" content="blog"><meta property="og:title" content="洛谷2022七月月赛"><meta property="og:url" content="http://betteroier.site/posts/55226.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="A题目描述15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://betteroier.site/img/og_image.png"><meta property="article:published_time" content="2022-08-10T10:34:55.000Z"><meta property="article:modified_time" content="2023-11-13T08:18:23.982Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="题解"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://betteroier.site/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://betteroier.site/posts/55226.html"},"headline":"洛谷2022七月月赛","image":["http://betteroier.site/img/og_image.png"],"datePublished":"2022-08-10T10:34:55.000Z","dateModified":"2023-11-13T08:18:23.982Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"http://betteroier.site/posts/image/head_logo.png"}},"description":"A题目描述15B03 的座位非常拥挤，可以看成一张 $n\\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。"}</script><link rel="canonical" href="http://betteroier.site/posts/55226.html"><link rel="icon" href="/image/site_logo_used.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/6.0.0/css/all.css"><link rel="stylesheet" href="https://code.bdstatic.com/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="/css/font.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://code.bdstatic.com/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/image/head_logo.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="http://betteroier.site:1000/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-10T10:34:55.000Z" title="2022/8/10 18:34:55">2022-08-10</time>发表</span></div></div><h1 class="title is-3 is-size-4-mobile">洛谷2022七月月赛</h1><div class="content"><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。</p>
<span id="more"></span>
<p>根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 <strong>公共点</strong>。严格定义两张桌子 $(i, j)$ 和 $(i’, j’)$ 相邻当且仅当 $|i - i’|\leq 1$ 且 $|j - j’|\leq 1$。</p>
<p>布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。</p>
<p>小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 <strong>欧几里得</strong> 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。</p>
<p>平行时空中 15B03 的规模不尽相同：多组测试数据。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>测试点 #1（15 points）：$n, m$ 均为奇数。</li>
<li>测试点 #2（20 points）：$n &#x3D; 1$。</li>
<li>测试点 #3（25 points）：$n &#x3D; 2$。</li>
<li>测试点 #4（30 points）：$n$ 为奇数。依赖测试点 #1，#2。</li>
<li>测试点 #5（10 points）：无特殊限制。依赖测试点 #3，#4。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$1\leq T\leq 57$。</li>
<li>$1\leq n, m\leq 1064$。</li>
</ul>
<h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>第一问的答案是 $\left\lceil \dfrac {n + 1} 2 \right\rceil\left\lceil \dfrac {m + 1} 2 \right\rceil$。选择奇数行和奇数列的所有交点，可以使得每个 $2\times 2$ 的小正方形 $(2k - 1 &#x2F; 2k, 2k - 1 &#x2F; 2k)$ 都存在一个格子被选。当 $n$ 或 $m$ 是奇数时，边界处小正方形不满。这种讨论是平凡的。</p>
<p>这样的构造是上界，因为每个小正方形至多选出一个格子。</p>
<p>对于第二问，我们有如下构造：若横坐标为奇数则横坐标固定，若为偶数则当 $\leq \dfrac n 2$ 时选奇数行，否则选偶数行。对于纵坐标同理。这样，四个角均被占用，并且每个位置都取到了它所能贡献的最大值。证明方法是观察到每个 $2\times 2$ 的小正方形 $(2k - 1 &#x2F; 2k, 2k - 1 &#x2F; 2k)$ 当中只能恰好放一个，而恰好放的这一个取到了贡献的最大值，具体证明细节略去。</p>
<p>需要特判 $n &#x3D; 2$ 或 $m &#x3D; 2$ 的情况。</p>
<p>根据构造算答案即可，时间复杂度 $\mathcal{O}(nm)$。</p>
<p>据验题人反应，第二问难度较大。我们给第一问 $80$ 分以达到送分的目的。</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;quadmath.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> S, T;</span><br><span class="line">  cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; n * m - (n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) * (m + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">2</span> || m &gt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(m == <span class="number">2</span>) <span class="built_in">swap</span>(n, m);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; j++) &#123;</span><br><span class="line">          <span class="type">int</span> x = i * <span class="number">2</span> - <span class="number">1</span>, y = j * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x &gt; n / <span class="number">2</span>) x++;</span><br><span class="line">          <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; y &gt; m / <span class="number">2</span>) y++;</span><br><span class="line">          <span class="type">int</span> dx = <span class="built_in">max</span>(x - <span class="number">1</span>, n - x);</span><br><span class="line">          <span class="type">int</span> dy = <span class="built_in">max</span>(y - <span class="number">1</span>, m - y);</span><br><span class="line">          ans += <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y &#x3D; n - 1$。</p>
<p>表达式越大，越有可能炸掉小 T 的博客。小 A 希望 <strong>从左往右</strong> 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。</p>
<p>若存在多组构造方案，输出任意一组。</p>
<p>多组测试数据。</p>
<h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>测试点 #1（10 points）：所有 $b_i$ 互不相等。</li>
<li>测试点 #2（20 points）：所有 $b_i$ 相等。</li>
<li>测试点 #3（30 points）：$n \leq 8$。</li>
<li>测试点 #4（25 points）：$n \leq 10 ^ 3$。依赖测试点 #3。</li>
<li>测试点 #5（15 points）：无特殊限制。依赖测试点 #1，#2，#4。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$1\leq T\leq 20$。</li>
<li>$1 \leq n \leq 2.5 \times 10 ^ 4$。</li>
<li>$0 \leq x, y &lt; n$，$x + y &#x3D; n - 1$。</li>
<li>$1\leq a_i &lt; 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\leq b_i &lt; 65536$。</li>
</ul>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>核心观察：或比异或更厉害。无论之前结果如何，只要在最后一次出现之前放上或就能让这一位变成 $1$。</p>
<p>对每个出现偶数次的位，在最后分配一个或就能变为 $1$。而出现奇数次的位就算不分配也是 $1$​。</p>
<p>按位从大到小贪心，时间复杂度 $\mathcal{O}(n + V)$。</p>
<p>构造方案：在选择分配或的位的最后一次出现之前放上或。对于多于的或，从后往前填入所有空隙，容易发现不影响答案。剩余空隙放入异或。</p>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2.5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> W = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="type">int</span> n, x, y, a[N], op[N];</span><br><span class="line"><span class="type">int</span> buc[W], ans[W], lst[W];</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">int</span> S, T;</span><br><span class="line">  cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(op, <span class="number">0</span>, <span class="built_in">sizeof</span>(op));</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="built_in">sizeof</span>(buc));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], buc[a[i]]++, lst[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = W - <span class="number">1</span>; ~i; i--)</span><br><span class="line">      <span class="keyword">if</span>(buc[i] &amp; <span class="number">1</span>) ans[i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(y &amp;&amp; buc[i]) ans[i] = op[lst[i]] = <span class="number">1</span>, y--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; y; i--) <span class="keyword">if</span>(!op[i]) op[i] = <span class="number">1</span>, y--;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = W - <span class="number">1</span>; ~i; i--) <span class="keyword">if</span>(ans[i] || flag) cout &lt;&lt; ans[i], flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!flag) cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) cout &lt;&lt; (op[i] ? <span class="string">&#x27;|&#x27;</span> : <span class="string">&#x27;^&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>小 A 一共有 $n$ 道题目没有补。评估后，他认为第 $i$ 题的难度为 $x_i$。</p>
<p>同时，他对自己的水平有评估值 $w$。他的水平会波动，因此 $w$ 会改变。</p>
<p>小 A 认为补难度和自己水平相近的题目（相差不超过 $b_1$）能带来收益 $inc$；相反，如果相差过大（相差超过 $b_2$）则浪费了时间，导致负收益 $dec$。因此，补第 $i$ 道题的收益为</p>
<p>$$<br>\begin{cases}<br>inc &amp; |x_i - w| \leq b_1 \<br>0 &amp; b_1 &lt; |x_i - w| \leq b_2 \<br>dec &amp; |x_i - w| &gt; b_2 \<br>\end{cases}<br>$$</p>
<p>保证 $b_1 \leq b_2$ 且 $dec &lt; 0 &lt; inc$。</p>
<p>此外，小 A 有一些喜欢和讨厌的题。如果他没有补任何喜欢的题，或补了任何讨厌的题，就会不高兴。</p>
<p>小 A 将选择一段编号连续的题目进行补题。他希望补每道题的收益之和最大，并且补完题目后不会不高兴。请你告诉他这个最大值。</p>
<h3 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>Subtask #1（7 points）：$n, q\leq 100$。</li>
<li>Subtask #2（12 points）：$n, q\leq 500$。依赖 Subtask #1。</li>
<li>Subtask #3（20 points）：$n, q\leq 4 \times 10 ^ 3$。依赖 Subtask #2。</li>
<li>Subtask #4（25 points）：$w, x_i \leq 100$。</li>
<li>Subtask #5（11 points）：$l &#x3D; 1$，$h &#x3D; 0$。</li>
<li>Subtask #6（15 points）：$w, x_i \leq 10 ^ 5$。依赖 Subtask #4。</li>
<li>Subtask #7（10 points）：无特殊限制。依赖 Subtask #3，#5，#6。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$1\leq n, q \leq 10 ^ 5$。</li>
<li>$0\leq w, x_i \leq 10 ^ 9$，$0\leq b_1 \leq b_2$ 且 $b_2$ 不大于 $w, x_i$ 上界的一半。</li>
<li>$-10 ^ 4 \leq dec &lt; 0 &lt; inc \leq 10 ^ 4$。</li>
<li>$1\leq l, il_i, ih_j \leq n$，$0 \leq h &lt; n$，$l + h\leq 5$。</li>
<li>保证 $il$，$ih$ 递增，且一组询问每个下标至多出现一次。</li>
</ul>
<h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>考虑 $n, q \leq 500$。</p>
<p>容易发现，讨厌的题将序列割成若干连续段。连续段之间独立，因此单独考虑一个连续段。</p>
<p>对于当前区间 $[l, r]$，枚举其所有子区间，检查是否有喜欢的题落在其中并更新答案。</p>
<p>时间复杂度 $\mathcal{O}(n ^ 2q)$。</p>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>考虑 $n, q \leq 4\times 10 ^ 3$。</p>
<p>注意到对于每个位置，合法的右端点形成一段区间 $[l, r)$，从 $p$ 右边第一个喜欢的题 $l$ 开始，第一个讨厌的题 $r$ 结束。</p>
<p>将区间求和差分转化为端点最值，每次改变 $w$ 时暴力重新求前缀和，区间最值用线段树或 ST 表维护。</p>
<p>时间复杂度 $\mathcal{O}(nq \log n)$。</p>
<h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol 3"></a>Sol 3</h3><p>考虑 $x_i, w \leq 100$。</p>
<p>回答询问考虑直接枚举包含的喜欢的题，则对应的合法区间左右端点均为一段区间（被讨厌的题所限制）。区间查询前缀和最大最小值即可。</p>
<p>可能的 $w$ 仅有 $100$ 种取值。对每种 $w$ 的取值的对应序列建线段树维护之。</p>
<p>时间复杂度 $\mathcal{O}(nw + q\log n)$。</p>
<h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol 4"></a>Sol 4</h3><p>考虑正解。</p>
<p>当 $w$ 从 $1$ 增大到 $10 ^ 9$ 时，仅有 $\mathcal{O}(n)$ 次改变某个位置上的贡献的操作。</p>
<p>单点修改相当于对前缀和区间修改，将所有询问离线回答，用线段树维护区间加法区间最值。</p>
<p>时间复杂度 $\mathcal{O}(n(l\log n + h))$，空间复杂度线性。</p>
<h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> S, n, q, w, b1, b2, inc, dec;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">event</span> &#123;</span><br><span class="line">  <span class="type">int</span> type, x, id, dt;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> event &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x != rhs.x) <span class="keyword">return</span> x &lt; rhs.x;</span><br><span class="line">    <span class="keyword">return</span> type &lt; rhs.type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; c[N * <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> cnt, ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; l[N], h[N];</span><br><span class="line"><span class="type">int</span> laz[N &lt;&lt; <span class="number">2</span>], mx[N &lt;&lt; <span class="number">2</span>], mn[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;laz[x] += v, mx[x] += v, mn[x] += v;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span>(laz[x]) <span class="built_in">tag</span>(x &lt;&lt; <span class="number">1</span>, laz[x]), <span class="built_in">tag</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, laz[x]), laz[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  mx[x] = <span class="built_in">max</span>(mx[x &lt;&lt; <span class="number">1</span>], mx[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mn[x] = <span class="built_in">min</span>(mn[x &lt;&lt; <span class="number">1</span>], mn[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l == r) <span class="keyword">return</span> mx[x] = mn[x] = ::dec * l, <span class="built_in">void</span>();</span><br><span class="line">  <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(l, m, x &lt;&lt; <span class="number">1</span>), <span class="built_in">build</span>(m + <span class="number">1</span>, r, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> <span class="built_in">tag</span>(x, v);</span><br><span class="line">  <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">down</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(ql &lt;= m) <span class="built_in">modify</span>(l, m, ql, qr, x &lt;&lt; <span class="number">1</span>, v);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; qr) <span class="built_in">modify</span>(m + <span class="number">1</span>, r, ql, qr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, v);</span><br><span class="line">  <span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr, <span class="type">int</span> x, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = type ? <span class="number">-1e9</span> : <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> type ? mx[x] : mn[x];</span><br><span class="line">  <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">down</span>(x);</span><br><span class="line">  <span class="keyword">if</span>(ql &lt;= m) ans = <span class="built_in">query</span>(l, m, ql, qr, x &lt;&lt; <span class="number">1</span>, type);</span><br><span class="line">  <span class="keyword">if</span>(m &lt; qr) &#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="built_in">query</span>(m + <span class="number">1</span>, r, ql, qr, x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, type);</span><br><span class="line">    ans = type ? <span class="built_in">max</span>(ans, v) : <span class="built_in">min</span>(ans, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  cin &gt;&gt; S;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q &gt;&gt; w &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; inc &gt;&gt; ::dec;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    c[++cnt] = &#123;<span class="number">1</span>, x - b2, i, -::dec&#125;;</span><br><span class="line">    c[++cnt] = &#123;<span class="number">1</span>, x - b1, i, inc&#125;;</span><br><span class="line">    c[++cnt] = &#123;<span class="number">1</span>, x + b1 + <span class="number">1</span>, i, -inc&#125;;</span><br><span class="line">    c[++cnt] = &#123;<span class="number">1</span>, x + b2 + <span class="number">1</span>, i, ::dec&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> op, L, H, il, ih;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;cin &gt;&gt; w; <span class="keyword">continue</span>;&#125;</span><br><span class="line">    cin &gt;&gt; L &gt;&gt; H;</span><br><span class="line">    <span class="keyword">while</span>(L--) cin &gt;&gt; il, l[i].<span class="built_in">push_back</span>(il);</span><br><span class="line">    <span class="keyword">while</span>(H--) cin &gt;&gt; ih, h[i].<span class="built_in">push_back</span>(ih);</span><br><span class="line">    c[++cnt] = &#123;<span class="number">2</span>, w, i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(c + <span class="number">1</span>, c + cnt + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">0</span>, n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    event t = c[i];</span><br><span class="line">    <span class="keyword">if</span>(t.type == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">int</span> id = t.id, res = <span class="number">-1e9</span>, lst = <span class="number">0</span>, pt = <span class="number">0</span>;</span><br><span class="line">      h[id].<span class="built_in">push_back</span>(n + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> it : l[id]) &#123;</span><br><span class="line">        <span class="keyword">while</span>(it &gt; h[id][pt]) lst = h[id][pt++];</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(<span class="number">0</span>, n, it, h[id][pt] - <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) - <span class="built_in">query</span>(<span class="number">0</span>, n, lst, it - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      ans[id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">0</span>, n, t.id, n, <span class="number">1</span>, t.dt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="keyword">if</span>(l[i].<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>以下是简化后的扫雷游戏规则：</p>
<ul>
<li>定义连通为 <strong>八连通</strong>。</li>
<li>如果打开雷，所有雷全部爆炸，游戏结束。</li>
<li>如果打开空地，若其周围没有雷，则递归打开周围八个空地。</li>
<li><a target="_blank" rel="noopener" href="https://cdn.luogu.com.cn/upload/image_hosting/kjjqs2v1.png">如图</a>，点开任意红色框内方块均形成当前局面。</li>
</ul>
<p>给定一张 $n\times m$ 的初始地图。小 A 决定搜出所有可能的局面，并找到最优鼠标点击顺序，从而速通这张地图。</p>
<p>为设置合适的数组大小，小 A 需要知道有多少种不同局面。对 $998244353$ 取模。</p>
<ul>
<li>如果方块是雷，它有爆炸和未爆炸两种状态；如果方块是空地，它有打开和未打开两种状态。</li>
<li>两个局面不同，当且仅当存在方块状态不同。</li>
<li>保证周围无雷的空地形成不超过 $37$ 个连通块。</li>
</ul>
<h3 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h3><p>设周围无雷的空地形成 $d$ 个连通块。</p>
<ul>
<li>Subtask #1（15 points）：$nm\leq 21$。</li>
<li>Subtask #2（4 points）：地图中只有一个雷。</li>
<li>Subtask #3（5 points）：$d &#x3D; 0$。</li>
<li>Subtask #4（6 points）：$d &#x3D; 1$。</li>
<li>Subtask #5（7 points）：$d &#x3D; 2$。</li>
<li>Subtask #6（8 points）：$d \leq 17$。依赖 Subtask #1，#2，#3，#4，#5。</li>
<li>Subtask #7（9 points）：$d \leq 23$。依赖 Subtask #6。</li>
<li>Subtask #8（16 points）：$d\leq 27$。依赖 Subtask #7。</li>
<li>Subtask #9（17 points）：$d\leq 33$。依赖 Subtask #8。</li>
<li>Subtask #10（13 points）：无特殊限制。依赖 Subtask #9。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$1\leq n, m\leq 500$。</li>
<li>$0\leq d\leq 37$。</li>
<li><strong>不保证</strong> 地图中有雷或空地。</li>
</ul>
<h3 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>考虑 $d &#x3D; 0$。</p>
<p>称「有雷空地」为周围有雷的空地，「无雷空地」为周围无雷的空地。</p>
<p>地图中没有无雷空地，每个空地的状态独立。设共有 $v$ 个有雷空地，根据乘法原理，答案为 $2 ^ {v + c}$，其中 $c$ 表示是否存在雷。</p>
<p>直接枚举空地及其周围空地求出 $v$，时间复杂度为 $\mathcal{O}(nm)$。</p>
<ul>
<li>将不计入雷的局面数乘 $2$ 即可得到计入雷的局面数。</li>
<li>为叙述方便，下文中提到的局面均不计入点到雷的局面。</li>
</ul>
<h3 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>考虑 $d &#x3D; 1$。</p>
<p>若空地周围存在无雷空地，当无雷空地打开时，该空地也同时打开。空地之间的状态并不独立。</p>
<p>设打开无雷空地形成的连通块将打开 $c$ 个有雷空地。当连通块未打开时，$v$ 个有雷空地的状态独立，有 $2 ^ v$ 种局面；当连通块打开时，$c$ 个有雷空地同时被打开，剩余 $v - c$ 个有雷空地的状态独立，有 $2 ^ {v - c}$ 种局面。</p>
<p>存在初始地图中没有雷的情况，此时答案为 $1$；否则答案为 $2\times (2 ^ v + 2 ^ {v - c})$。</p>
<p>容易 dfs 求出 $c$，时间复杂度为 $\mathcal{O}(nm)$。</p>
<h3 id="Sol-3-1"><a href="#Sol-3-1" class="headerlink" title="Sol 3"></a>Sol 3</h3><p>考虑 $d &#x3D; 2$。</p>
<p>将无雷空地形成的两个八连通块标上序号。设打开第 $i$ 个连通块时打开的有雷空地个数为 $c_i$。</p>
<p>讨论连通块的状态：</p>
<ul>
<li>若连通块 $1, 2$ 都未打开，共有 $2 ^ v$ 种局面。</li>
<li>若连通块 $1$ 打开，连通块 $2$ 未打开，沿用 $d &#x3D; 1$ 的做法，共有 $2 ^ {v - c_1}$ 种局面。</li>
<li>同理，若连通块 $2$ 打开，连通块 $1$ 未打开，共有 $2 ^ {v - c_2}$ 种局面。</li>
<li>若连通块 $1, 2$ 都打开，共有 $2 ^ {v - c_1 - c_2}$ 种局面。</li>
</ul>
<p>分析第四种情况：直接按照这种思路写甚至过不了样例，因为两个连通块可能打开相同的有雷空地。如 $3 \times 3$ 的网格，左上角和右下角均为雷，则左下角和右上角的两个连通块同时打开中心空地。</p>
<p>设打开两个连通块时打开的相同有雷空地个数为 $e$。</p>
<p>在计算连通块 $1, 2$ 影响到的有雷空地个数时，上述结论多统计了 $e$ 个空地。此时应仅有 $c_1 + c_2 - e_{1, 2}$ 个有雷空地被打开，其余 $v - (c_1 + c_2 - e_{1, 2})$ 个有雷空地的状态独立。</p>
<p>答案为 $2\times (2 ^ v + 2 ^ {v - c_1} + 2 ^ {v - c_2} + 2 ^ {v - c_1 - c_2 + e})$。</p>
<p>dfs 求出 $c_i$ 与 $e$，时间复杂度为 $\mathcal{O}(nm)$。</p>
<h3 id="Sol-4-1"><a href="#Sol-4-1" class="headerlink" title="Sol 4"></a>Sol 4</h3><p>考虑 $d \leq 15$。</p>
<p>设 $e_S$ 表示 <strong>恰好</strong> 同时被连通块集合 $S$ 打开的有雷空地数，可以 dfs 求出。</p>
<p>枚举打开的连通块集合 $S$，则答案为 $2 \times \sum\limits_{S} 2 ^ {S - \sum_{T\subseteq S} e_T}$。</p>
<p>直接枚举子集，时间复杂度 $\mathcal{O}(nm + 3 ^ d)$。</p>
<h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol 5"></a>Sol 5</h3><p>考虑 $d \leq 21$。</p>
<p>用 FMT 优化上式，时间复杂度 $\mathcal{O}(nm + d2 ^ d)$。</p>
<h3 id="Sol-6"><a href="#Sol-6" class="headerlink" title="Sol 6"></a>Sol 6</h3><p>考虑 $d\leq 26$。</p>
<p>枚举子集的复杂度无法做到更优，考虑挖掘性质。</p>
<p>结论：一个有雷空地至多被两个连通块打开。</p>
<p>证明：</p>
<ul>
<li><p>若一个有雷空地同向的两个角落的方块均为无雷空地，则这两个无雷空地一定在同一连通块，因为它们中间的方块是无雷空地。</p>
</li>
<li><p>一个有雷空地的上下和左右两个方块不可能均为无雷空地，否则该有雷空地为无雷空地。</p>
</li>
</ul>
<p>根据上述限制，一个有雷空地最多被三个连通块打开，且其周围状态只能为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? 0 ?</span><br><span class="line">0 * ?</span><br><span class="line">? ? 0</span><br></pre></td></tr></table></figure>

<p>其中 <code>*</code> 表示有雷空地，<code>0</code> 表示无雷空地，<code>?</code> 表示不重要的方块。</p>
<p>根据周围三个无雷空地的限制，中间的有雷空地为无雷空地，矛盾。得证。</p>
<p>因此 $e_S$ 仅在 $|S|\leq 2$ 处有值。在此基础上得以 $2 ^ d$ 求出 $f_S &#x3D; \sum\limits_{T\subseteq S} e_T$。</p>
<p>对于 $f_S$，设 $p$ 为 $S$ 中编号最小的连通块，则 $f_S &#x3D; f_{S \backslash p} + g_{p, S\backslash p} + e_$。$p$ 可以 <code>lowbit</code> 求得。</p>
<p>综上，时空复杂度 $\mathcal{O}(nm + 2 ^ d)$。</p>
<p>进一步地，可以将空间复杂度优化至 $\mathcal{O}(nm + d ^ 2)$。</p>
<p>时间复杂度仍然是 $\sum\limits_{i &#x3D; 0} ^ {d - 1} 2 ^ i \times (d - i) \approx \mathcal{O}(2 ^ d)$。如果不放心，利用主定理求解 $T(n) &#x3D; 2T(\frac n 2) + \log n$，解得 $T(n) &#x3D; n$。</p>
<h3 id="Sol-7"><a href="#Sol-7" class="headerlink" title="Sol 7"></a>Sol 7</h3><p>考虑 $d\leq 33$。</p>
<p>根据 Sol 6 的结论，将连通块抽象成点，令两个节点之间的权值为它们同时打开的空地数。若 $w(u, v) &gt; 0$ 视 $u, v$ 之间连边。</p>
<p>每次枚举度数最大的节点的两种状态，考虑它对剩余节点的影响，并删掉该点。形成的连通块之间独立，分别暴搜。可以通过本题，但不会分析复杂度的算法不适合当正解。</p>
<p>我们给出优于 $2 ^ d$ 的 <strong>确定性</strong> 做法：</p>
<p>整张地图是二维平面，所以建出的图 $G$ 是平面图。根据四色定理，$G$ 的最大独立集 $I_{\max}$ 不小于 $\left\lceil \dfrac d 4\right\rceil$。最大独立集可以在 $2 ^ {\frac d 2}$ 或 $3 ^ {\frac d 3}$ 的时间内求得，以下做法摘自 pb 的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/p-b-p-b/p/14200616.html">《浅谈信息学竞赛中的独立集问题》学习笔记</a>。</p>
<p>设 $f_S$ 表示点集 $S$ 上的最大独立集，令 $u$ 为 $S$ 中编号最大的节点，有 $f_S &#x3D; \max(f_{S\backslash u}, f_{S\backslash u \backslash N(u)} + 1)$。因为前 $\dfrac d 2$ 层只有 $2 ^ {\frac d 2}$ 种递归的可能，后 $\dfrac d 2$ 层 $S$ 中最大节点不超过 $\dfrac d 2$，所以总共只有 $2 ^ {\frac d 2}$ 种状态，对这些状态记忆化即可做到 $\mathcal{O}(2 ^ {\frac d 2})$。</p>
<p>对 $V\backslash I_{\max}$ 做 Sol 6，$I_{\max}$ 内所有点的状态独立，可以 $\mathcal{O}(|I|)$ 考虑。</p>
<p>时间复杂度 $\mathcal{O}(2 ^ {d - I}I)$，空间复杂度 $\mathcal{O}(nm + d ^ 2)$。</p>
<h3 id="Sol-8"><a href="#Sol-8" class="headerlink" title="Sol 8"></a>Sol 8</h3><p>考虑正解。</p>
<p>$I$ 中的点一旦独立，即可直接考虑贡献，不需要等到确定 $V\backslash I$ 所有节点的状态后再计算。因此，令 $I$ 的一个排列 $P &#x3D; {p_1, p_2, \cdots, p_k}$ 的代价 $f(P)$ 为 $\sum\limits_{i &#x3D; 1} ^ k2 ^ {|\cup_{j &#x3D; 1} ^ iN(p_j)|}$，表示 $I$ 内所有节点以 $P$ 的顺序独立的时间代价：$p_i$ 独立时，$p_1\sim p_i$ 均独立，需要删去 $\cup_{j &#x3D; 1} ^ {i} N(j)$ 内所有节点。</p>
<p>当 $I$ 较小时，枚举其所有排列并求出代价，否则随机足够多的排列使代价尽可能小。</p>
<p>得到最优排列 $P_b$ 后，求出对应删点顺序，并在对应时刻计算 $I$ 内某些节点的代价。</p>
<p>对于 $d &#x3D; 37$ 而言，$I_{\max}$ 的最小值为 $10$，此时可以全排列求最小代价。在 $I_{\max}$ 卡到最小值的图中几乎不可能使得 $\min f(P)$ 大于 $2\times 2 ^ {d - I}$（出题人尝试构建这样的图，均无法保证 $I_{\max} &#x3D; 10$）。若 $I$ 更大，则 $2 ^ {d - I}$ 变小，随机排列足够优秀。</p>
<p>复杂度可近似看做 $\mathcal{O}(2 ^ {d - I})$。</p>
<hr>
<p>本题出题人即笔者。一开始的想法是从 windows 的经典游戏中获取灵感，出了两道月赛 D 难度的题目。一道关于蜘蛛纸牌，已经放在了 SWTR-07，另一道是本题。</p>
<p>本题考察了选手对乘法原理，容斥原理，状压 DP 和随机乱搞的运用能力，以及将问题从实际情境中抽离却不脱离实际情境的能力。本题将 $d$ 优化掉并获得更优时间复杂度的关键结论隐藏在背景当中。</p>
<p>最初正解的复杂度为 $d2 ^ d$，提交审核时，粉兔指出本题有无脑 FMT 做法，大幅拉低本题水准，故撤下。出题人抓住关键性质，不断思考后得到 $2 ^ d$ 做法。同时，出题人认为验题人 chenxia25 给出的 $d ^ 2$ 空间做法具有一定启发性，故二次加强了本题。</p>
<p>进一步地，验题人 asmend 给出复杂度玄学的暴搜做法，出题人实现后发现效率惊人。不仅因为题目的实际意义限制了造出强的数据非常困难，而且 $G$ 是平面图。</p>
<p>对于完全图而言暴搜不可行，但 $G$ 甚至不存在 $K_5$ 和 $K_{3, 3}$，所以暴搜本身复杂度可能就是正确的，加上一点随机化难以卡掉。</p>
<p>出题人请教 EI 后，他指出可以通过删去最大独立集以外的所有顶点实现较多节点的独立。结合平面图四色定理（最大独立集不小于点集的四分之一）与 $2 ^ {\frac n 2}$ 求解一般图最大独立集，出题人得到本题正解的基本思路。</p>
<p>出题人尝试卡掉暴力无果，实现 Sol 7 后发现速度太慢，无法通过 $d &#x3D; 37$ 且 $I$ 卡到最小值的数据。尝试优化后得到最终正解。</p>
<p>出题人实现的基于随机化的最优秀暴力需要 2.1s，而 Sol 8 在出题人造出的最劣数据下仅需要 1.6s。因为难以估计 Sol 8 的复杂度上界，所以出题人将时间限制设为 3s。</p>
<p>也许这是第一次四色定理和 $2 ^ {\frac n 2}$ 最大独立集被应用在正经 OI 题当中。因为这一点，出题人认为本题是一道非常新颖有趣的问题，可惜暴力搜索可以通过。</p>
<p>单论本题正解，其难度堪比 Div.1 C 或 D。出题人将其放在 Div.2 D &#x2F; Div.1 B 的位置，因为暴力搜索被定位为 intended solution。按照其难度判断，本题放在 2D &#x2F; 1B 比较合适。</p>
<h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> D = <span class="number">37</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S, n, m, cmine, pw2[N * N];</span><br><span class="line"><span class="type">int</span> cur, mine, open[D], e[D][D];</span><br><span class="line"><span class="keyword">namespace</span> MAP &#123;</span><br><span class="line">  <span class="type">int</span> label[N][N];</span><br><span class="line">  <span class="type">bool</span> hmine[N][N], vis[N][N];</span><br><span class="line">  <span class="type">char</span> mp[N][N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs_map</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    vis[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">8</span>; dir++) &#123;</span><br><span class="line">      <span class="type">int</span> x = i + dx[dir], y = j + dy[dir];</span><br><span class="line">      <span class="keyword">if</span>(mp[x][y] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(hmine[x][y] &amp;&amp; label[x][y] != cur) &#123;</span><br><span class="line">        <span class="keyword">if</span>(label[x][y] != <span class="number">-1</span>) e[label[x][y]][cur]++;</span><br><span class="line">        label[x][y] = cur, open[cur]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!vis[x][y] &amp;&amp; !hmine[x][y]) <span class="built_in">dfs_map</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">8</span>; dir++) hmine[i][j] |= mp[i + dx[dir]][j + dy[dir]] == <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">          cmine += hmine[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mine = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(label, <span class="number">-1</span>, <span class="built_in">sizeof</span>(label));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">if</span>(mp[i][j] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !hmine[i][j] &amp;&amp; !vis[i][j])</span><br><span class="line">          <span class="built_in">dfs_map</span>(i, j), cur++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        e[i][j] = e[j][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        open[i] -= e[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++) cmine -= open[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; cur; j++)</span><br><span class="line">        cmine -= e[i][j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ar[D], I;</span><br><span class="line"><span class="keyword">namespace</span> MIS &#123;</span><br><span class="line">  <span class="type">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">19</span>];</span><br><span class="line">  <span class="function">ll <span class="title">get</span><span class="params">(ll x, ll y)</span> </span>&#123;<span class="keyword">return</span> __builtin_popcountll(x) &gt; __builtin_popcountll(y) ? x : y;&#125;</span><br><span class="line">  <span class="function">ll <span class="title">dfs_I</span><span class="params">(ll S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bit = <span class="number">63</span> - __builtin_clzll(S);</span><br><span class="line">    ll x = S ^ (<span class="number">1ll</span> &lt;&lt; bit), y = x ^ (x &amp; ar[bit]); </span><br><span class="line">    <span class="keyword">if</span>(S &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">19</span>)) <span class="keyword">return</span> <span class="built_in">get</span>(<span class="built_in">dfs_I</span>(x), <span class="built_in">dfs_I</span>(y) ^ (<span class="number">1ll</span> &lt;&lt; bit));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(f[S] != <span class="number">-1</span>) <span class="keyword">return</span> f[S];</span><br><span class="line">      <span class="keyword">return</span> f[S] = <span class="built_in">get</span>(<span class="built_in">dfs_I</span>(x), <span class="built_in">dfs_I</span>(y) ^ (<span class="number">1ll</span> &lt;&lt; bit));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        <span class="keyword">if</span>(e[i][j])</span><br><span class="line">          ar[i] |= <span class="number">1ll</span> &lt;&lt; j;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    I = <span class="built_in">dfs_I</span>((<span class="number">1ll</span> &lt;&lt; cur) - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> limit, mark[D];</span><br><span class="line"><span class="keyword">namespace</span> LAB &#123;</span><br><span class="line">  <span class="type">int</span> p[D], q[D], best[D], te[D][D], to[D];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = cur - __builtin_popcountll(I);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, minc = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">if</span>(I &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        q[cnt++] = i;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">shuffle</span>(q, q + cnt, rnd);</span><br><span class="line">      <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> msk = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        msk |= ar[q[i]];</span><br><span class="line">        cost += <span class="number">1ll</span> &lt;&lt; __builtin_popcountll(msk);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cost &lt; minc) &#123;</span><br><span class="line">        minc = cost;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) best[i] = q[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> msk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        <span class="keyword">if</span>((msk &gt;&gt; j &amp; <span class="number">1</span> ^ <span class="number">1</span>) &amp;&amp; (ar[best[i]] &gt;&gt; j &amp; <span class="number">1</span>))</span><br><span class="line">          p[index] = j, mark[++index] = i;</span><br><span class="line">      msk |= ar[best[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">if</span>((msk | I) &gt;&gt; i &amp; <span class="number">1</span> ^ <span class="number">1</span>)</span><br><span class="line">        p[index] = i, mark[++index] = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) p[index++] = best[cnt - i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        te[i][j] = e[p[i]][p[j]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        e[i][j] = te[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++) to[i] = open[p[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur; i++) open[i] = to[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_ans</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p == limit) &#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p; i &lt; cur - mark[p]; i++) res = <span class="number">1ll</span> * res * (pw2[open[i]] + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">dfs_ans</span>(p + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt; cur - mark[p + <span class="number">1</span>]; i++) open[i] += e[p][i];</span><br><span class="line">  res = (res + <span class="number">1ll</span> * pw2[open[p]] * <span class="built_in">dfs_ans</span>(p + <span class="number">1</span>)) % mod;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt; cur - mark[p + <span class="number">1</span>]; i++) open[i] -= e[p][i];</span><br><span class="line">  <span class="keyword">if</span>(mark[p + <span class="number">1</span>] != mark[p])</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = mark[p] + <span class="number">1</span>; x &lt;= mark[p + <span class="number">1</span>]; x++)</span><br><span class="line">      res = <span class="number">1ll</span> * res * (pw2[open[cur - x]] + <span class="number">1</span>) % mod;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  cin &gt;&gt; S &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = pw2[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n * m; i++) pw2[i] = pw2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">  MAP::<span class="built_in">solve</span>();</span><br><span class="line">  MIS::<span class="built_in">solve</span>();</span><br><span class="line">  LAB::<span class="built_in">solve</span>();</span><br><span class="line">  cout &lt;&lt; (mine ? <span class="number">2ll</span> : <span class="number">1ll</span>) * <span class="built_in">dfs_ans</span>(<span class="number">0</span>) * pw2[cmine] % mod &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一张 $n$ 个点，$m$ 条边的无向图。每条边标有 <code>D</code> 或 <code>d</code>。</p>
<p>定义无序点对 $(x, y)$ 是「铁的」，当且仅当 $x \neq y$ 且 $x, y$ 之间存在同时出现 <code>D</code> 和 <code>d</code> 的简单路径。</p>
<p>小 A 深知自由组合定律 DdTt 的重要性，所以他让你对这样的点对计数。</p>
<p>注意：</p>
<ul>
<li>简单路径定义为不经过重复 <strong>节点</strong> 的路径。</li>
<li>保证图无自环，连通，可能有重边。</li>
</ul>
<h3 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>Subtask #1（6 points）：$n \leq 8$，$m \leq 21$。</li>
<li>Subtask #2（16 points）：$n\leq 15$，$m\leq 822$。依赖 Subtask #1。</li>
<li>Subtask #3（17 points）：$m &#x3D; n - 1$。</li>
<li>Subtask #4（18 points）：$m &#x3D; n$。</li>
<li>Subtask #5（19 points）：$n\leq 1064$，$m\leq 10 ^ 4$。依赖 Subtask #2。</li>
<li>Subtask #6（24 points）：无特殊限制。依赖 Subtask #3，#4，#5。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$2\leq n \leq 4\times 10 ^ 5$，$n - 1\leq m\leq  10 ^ 6$。</li>
<li>$1\leq x, y\leq n$。</li>
<li>$c\in {\texttt{D}, \texttt{d}}$。</li>
<li>保证图无自环，连通，可能有重边。</li>
</ul>
<h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>补集转化变成不存在同时出现 <code>D</code>（1）和 <code>d</code>（0）的简单路径。</p>
<p>如果点对之间不存在出现 $01$ 的路径，只有以下三种情况：</p>
<ul>
<li>只有 $0$ 路径。</li>
<li>只有 $1$ 路径。</li>
<li>同时有 $0$ 路径和 $1$ 路径。</li>
</ul>
<p>接下来的推导需多次应用如下基本事实：</p>
<blockquote>
<p><strong>性质 1</strong>：对于点数 $\geq 3$ 的点双，任给两点 $x\neq y$，存在经过 $x, y$ 的简单环。</p>
</blockquote>
<p>点双基本性质。若 $x, y$ 不直接相连，由 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%97%A8%E6%9D%B0%E5%AE%9A%E7%90%86/19137908">门杰定理</a> $k &#x3D; 2$ 的特殊情形可证。若 $x, y$ 直接相连，若删去 $(x, y)$ 后 $x, y$ 不连通，不妨设 $x$ 所在连通块大小 $\geq 2$，则 $x$ 为原图割点，矛盾，因此删去 $(x, y)$ 后 $x, y$ 连通，从而得到经过 $x, y$ 的简单环。证毕。</p>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>对于只有 $0$ 路径的情况，考虑点双 $B$，容易猜测若存在 $1$ 边则经过 $B$ 的点对不合法。</p>
<blockquote>
<p><strong>性质 2</strong>：对于点数 $\geq 3$ 的点双，任给一点 $x$ 与一边 $e$，存在经过 $x, e$ 的简单环。</p>
</blockquote>
<p>证明：将 $e &#x3D; (u, v)$ 拆成 $(u, w)$ 和 $(w, v)$ 不影响 $B$ 点双连通性。据性质 1，存在经过 $x, w$ 的简单环。因 $w$ 仅与 $u, v$ 相连，故 $(u, w), (w, v)$ 在环上，将其替换为 $(u, v)$ 可得经过 $x, e$ 的简单环。证毕。</p>
<ul>
<li>不影响点双连通性的证明：删去 $u$ 或 $v$，因 $w$ 与 $v$ 或 $u$ 连通且 $B$ 删去 $u$ 或 $v$ 后连通可知 $u, v$ 不是割点；删去 $u, v, w$ 以外的点时，将 $(u, w)$ 和 $(w, v)$ 视为 $(u, v)$，$B$ 连通；删去 $w$ 相当于删去 $(u, v)$，若图不连通则 $(u, v)$ 在 $B$ 上为割边，当点数 $\geq 3$ 时 $u$ 或 $v$ 在 $B$ 上为割点，矛盾，故 $B$ 连通。</li>
</ul>
<blockquote>
<p><strong>性质 3</strong>：对于点数 $\geq 3$ 的点双，点双内任给两点 $x\neq y$ 与一边 $e$，存在 $x \to e \to y$ 的简单路径。</p>
</blockquote>
<p>证明：由性质 2，存在经过 $x, e$ 的简单环 $C$，若 $y\in C$ 显然成立，否则令 $P$ 为任意 $y\to x$ 路径，考虑 $P$ 与 $C$ 的第一个交点 $z$，存在使得 $z \neq x$ 的 $P$，否则 $x$ 为割点：删去 $x$ 后 $y$ 无法到达 $C$ 剩余节点。令 $Q &#x3D; y \to z$ 接上 $z$ 通过环上有 $e$ 的一侧到 $x$ 的路径，则 $Q$ 为 $x \to e\to y$ 的简单路径。证毕。</p>
<p>令 $e$ 为 $1$ 边，对点双内任意两点 $x\neq y$ 应用性质 3，结合 $|B| &#x3D; 2$ 的平凡情况，可得</p>
<blockquote>
<p><strong>结论 1</strong>：若点双内存在 $1$ 边，则经过该点双的点对不合法。</p>
</blockquote>
<p>因此，删去有 $1$ 边的点双内部所有边，剩余连通块大小选 $2$ 之和即为所求。</p>
<p>对于只有 $1$ 路径的情况同理。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>同时有 $0$ 路径和 $1$ 路径的点对是本题重点，下称「合法点对」。</p>
<blockquote>
<p><strong>结论 2</strong>：若两点之间存在割点，则不合法。 </p>
</blockquote>
<p>证明：设 $x, y$ 间存在割点 $z$。考虑 $x\to z$ 和 $z\to y$ 的所有路径，它们仅在 $z$ 处相交，否则与 $z$ 为割点矛盾。若同时存在 $0$ 路径 $P_0$ 和 $1$ 路径 $P_1$，将 $P_0$ 在 $x\to z$ 的部分和 $P_1$ 在 $z\to y$ 的部分相接得到 $01$ 路径，不合法。证毕。</p>
<p>可以推出合法点对属于相同点双，考虑点双 $B &#x3D; (V, E)$，感性猜测 $B$ 内部最多有一对合法对，接下来证明这一点。</p>
<p>考虑合法点对 $x, y$。令 $x\to y$ 所有 $0$ 路径覆盖点集 $V_0$，所有 $1$ 路径覆盖点集 $V_1$。</p>
<blockquote>
<p> <strong>结论 3.1</strong>：除 $x, y$ 以外，$V_0$ 与 $V_1$ 无交。</p>
</blockquote>
<p>证明：若有交，则可通过 $P_0$ 与 $P_1$ 第一个交点调整得到 $01$ 路径。证毕。</p>
<blockquote>
<p><strong>结论 3.2</strong>：$V_0$ 与 $V_1$ 之间无边。</p>
</blockquote>
<p>证明：若有边 $u\to v$ 满足 $u\in V_0, v\in V_1$，则 $x\to u \to v \to y$ 为 $01$ 路径。证毕。</p>
<blockquote>
<p><strong>性质 4</strong>：对于点数 $\geq 3$ 的点双，任给不同三点 $x, y, z$，存在经过 $x, y, z$ 且以 $x, y$ 为端点的简单路径。</p>
</blockquote>
<p>证明：由性质 1，存在经过 $x, z$ 的简单环 $C$，若 $y\in C$ 显然成立，否则令 $P$ 为任意 $y\to x$ 路径，考虑 $P$ 与 $C$ 的第一个交点 $u$，存在使得 $u \neq x$ 的 $P$，否则 $x$ 为割点：删去 $x$ 后 $y$ 无法到达 $C$ 剩余节点。令 $Q &#x3D; y \to u$ 接上 $u$ 通过环上有 $z$ 的一侧到 $x$ 的路径，则 $Q$ 为经过 $x, y, z$ 且以 $x, y$ 为端点的简单路径。 证毕。</p>
<blockquote>
<p><strong>结论 3.3</strong>：$V_0 \cup V_1 &#x3D; V$。</p>
</blockquote>
<p>证明：对任意 $z\neq x, y$ 应用性质 4，证毕。</p>
<p>考虑 $z\in V_0$，$z’\in V_0$ 且 $(x, y) \neq (z, z’)$。</p>
<blockquote>
<p><strong>结论 4</strong>：存在 $x, y$ 分别到 $z, z’$ 或 $z’, z$ 的两条仅经过 $V_0$ 的不交路径。</p>
</blockquote>
<p>证明：若 $z$ 或 $z’$ 与 $x$ 或 $y$ 相等，显然。否则考虑仅经过 $V_0$ 的 $x\to z \to y$ 的任意 <strong>有序</strong> 路径 $P$，$x\to z’ \to y$ 的任意 <strong>有序</strong> 路径 $P’$，令它们的交点为 $Q$。若 $z\in Q$ 或 $z’\in Q$，可得同时经过 $x, y, z, z’$ 的路径且 $x, y$ 分别在两端，显然。否则将 $Q$ 按照在 $P$ 中的出现顺序标号 $q_1, q_2, \cdots, q_k$，注意 $x, y\in Q$。令 $z’$ 两侧与 $z’$ 距离最近的两个交点分别为 $q_i$ 与 $q_j$，则令<br>$$<br>P’’ &#x3D; x\xrightarrow{P} q_{\min(i, j)} \xrightarrow{P’} z’ \xrightarrow{P’} q_{\max(i, j)} \xrightarrow{P} y<br>$$<br>这样，$P$ 与 $P’’$ 的所有交点按顺序出现，即令 $P$ 与 $P’’$ 的交点为 $Q’$，将 $Q’$ 按照在 $P$ 中的出现顺序标号为 $q_1’, q_2’, \cdots, q_k’$，则 $P’’$ 上 $Q’$ 出现顺序也为 $q_1’, q_2’, \cdots, q_k’$。设 $z$ 两侧与 $z$ 距离最近的两个交点分别为 $q_c$ 与 $q_{c + 1}$，$z’$ 为 $q_d$ 与 $q_{d + 1}$。当 $c\leq d$ 时，令 $P_z &#x3D; x\xrightarrow {P} q_c \xrightarrow{P} z$，$P_{z’} &#x3D; z’\xrightarrow{P’} q_{d + 1} \xrightarrow{P’} y$，合法。当 $c &gt; d$ 时只需反过来构造即可。证毕。</p>
<p>因此，对于任意 $z, z’ \in V_0 \land (x, y) \neq (z, z’) \land z\neq z’$，存在 $x, y$ 分别到 $z, z’$ 或 $z’, z$ 的两条仅经过 $V_0$ 的不交路径。将这两条路径通过 $x, y$ 之间的全 $1$ 路径连起来，得 $z, z’$ 之间不合法。</p>
<p>同理，对于任意 $z, z’ \in V_1 \land (x, y) \neq (z, z’) \land z\neq z’$，$z, z’$ 之间不合法。</p>
<p>而 $z\in V_0$，$z’\in V_1$ 且 $(x, y) \neq (z, z’)$ 之间显然不合法。</p>
<p>综上，$S$ 内部最多有一对合法对。</p>
<p>考虑充要条件，其等价于点双内恰好存在两个点满足同时有 $01$ 出边。</p>
<p>充分性：考虑令唯二的两个点分别为 $x, y$。根据性质 4，考虑任意 $x\to u\to y$，路径必然纯色，否则考虑切换颜色的点，该点同时存在 $01$ 出边。因 $x, y$ 同时有 $0, 1$ 出边，故存在全 $0$ 路径和全 $1$ 路径。</p>
<p>必要性：当 $x, y$ 合法时，根据结论 3.2 可知仅有 $x, y$ 同时有 $01$ 出边。</p>
<p>问题在 $\mathcal{O}(n + m)$ 的时间内解决。</p>
<h3 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">solver</span> &#123;</span><br><span class="line">  <span class="type">int</span> cnt, hd[N], nxt[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v;</span><br><span class="line">    nxt[++cnt] = hd[v], hd[v] = cnt, to[cnt] = u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sz, vis[N];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    vis[id] = <span class="number">1</span>, sz++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = hd[id]; i; i = nxt[i]) <span class="keyword">if</span>(!vis[to[i]]) <span class="built_in">dfs</span>(to[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">        sz = <span class="number">0</span>, <span class="built_in">dfs</span>(i);</span><br><span class="line">        ans += <span class="number">1ll</span> * sz * (sz - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; D, d;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"><span class="type">int</span> S, n, m, node, u[N], v[N];</span><br><span class="line"><span class="type">int</span> dn, dfn[N], low[N], top, stc[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N], g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  dfn[id] = low[id] = ++dn, stc[++top] = id;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> it : e[id]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[it]) &#123;</span><br><span class="line">      <span class="built_in">tarjan</span>(it), low[id] = <span class="built_in">min</span>(low[id], low[it]);</span><br><span class="line">      <span class="keyword">if</span>(low[it] &gt;= dfn[id]) &#123;</span><br><span class="line">        g[++node].<span class="built_in">push_back</span>(id);</span><br><span class="line">        g[id].<span class="built_in">push_back</span>(node);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x != it; ) &#123;</span><br><span class="line">          g[node].<span class="built_in">push_back</span>(x = stc[top--]);</span><br><span class="line">          g[x].<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> low[id] = <span class="built_in">min</span>(low[id], dfn[it]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> have[N], fa[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">gp_hash_table&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> ff)</span> </span>&#123;</span><br><span class="line">  fa[id] = ff;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> it : g[id]) <span class="keyword">if</span>(it != ff) <span class="built_in">dfs</span>(it, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  cin &gt;&gt; S &gt;&gt; n &gt;&gt; m, node = n;</span><br><span class="line">  ans = <span class="number">1ll</span> * n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">    e[u[i]].<span class="built_in">push_back</span>(v[i]), e[v[i]].<span class="built_in">push_back</span>(u[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">tarjan</span>(<span class="number">1</span>), <span class="built_in">dfs</span>(node, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> id, <span class="type">int</span> it) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[id] == fa[it]) <span class="keyword">return</span> fa[id];</span><br><span class="line">    <span class="keyword">if</span>(fa[fa[id]] == it) <span class="keyword">return</span> fa[id];</span><br><span class="line">    <span class="keyword">return</span> fa[it];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> bcc = <span class="built_in">get</span>(u[i], v[i]), msk = <span class="number">1</span> &lt;&lt; (c[i] == <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    mp[bcc][u[i]] |= msk, mp[bcc][v[i]] |= msk;</span><br><span class="line">    have[bcc] |= msk;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> bcc = <span class="built_in">get</span>(u[i], v[i]);</span><br><span class="line">    <span class="keyword">if</span>((have[bcc] &amp; <span class="number">1</span>) ^ <span class="number">1</span>) D.<span class="built_in">add</span>(u[i], v[i]);</span><br><span class="line">    <span class="keyword">if</span>((have[bcc] &amp; <span class="number">2</span>) ^ <span class="number">2</span>) d.<span class="built_in">add</span>(u[i], v[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  ans -= D.<span class="built_in">solve</span>(n) + d.<span class="built_in">solve</span>(n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= node; i++) &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : mp[i]) cnt += it.second == <span class="number">3</span>;</span><br><span class="line">    ans -= cnt == <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层娃的幂塔方程，但他不是。</p>
<p>他想让你求解：<br>$$<br>x ^ x\equiv D \pmod n<br>$$</p>
<p>保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。</p>
<p>你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。</p>
<p>多组测试数据。</p>
<h3 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h3><ul>
<li>Subtask #1（5 points）：$n\leq 20$。</li>
<li>Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。</li>
<li>Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。</li>
<li>Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。</li>
<li>Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。</li>
<li>Subtask #6（13 points）：$n &#x3D; p ^ k(p \in \mathrm{prime})$，$T\leq 100$。</li>
<li>Subtask #7（7 points）：$n &#x3D; p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。</li>
<li>Subtask #8（6 points）：$m\leq 1064$。依赖 Subtask #2。</li>
<li>Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。</li>
<li>Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。</li>
</ul>
<p>对于 $100%$ 的数据：</p>
<ul>
<li>$1\leq T\leq 4\times 10 ^ 4$。</li>
<li>$2\leq n \leq 10 ^ {18}$。</li>
<li>$1\leq D &lt; n$，$D\perp n$。</li>
<li>$2\leq p_1 &lt; p_2 &lt; \cdots &lt; p_k \leq 10 ^ 5$。</li>
</ul>
<h3 id="Sol-0"><a href="#Sol-0" class="headerlink" title="Sol 0"></a>Sol 0</h3><p>验题人 chenxia25 给出了一个假做法：将 $n$ 分解质因数，对于每个 $p ^ k$ 可以单独求解。然后 excrt 合并。</p>
<p>问题在于 $p ^ k$ 很大，且 $p ^ k \times \varphi(p ^ k)$ 可能不互质，但对于单独求解的 $p ^ k$ 得到的解互质（因为有多解），导致同余方程合并时无解。</p>
<h3 id="Sol-1-2"><a href="#Sol-1-2" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>考虑 $n &#x3D; p$。</p>
<p>令 $x_1$ 为 $x \equiv D \pmod p$ 和 $x \equiv 1 \pmod {p - 1}$ 的解，容易发现 $x_1$ 存在。</p>
<h3 id="Sol-2-2"><a href="#Sol-2-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>考虑 $n &#x3D; p ^ k$。</p>
<p>考虑 <strong>增量法构造</strong>。</p>
<p>设 $x_i ^ {x_i} \equiv D \pmod {p ^ i}$。考虑如何 $x_i$ 推到 $x_{i + 1}$。</p>
<p>容易发现令 $x_i \gets x_i + Ip ^ i(p - 1)$ 仍然可行，因此设 $x_{i + 1} &#x3D; x_i + Ip ^ i(p - 1)$。</p>
<p>考虑求出 $I$。因为 $x_{i + 1} ^ {x _{i + 1}} \equiv D \pmod {p ^ {i + 1}}$，所以 $(x_i + Ip ^ i(p - 1)) ^ {x_i + Ip ^ i(p - 1)} \equiv D \pmod {p ^ {i + 1}}$。</p>
<p>因为 $D$ 和 $p ^ i$ 互质，所以 $x_i$ 必然和 $p ^ i$ 互质，所以 $x_i + Ip ^ i(p - 1)$ 和 $p ^ i$ 互质，故和 $p ^ {i + 1}$ 互质。欧拉定理可以用。</p>
<p>因为 $\varphi(p ^ {i + 1}) &#x3D; p ^ i(p - 1)$，所以 $Ip ^ i(p - 1)\equiv 0\pmod {\varphi(p ^ {i + 1})}$，因此 $(x_i + Ip ^ i(p - 1)) ^ {x_i} \equiv D \pmod {p ^ {i + 1}}$。</p>
<p>这是一个 n 次剩余的形式。但是 $p ^ {i + 1}$ 太大，无法使用 BSGS 求解。</p>
<p>注意到 $Ip ^ i(p - 1)$ 的大于 $1$ 次方 $\bmod\ p ^ {i + 1}$ 等于 $0$，考虑 <strong>二项式展开</strong>。<br>$$<br>(x_i + Ip ^ i(p - 1)) ^ {x_i} \equiv x_i ^ {x_i} + \dbinom{x_i} 1 x_i ^ {x_i - 1} \cdot Ip ^ i(p - 1) \equiv D \pmod {p ^ {i + 1}}<br>$$<br>令 $v &#x3D; x_i ^ {x_i}$，则 $vIp ^ i(p - 1)\equiv D - v\pmod {p ^ {i + 1}}$，即 $I\equiv \dfrac{D - v}{v p ^ i (p - 1)} \pmod {p ^ {i + 1}}$。</p>
<p>因为 $v \equiv D \pmod {p ^ i}$，所以 $D  - v$ 是 $p ^ i$ 的倍数。设 $t &#x3D; \dfrac {D - v}{p ^ i}$，则 $I \equiv \dfrac t {v(p - 1)} \pmod p$，显然 $v(p - 1) \perp p$，因此 $v(p - 1)$ 在模 $p$ 意义下的逆元存在，据此可求出 $I$。</p>
<p>注意到 $I &lt; p$，因此 $I p ^ i (p - 1) &lt; p ^ {i + 1}(p - 1)$，构造出的解远小于 $2 ^ {125}$ 这一上界，算法可行。</p>
<p>时间复杂度约为 $\mathcal{O}(T\log m\log n)$。</p>
<h3 id="Sol-3-2"><a href="#Sol-3-2" class="headerlink" title="Sol 3"></a>Sol 3</h3><p>考虑 $n$ 是 square free number。</p>
<p>考虑 <strong>增量法构造</strong>。</p>
<p>设 $n$ 的质因子分别为 $p_1, p_2, \cdots, p_k$，令 $P_i &#x3D; \prod\limits_{j &#x3D; 1} ^ i p_j$，$Q_i &#x3D; \prod\limits_{j &#x3D; 1} ^ i (p_j - 1) $。</p>
<p>设 $x_i \equiv D \pmod {P_i}$，考虑如何从 $x_i$ 推到 $x_{i + 1}$。</p>
<p>如法炮制，发现令 $x_i \gets x_i + IP_iQ_i$ 仍然可行，因此设 $x_{i + 1} &#x3D; x_i + IP_iQ_i$。但是再走二项式展开的老路就行不通了，因为 $P_iQ_i \not \equiv 0 \pmod {\varphi(P_{i + 1})}$。</p>
<p>怎么办呢？注意到若需保证 $x_{i + 1} ^ {x_{i + 1}} \equiv D \pmod {P_{i + 1}}$，因为必然有 $(x_i + IP_iQ_i) ^ {x_i + IP_iQ_i} \equiv D\pmod {P_i}$ 且 $P_i \perp p_{i + 1}$，根据中国剩余定理，只需保证 $(x_i + IP_iQ_i) ^ {x_i + IP_iQ_i} \equiv D\pmod {p_{i + 1}}$。发现还是很不好做，因为 $I$ 同时在底数和指数上，而且 $P_iQ_i \not \equiv 0 \pmod {p_{i + 1} - 1}$。</p>
<p>考虑化去指数上的 $I$。</p>
<p>尝试改变定义，令 $x_{i + 1} &#x3D; x_i + IP_iQ_{i + 1}$，因为 $Q_{i + 1} \perp p_{i + 1}$，这为接下来寻找逆元奠定基础（如果令 $x_{i + 1} &#x3D; x_i + IP_{i + 1}Q_{i + 1}$，实际上相当于给 $x_i$ 加上 $x_{i + 1}$ 的循环节 $\mathrm{lcm}(P_i, \varphi(P_i))$ 的倍数 $P_{i + 1}Q_{i + 1}$ 的倍数，显然不可行，因为当且仅当 $x_i$ 已经符合要求时我们能找到合法的 $x_{i + 1}$）且 $Q_{i + 1} \equiv 0 \pmod {p_{i + 1} - 1}$。</p>
<p>这样一来，上式化简为 $(x_i + IP_iQ_{i + 1}) ^ {x_i} \equiv D\pmod {p_{i + 1}}$。求解该 n 次剩余，令 $g$ 为 $p_{i + 1}$ 的任意原根，$g ^ u \equiv D\pmod {p_{i + 1}}$，则 $I \equiv \dfrac {g ^ {\frac u {x_i}} - x_i}{P_i Q_{i + 1}} \pmod {p_{i + 1}}$。</p>
<p>此时出现了一个严重的问题。分子的 $\dfrac u {x_i}$ 在模 $p_{i +1} - 1$ 意义下求解，但 $x_i$ 和 $p_{i + 1} - 1$ 可能不互质。</p>
<p>尝试修补这个问题。即尝试令 $x_i \perp p_{i + 1} - 1$。</p>
<p>接下来是一步巧妙转化：令 $x’<em>i \gets x_i + JP_iQ_i$，使得 $x_i + JP_iQ_i \perp p</em>{i + 1} - 1$。</p>
<p>但是又出现了问题，即 $P_iQ_i$ 可能和 $p_{i + 1} - 1$ 不互质。</p>
<p>给出引理：若 $a\perp d$，则对于任意 $n\geq 2$，存在 $J\in [0, n - 1]$ 使得 $a + Jd \perp n$。</p>
<p>证明：将 $n$ 分解质因数成 $\prod q_i ^ {c_i}$ 的形式。容易证明 $a \perp q_i ^ {c_i}$ 或 $a + d \perp q_i ^ {c_i}$。若非，说明 $a$ 和 $d$ 同时含有质因子 $q_i$，与假设矛盾。又因为若 $a + Jd \perp q_i ^ {c_i}$，显然 $a + (J + kq_i ^ {c_i})d \perp q_i ^ {c_i}$，即 $J$ 在 $q_i ^ {c_i}$ 模意义下。根据中国剩余定理，得证。</p>
<p>我们发现这是一个递归形式的问题，即若 <strong>归纳假设</strong> $x_i \perp P_iQ_i$，则能找到这样的 $J$ 使得 $x_i + JP_iQ_i \perp p_{i + 1} - 1$，且上述引理给出了一个求解 $J$ 的方法，即对 $p_i - 1$ 分解质因数并 CRT 合并。而 <strong>若条件满足，则结论满足，推出下一轮的条件仍满足</strong>：$x’<em>i \perp p</em>{i + 1} - 1 \Rightarrow x’<em>i \perp P_iQ</em>{i + 1} \Rightarrow x’<em>i + IP_iQ</em>{i + 1} \perp P_iQ_{i + 1} \Rightarrow x_{i + 1}\perp P_iQ_{i + 1}$，又因为 $D\perp P_{i + 1}$，所以 $x_{i + 1} \perp P_{i + 1}Q_{i + 1}$。</p>
<p>同时，当在构造第一步时，Sol 2 满足归纳的初始条件，因为 $x_1 \equiv D \pmod {p_i}$ 且 $x_1 \equiv 1 \pmod {p_1 - 1}$，显然 $x_1\perp P_1Q_1$。</p>
<p>梳理一下上面的思路，发现添加限制 $x_i \perp P_iQ_i$ 之后，<strong>为了满足该性质所需进行的操作的正确性被该性质所保证</strong>，而一开始性质满足，故正确性得以保证。这是归纳法非常巧妙的应用。</p>
<p>这样，我们解决了 $\dfrac u {x_i}$ 可能无解的问题。</p>
<p>$P_iQ_{i + 1}$ 与 $p_{i + 1}$ 互质，其在模 $p_{i + 1}$ 意义下存在逆元。我们得以算出 $I \equiv \dfrac {g ^ {\frac u {x’<em>i}} - x’<em>i}{P_i Q</em>{i + 1}} \pmod {p</em>{i + 1}}$，从 $x_i$ 扩展至 $x_{i + 1}$。</p>
<p>时间复杂度约为 $\mathcal{O}(m ^ {\frac 5 4} + T\omega(n)(\log n + \sqrt m))$：预处理 $m$ 以内每个质数（约 $\frac m {\ln m}$ 个）的原根（单次复杂度 $m ^ {\frac 1 4} \log m$）。BSGS 求解离散对数方程时模数非常小，不需要 <code>map</code> 或哈希表，用数组记录即可。</p>
<p>由于 $I, J$ 均为 $p_{i + 1}$ 级别，因此对应的 $\sum IP_iQ_{i + 1}$ 和 $\sum JP_iQ_i$ 的一个粗略上界为 $\omega(n) n ^ 2$，略小于 $2 ^ {125}$ 的限制，符合要求。若担心超出上界，可以令 $x_i$ 对 $P_iQ_i$ 取模。</p>
<h3 id="Sol-4-2"><a href="#Sol-4-2" class="headerlink" title="Sol 4"></a>Sol 4</h3><p>结合 Sol 2 和 Sol 3，从小到大考虑所有质因子。若相邻两个质因子相同，则使用 Sol 2，将对应的 $p ^ i (p - 1)$ 换成 $P_iQ_i$；否则使用 Sol 3 即可。</p>
<p>接下来是一些细节讨论：</p>
<ul>
<li>在 Sol 2 使用欧拉定理时，需要 $IP_iQ_i \equiv 0 \pmod {\varphi(P_{i + 1})}$。考虑 $P_iQ_i$ 包含 $k$ 个质因子 $p_i$，则 $\varphi(P_{i + 1})$ 也包含 $k$ 个质因子（根据欧拉定理的计算式可得）。同时，$\varphi(P_{i + 1})$ 所有形如 $p_j - 1$ 的乘积项被 $Q_i$ 消去，因此上式仍然成立。</li>
<li>在 Sol 2 二项式展开时，需要 $IP_iQ_i$ 的大于 $1$ 次幂是 $P_{i + 1}$ 的倍数。显然成立，因为 $p_i &#x3D; p_{i + 1}$。</li>
<li>在 Sol 2 求解 $I$ 时，需要 $\dfrac {D - v}{vP_iQ_i}$ 在模 $P_{i + 1}$ 意义下存在。由于分子，分母和模数均为 $P_i$ 的倍数，因此同除后分母 $vQ_i$ 和 $p_{i + 1}$ 互质，这是因为 $v$ 显然和 $p_i$ 互质，且 $p_{i + 1} &#x3D; p_i$。</li>
<li>在 Sol 3 中的归纳假设需要在 Sol 2 中满足，因为我们会交替使用 Sol 2 和 Sol 3。因为 Sol 2 的初始条件成立，所以 $x_i \perp P_iQ_i$。因为 $P_{i + 1}Q_{i + 1}$ 相较于 $P_iQ_i$ 没有增加更多质因子，所以显然 $x_{i + 1}\perp P_{i + 1}Q_{i + 1}$。</li>
</ul>
<p>综上，时间复杂度 $\mathcal{O}(m ^ {\frac 5 4} + T((\omega(n) + \log m)\log n + \omega(n) \sqrt m))$，常数较大。</p>
<p>可以获得 100 分的好成绩。</p>
<p>接下来是一些补充：</p>
<ul>
<li>在求解 $J$ 时，可以每次给 $x_i$ 加上 $P_iQ_i$ 直到符合要求而非 CRT 求解。因为每次加上 $P_iQ_i$ 可以看做从 $0\sim p_{i + 1} - 1$ 中随机选一个数，期望随机 $\dfrac {p_{i + 1} - 1} {\varphi(p_{i + 1} - 1)} - 1$ 次（初始状态算一次）即可得到与 $p_{i + 1} - 1$ 互质的 $x_i + JP_iQ_i$。</li>
<li>笔者认为本题是一道不可多得的数论好题。尽管其形式简单，但却涉及到了 exgcd 求逆元，CRT 合并同余方程，BSGS 求解离散对数和 n 次剩余问题。归纳法用得恰到好处。整个算法优美而简洁，思维难度极高。没有冗余步骤，只是纯粹的数论。</li>
</ul>
<h3 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> Mbe;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> s = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(s)) s = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s)) x = x * <span class="number">10</span> + s - <span class="string">&#x27;0&#x27;</span>, s = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(i128 x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt;= <span class="number">10</span>) <span class="built_in">print</span>(x / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> W = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">namespace</span> math &#123;</span><br><span class="line">  <span class="function">ll <span class="title">ksm</span><span class="params">(ll a, i128 b, ll p)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">      <span class="keyword">if</span>(b &amp; <span class="number">1</span>) s = (i128) s * a % p;</span><br><span class="line">      a = (i128) a * a % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">i128 <span class="title">gcd</span><span class="params">(i128 x, i128 y)</span> </span>&#123;<span class="keyword">return</span> !y ? x : <span class="built_in">gcd</span>(y, x % y);&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, <span class="built_in">void</span>();</span><br><span class="line">    <span class="built_in">exgcd</span>(b, a % b, y, x), y -= a / b * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">exgcd</span>(x, p, x, *<span class="keyword">new</span> <span class="type">int</span>);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> val[N];</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A = <span class="number">1</span>, B = <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B; i++) &#123;</span><br><span class="line">      val[<span class="number">1ll</span> * A * b % p] = i;</span><br><span class="line">      A = <span class="number">1ll</span> * A * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, AA = A; i &lt;= B; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(val[AA] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ans = i * B - val[AA];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, A = <span class="number">1</span>; i &lt; B; i++) &#123;</span><br><span class="line">          val[<span class="number">1ll</span> * A * b % p] = <span class="number">-1</span>;</span><br><span class="line">          A = <span class="number">1ll</span> * A * a % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">      AA = <span class="number">1ll</span> * AA * A % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pc, vis[N], pr[N], g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) pr[++pc] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pc &amp;&amp; i * pr[j] &lt; N; j++) &#123;</span><br><span class="line">      vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> pf[N];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, tmp = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j * j &lt;= tmp; j++)</span><br><span class="line">      <span class="keyword">if</span>(tmp % j == <span class="number">0</span>) &#123;</span><br><span class="line">        pf[++cnt] = j;</span><br><span class="line">        <span class="keyword">while</span>(tmp % j == <span class="number">0</span>) tmp /= j;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>) pf[++cnt] = tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; !g[i]; j++) &#123;</span><br><span class="line">      <span class="type">bool</span> ok = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)</span><br><span class="line">        ok &amp;= math::<span class="built_in">ksm</span>(j, (i - <span class="number">1</span>) / pf[k], i) != <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(ok) g[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">i128 ans;</span><br><span class="line">ll n, D, P[W], Q[W];</span><br><span class="line"><span class="type">int</span> cnt, p[W];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P[<span class="number">0</span>] = Q[<span class="number">0</span>] = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  ll tmp = n;</span><br><span class="line">  <span class="keyword">while</span>(tmp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> pf = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(tmp % pf == <span class="number">0</span>) &#123;</span><br><span class="line">      p[++cnt] = pf, tmp /= pf;</span><br><span class="line">      P[cnt] = P[cnt - <span class="number">1</span>] * pf;</span><br><span class="line">      Q[cnt] = Q[cnt - <span class="number">1</span>] * (pf - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ll M = <span class="number">1ll</span> * p[<span class="number">1</span>] * (p[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">  ans = (D % p[<span class="number">1</span>] * (p[<span class="number">1</span>] - <span class="number">1</span>) * (p[<span class="number">1</span>] - <span class="number">1</span>) + p[<span class="number">1</span>]) % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod p[i + 1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">same</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  ll v = math::<span class="built_in">ksm</span>(ans % P[i + <span class="number">1</span>], ans, P[i + <span class="number">1</span>]);</span><br><span class="line">  i128 I = (D - v + P[i + <span class="number">1</span>]) % P[i + <span class="number">1</span>] / P[i];</span><br><span class="line">  I = I * math::<span class="built_in">inv</span>(Q[i] % mod * (v % mod) % mod, mod) % mod;</span><br><span class="line">  ans += I * P[i] * Q[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">diff</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  i128 prod = (i128) P[i] * Q[i];</span><br><span class="line">  <span class="keyword">while</span>(math::<span class="built_in">gcd</span>(ans, mod - <span class="number">1</span>) != <span class="number">1</span>) ans += prod;</span><br><span class="line">  prod *= mod - <span class="number">1</span>;</span><br><span class="line">  ll u = math::<span class="built_in">BSGS</span>(g[mod], D % mod, mod);</span><br><span class="line">  i128 I = math::<span class="built_in">ksm</span>(g[mod], u * math::<span class="built_in">inv</span>(ans % (mod - <span class="number">1</span>), mod - <span class="number">1</span>), mod);</span><br><span class="line">  I = (I + mod - ans % mod) * math::<span class="built_in">inv</span>(prod % mod, mod) % mod;</span><br><span class="line">  ans += I * prod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>(), D = <span class="built_in">read</span>(), <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">    p[i] == p[i + <span class="number">1</span>] ? <span class="built_in">same</span>(i) : <span class="built_in">diff</span>(i);</span><br><span class="line">    ans %= (i128) P[i + <span class="number">1</span>] * Q[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(ans), <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> Med;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%.3lf\n&quot;</span>, (&amp;Mbe - &amp;Med) / <span class="number">1048576.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALEX_WEI</span></span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">  <span class="built_in">freopen</span>(<span class="string">&quot;0.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="built_in">sieve</span>();</span><br><span class="line">  <span class="built_in">memset</span>(math::val, <span class="number">-1</span>, <span class="built_in">sizeof</span>(math::val));</span><br><span class="line">  <span class="type">int</span> S, T;</span><br><span class="line">  cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">  <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">return</span> cerr &lt;&lt; <span class="built_in">clock</span>() &lt;&lt; endl, <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/29702.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">解析几何</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/59244.html"><span class="level-item">CMD操作</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#A"><span class="level-left"><span class="level-item">1</span><span class="level-item">A</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Sol</span></span></a></li><li><a class="level is-mobile" href="#参考代码"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">参考代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#B"><span class="level-left"><span class="level-item">2</span><span class="level-item">B</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol-1"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Sol</span></span></a></li><li><a class="level is-mobile" href="#参考代码-1"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">参考代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#C"><span class="level-left"><span class="level-item">3</span><span class="level-item">C</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围-2"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol-1"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Sol 1</span></span></a></li><li><a class="level is-mobile" href="#Sol-2"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Sol 2</span></span></a></li><li><a class="level is-mobile" href="#Sol-3"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">Sol 3</span></span></a></li><li><a class="level is-mobile" href="#Sol-4"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">Sol 4</span></span></a></li><li><a class="level is-mobile" href="#参考代码-2"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">参考代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#D"><span class="level-left"><span class="level-item">4</span><span class="level-item">D</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-3"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围-3"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol-1-1"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Sol 1</span></span></a></li><li><a class="level is-mobile" href="#Sol-2-1"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">Sol 2</span></span></a></li><li><a class="level is-mobile" href="#Sol-3-1"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">Sol 3</span></span></a></li><li><a class="level is-mobile" href="#Sol-4-1"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">Sol 4</span></span></a></li><li><a class="level is-mobile" href="#Sol-5"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">Sol 5</span></span></a></li><li><a class="level is-mobile" href="#Sol-6"><span class="level-left"><span class="level-item">4.8</span><span class="level-item">Sol 6</span></span></a></li><li><a class="level is-mobile" href="#Sol-7"><span class="level-left"><span class="level-item">4.9</span><span class="level-item">Sol 7</span></span></a></li><li><a class="level is-mobile" href="#Sol-8"><span class="level-left"><span class="level-item">4.10</span><span class="level-item">Sol 8</span></span></a></li><li><a class="level is-mobile" href="#参考代码-3"><span class="level-left"><span class="level-item">4.11</span><span class="level-item">参考代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#E"><span class="level-left"><span class="level-item">5</span><span class="level-item">E</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-4"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围-4"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol-2"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">Sol</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Part-1"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">Part 1</span></span></a></li><li><a class="level is-mobile" href="#Part-2"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">Part 2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考代码-4"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">参考代码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#F"><span class="level-left"><span class="level-item">6</span><span class="level-item">F</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目描述-5"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">题目描述</span></span></a></li><li><a class="level is-mobile" href="#数据范围-5"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">数据范围</span></span></a></li><li><a class="level is-mobile" href="#Sol-0"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Sol 0</span></span></a></li><li><a class="level is-mobile" href="#Sol-1-2"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Sol 1</span></span></a></li><li><a class="level is-mobile" href="#Sol-2-2"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">Sol 2</span></span></a></li><li><a class="level is-mobile" href="#Sol-3-2"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">Sol 3</span></span></a></li><li><a class="level is-mobile" href="#Sol-4-2"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">Sol 4</span></span></a></li><li><a class="level is-mobile" href="#参考代码-5"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">参考代码</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IT/"><span class="tag">IT</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Ubuntu/"><span class="tag">Ubuntu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%80%E5%B7%A7/"><span class="tag">技巧</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB/"><span class="tag">生活</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">28</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%96%87/"><span class="tag">语文</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%98%E8%A7%A3/"><span class="tag">题解</span><span class="tag">13</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/image/head_logo.png" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://code.bdstatic.com/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://code.bdstatic.com/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://code.bdstatic.com/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://code.bdstatic.com/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>