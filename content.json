{"posts":[{"title":"C++ Socket 网络编程","text":"在一切开始之前要进行Socket编程需要导入一些头文件 $\\textbf{For Windows}$ 1#include &lt;winsock2.h&gt; 如果使用MSVC编译器，则再写一行 1#pragma comment(lib,&quot;ws2_32.lib&quot;) 如果使用MinGW编译器，则在编译选项里加入-lwsock32 $\\textbf{For Linux}$ 1234#include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; Socket 原理看图 各个函数介绍WSAStartup：异步启动套接字命令1、函数原型： 1234int WSAAPI WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData); 2、参数： wVersionRequested:大部分人用的是2.2、所以我也用的2.2 lpWSAData:指向WSADATA数据结构的指针，该数据结构将接收Windows套接字实现的详细信息 3、返回值： 返回0执行正确否则失败 4、代码范例： 123456WSADATA wsdata;if (WSAStartup(MAKEWORD(2, 2), &amp;wsdata)){ std::cout &lt;&lt; &quot;init socket failed!&quot; &lt;&lt; std::endl; WSACleanup(); return FALSE;} socket:创建套接字1、函数原型： 1SOCKET socket(int af,int type,int protocl); 2、参数：af:第一个参数(af)指定地址族,对于TCP/IP协议的套接字他有以下两个参数： AF_INET，PF_INET IPV4协议 PF_INET6 IPV6协议 其他还有很多协议这里不做介绍 type:用于设置套接字通信的类型，有流式套接字（SOCKET_STREAM）和数据包套接字（SOCK_DGRAM） SOCK_STREAM TCP连接，提供有序化的、可靠的、双向连接的字节流。支持带外数据传输 SOCK_DGRAM UDP连接 protocl:用于制定某个协议的特定类型，即type类型中的某个类型，通常一种协议只有一种类型，该参数可以直接被设置为0；如果协议有多种类型，则需要指定协议类型 3、返回值 如果没有错误发生，socket()返回一个与建立的套接字相关的描述符。 否则它返回值INVALID_SOCKET，错误码可通过调用WSAGetLastError()函数得到 4、代码范例: 12345678//定义一个套接字 作为服务端SOCKET s_server;s_server = socket(PF_INET, SOCK_STREAM, 0);if (s_server == INVALID_SOCKET){ std::cout &lt;&lt; &quot;create socket fail&quot; &lt;&lt; std::endl; WSACleanup(); return FALSE;} bind:绑定套接字1、函数原型： 12345678910111213141516171819202122232425262728293031323334353637383940 int bind( SOCKET s, const sockaddr *addr, int namelen ); @ SOCKET s:要绑定的套接字 @const sockaddr *addr：指向要分配给绑定套接字的本地地址的sockaddr结构的指针 struct sockaddr { ushort sa_family; char sa_data[14]; }; struct sockaddr_in { short sin_family; //指定协议家族 ipv4 or ipv6 u_short sin_port; //指定端口号 struct in_addr sin_addr; //指定地址 也可以是所有ip 参数为：INADDR_ANY char sin_zero[8]; //没有特殊意义不用管 }; struct in_addr { union { struct { u_char s_b1; u_char s_b2; u_char s_b3; u_char s_b4; } S_un_b; struct { u_short s_w1; u_short s_w2; } S_un_w; u_long S_addr; //ip地址 } S_un; }; @int namelen:sockaddr结构的指针的大小 2、返回值如果没有错误发生，bind()返回0。否则返回值SOCKET_ERROR，错误码可通过调用WSAGetLastError()函数得到 3、代码范例: 123456789101112//填充服务端信息SOCKADDR_IN server_addr;server_addr.sin_family = AF_INET;server_addr.sin_port = htons(8224);server_addr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); //数据绑定服务器 s_server为服务端套接字if(bind(s_server, (SOCKADDR*)&amp;server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR){ std::cout &lt;&lt; &quot;Binding Socket fail!&quot; &lt;&lt; std::endl; WSACleanup(); return FALSE;} listen:监听1、函数原型： 1234567int PASCAL FAR listen ( _In_ SOCKET s, _In_ int backlog); @SOCKET s：服务端的socket，也就是socket函数创建的 @int backlog：挂起的连接队列的最大长度,由用户自主选择。但是我们知道我们电脑处理线程的时候用一时间只能处理n个线程、这里也是一样的原理，我们创建的服务器他可能不支持你定义的这个队列长度的用户比如：一个洗手间 只能同时供4个人使用 而这个时候来了8个人 那么其他4个人则需要外面等待。 所以一般填写这个参数为SOMAXCONN作用是让系统自动选择最合适的个数不同的系统环境不一样，所以这个合适的数也不一样 2、返回值 成功返回0失败返回SOCKET_ERROR具体错误码：WSAGetLastError()得到 3、代码示例： 123456//监听if (listen(s_server, 1) == SOCKET_ERROR){ std::cout &lt;&lt; &quot;Listening Socket fail........!&quot; &lt;&lt; std::endl; WSACleanup(); return FALSE;} accept:接受连接请求1、函数原型： 123456789int WSAAPI connect ( SOCKET s, const struct sockaddr FAR* name, int namelen //socket address结构的字节数 ); @SOCKET s：发出连接请求的套接字的描述符 @const struct sockaddr FAR* name：对等方的套接字的地址、就是你创建客户端的套接字时绑定ip和端口号的套接字地址 @namelen： 套接字类型大小 2、返回值如果没有错误发生，connect()返回0。否则返回值SOCKET_ERROR，错误码可通过调用WSAGetLastError()函数得到。 3、代码范例： 123456789101112//填充服务端信息//SOCKADDR_IN server_addr;//server_addr.sin_family = AF_INET;//server_addr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);//server_addr.sin_port = htons(8224);//创建套接字//SOCKET client= socket(AF_INET, SOCK_STREAM, 0);if (connect(client, (SOCKADDR*)&amp;server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR){ std::cout &lt;&lt; &quot;Error: connect server failed !&quot; &lt;&lt; std::endl; WSACleanup(); return -1;} send：发送数据1、函数原型： 123456789101112int WSAAPI send( SOCKET s, const char FAR * buf, int len, int flags); @SOCKET s： 已连接的套接字描述符 @const char FAR * buf：指向存有发送数据的缓冲区的指针 @int len：缓冲区buf中数据长度 @int flags:一般为0,为阻塞发送 即发送不成功会一直阻塞，直到被某个信号终端终止，或者直到发送成功为止。指定MSG_NOSIGNAL，表示当连接被关闭时不会产生SIGPIPE信号指定MSG_DONTWAIT 表示非阻塞发 2、返回值 如果没有错误发生，send()返回总共发送的字节数（注意，这可能比len指示的长度小）。否则它返回SOCKET_ERROR，错误码可通过调用WSAGetLastError()函数得到。 2、代码范例： 1234567char temp[1024] = {0};snprintf(temp, sizeof(temp), &quot;%s&quot;, detectInfo);int sendLen = send(socket, (char*)temp, sizeof(temp), 0);if (sendLen &lt; 0){ std::cout &lt;&lt; &quot;Error: send info to server failed !&quot; &lt;&lt; std::endl; return -1;} recv：接收数据1、函数原型： 12345678910int PASCAL FAR recv ( SOCKET s, writes_bytes_to_(len, return) __out_data_source(NETWORK) char FAR * buf, int len, int flags); @SOCKET s：已连接的套接字描述符。 @char FAR * buf：指向接收输入数据缓冲区的指针 @int len：buf参数所指缓冲区的长度 @int flags：一般为0 2、返回值如果没有错误发生，recv()返回收到的字节数。如果连接被关闭，返回0。否则它返回SOCKET_ERROR，错误码可通过调用WSAGetLastError()函数得到。 3、代码示例： 123456char recv_buf[8192] = {0};int recv_len = recv(socket, recv_buf, sizeof(recv_buf), 0);if (recv_len &lt; 0) { std::cout &lt;&lt; &quot;Error: receive info from server failed !&quot; &lt;&lt; std::endl; return -1;} closesocket, WSACleanup:释放socket使用完后续如果不再使用,一定要释放相关资源 1234//关闭套接字 参数：需要关闭的套接字描述符closesocket(s_server);//释放DLL资源WSACleanup();","link":"/posts/17235.html"},{"title":"C++ 运算符优先级","text":"如下表 优先级 操作符 描述 结合性 1 ()[]-&gt;.::++– 调节优先级的括号操作符数组下标访问操符通过指向对象的指针访问成员的操作符通过对象本身访问成员的操作符作用域操符后置自增操作符后置自减操作符 从左到右 2 !~++–-+*&amp;(type)sizeof 逻辑取反操作符按位取反(按位取补)前置自增操作符前置自减操作符一元取负操作符一元取正操作符解引用操作符取地址操作符类型转换操作符返回对象占用的字节数操作符 从右到左 3 -&gt;* .* 在指针上通过指向成员的指针访问成员的操作符在对象上通过指向成员的指针访问成员的操作符 从左到右 4 */% 乘法操作符除法操作符取余数操作符 从左到右 5 +- 加法操作符减法操作符 从左到右 6 &lt;&lt; &gt;&gt; 按位左移操作符按位右移操作符 从左到右 7 &lt; &lt;= &gt; &gt;= 小于比较操作符小于或等于比较操作符大于比较操作符大于或等于比较操作符 从左到右 8 ==!= 等于比较操作符不等于比较操作符 从左到右 9 &amp; 按位与操作符 从左到右 10 ^ 按位异或操作符 从左到右 11 | 按位或操作符 从左到右 12 &amp;&amp; 逻辑与操作符 从左到右 13 || 逻辑或操作符 从左到右 14 ?: 三元条件操作符 从右到左 15 =+=-=*=/=%=&amp;=^=|=&lt;&lt;=&gt;&gt;= 赋值操作符复合赋值操作符(加法)复合赋值操作符(减法)复合赋值操作符(乘法)复合赋值操作符(除法)复合赋值操作符(取余)复合赋值操作符(按位与)复合赋值操作符(按位异或)复合赋值操作符(按位或)复合赋值操作符(按位左移)复合赋值操作符(按位右移) 从右到左 16 , 逗号操作符 从左到右","link":"/posts/35951.html"},{"title":"BalanceTree平衡树","text":"题目描述您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入 $x$ 数 删除 $x$ 数(若有多个相同的数，因只删除一个) 查询 $x$ 数的排名(排名定义为比当前数小的数的个数 $+1$ ) 查询排名为 $x$ 的数 求 $x$ 的前驱(前驱定义为小于 $x$，且最大的数) 求 $x$ 的后继(后继定义为大于 $x$，且最小的数) 输入格式第一行为 $n$，表示操作的个数,下面 $n$ 行每行有两个数 $\\text{opt}$ 和 $x$，$\\text{opt}$ 表示操作的序号( $ 1 \\leq \\text{opt} \\leq 6 $ ) 输出格式对于操作 $3,4,5,6$ 每行输出一个数，表示对应答案 样例 #1样例输入 #11234567891011101 1064654 11 3177211 4609291 6449851 841851 898516 819681 4927375 493598 样例输出 #112310646584185492737 数据范围对于 $100%$ 的数据，$1\\le n \\le 10^5$，$|x| \\le 10^7$ 分析平衡树可以做什么 插入 $x$ 数 删除 $x$ 数(若有多个相同的数，因只删除一个) 查询 $x$ 数的排名(排名定义为比当前数小的数的个数 $+1$ ) 查询排名为 $x$ 的数 求 $x$ 的前驱(前驱定义为小于 $x$，且最大的数) 求 $x$ 的后继(后继定义为大于 $x$，且最小的数) 算法分析旋转树（平衡树核心）1234567891011121314void pushup(int pos){ tree[pos].size=tree[tree[pos].s[0]].size+tree[tree[pos].s[1]].size+tree[pos].cnt; //合并当前节点数据}void rotate(int pos){ int fa=tree[pos].fa,grandfa=tree[fa].fa; //父节点，父亲的父亲节点 int fich = tree[fa].s[1]==pos; tree[fa].s[fich]=tree[pos].s[fich^1]; tree[tree[pos].s[fich^1]].fa=fa; tree[pos].s[fich^1]=fa; tree[fa].fa=pos; tree[grandfa].s[tree[grandfa].s[1]==fa]=pos; tree[pos].fa=grandfa; pushup(fa),pushup(pos);} 插入1234567891011void insert(int val){ int pos=root,fa=0; //从根开始 while(pos&amp;&amp;tree[pos].val!=val) fa=pos,pos=tree[pos].s[val&gt;tree[pos].val]; //根据BIT性质寻找离val最接近的值 if(pos)tree[pos].cnt++; //如果已经存在当前值的点，直接将次数加1 else{ //如果没有 pos=++idx; //新建点 tree[fa].s[val&gt;tree[fa].val]=pos; //根据BIT性质选择插入位置 tree[pos].init(fa,val); //初始化 } splay(pos,0); //为方便后续操作，将当前节点设为根} $Model$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std;const int N = 1000005; inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}struct node{ int s[2]; int fa; int val; int cnt; int size; void init(int fanew,int valnew){ fa=fanew,val=valnew; cnt=size=1; }}tree[N];int root,n,idx;void pushup(int pos){ tree[pos].size=tree[tree[pos].s[0]].size+tree[tree[pos].s[1]].size+tree[pos].cnt;}void rotate(int pos){ int fa=tree[pos].fa,grandfa=tree[fa].fa; int fich = tree[fa].s[1]==pos; tree[fa].s[fich]=tree[pos].s[fich^1]; tree[tree[pos].s[fich^1]].fa=fa; tree[pos].s[fich^1]=fa; tree[fa].fa=pos; tree[grandfa].s[tree[grandfa].s[1]==fa]=pos; tree[pos].fa=grandfa; pushup(fa),pushup(pos);}void splay(int pos,int goal){ while(tree[pos].fa!=goal){ int fa=tree[pos].fa,grandfa=tree[fa].fa; if(grandfa!=goal) ((tree[fa].s[0]==pos)^(tree[grandfa].s[0]==fa))? rotate(pos):rotate(fa); rotate(pos); } if(goal==0) root=pos;}void find(int val){ int pos=root; while(tree[pos].s[val&gt;tree[pos].val]&amp;&amp;val!=tree[pos].val)pos=tree[pos].s[val&gt;tree[pos].val]; splay(pos,0);}int get_pre(int val){ find(val); int pos=root; if(tree[pos].val&lt;val)return pos; pos=tree[pos].s[0]; while(tree[pos].s[1])pos=tree[pos].s[1]; return pos;}int get_aft(int val){ find(val); int pos=root; if(tree[pos].val&gt;val)return pos; pos=tree[pos].s[1]; while(tree[pos].s[0])pos=tree[pos].s[0]; return pos;}void del(int val){ int pre=get_pre(val); int aft=get_aft(val); splay(pre,0);splay(aft,pre); int del=tree[aft].s[0]; if(tree[del].cnt&gt;1)tree[del].cnt--,splay(del,0); else tree[aft].s[0]=0; }int get_rank(int val){ find(val); return tree[tree[root].s[0]].size;}int get_kth(int k){ int pos=root; while(true){ int fich=tree[pos].s[0]; if(tree[fich].size+tree[pos].cnt&lt;k){ k-=(tree[fich].size+tree[pos].cnt); pos=tree[pos].s[1]; }else{ if(tree[fich].size&gt;=k)pos=tree[pos].s[0]; else break; } } splay(pos,0); return tree[pos].val;}void insert(int val){ int pos=root,fa=0; while(pos&amp;&amp;tree[pos].val!=val) fa=pos,pos=tree[pos].s[val&gt;tree[pos].val]; if(pos)tree[pos].cnt++; else{ pos=++idx; tree[fa].s[val&gt;tree[fa].val]=pos; tree[pos].init(fa,val); } splay(pos,0);}int main(){ insert(-1e9);insert(1e9); n=read(); while(n--){ int opt=read(),num=read(); if(opt==1)insert(num); if(opt==2)del(num); if(opt==3)cout&lt;&lt;get_rank(num)&lt;&lt;endl; if(opt==4)cout&lt;&lt;get_kth(num+1)&lt;&lt;endl; if(opt==5)cout&lt;&lt;tree[get_pre(num)].val&lt;&lt;endl; if(opt==6)cout&lt;&lt;tree[get_aft(num)].val&lt;&lt;endl; } return 0;}","link":"/posts/638.html"},{"title":"BellmanFord的优化：SPFA算法","text":"关于SPFA 它死了 致敬NOI凉心出题人以及…… 单源最短路奇技淫巧之SPFA算法😎😎😎 用途 可以用SPFA求有负边权图的最短路 求出图中是否存在负环 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;inline int read(){int x=0,f=1;char c=getchar();for(;!isdigit(c);c=getchar())if(c=='-')f=-1;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);return x*f;}int n,m,s;struct node{ int to; int val;};vector&lt;node&gt;ro[100005];int dis[100005],cnt[100005];bool vis[100005];queue&lt;int&gt;Q;bool spfa(){ memset(dis,0x3f3f3f3f,sizeof dis); dis[s]=0,vis[s]=true/* 这里的vis[]表示的是当前点是否在队列中 */;Q.push(s); while(Q.size()){ int now = Q.front();Q.pop(); vis[now]=false; for(node to:ro[now]){ if(dis[to.to]&gt;dis[now]+to.val){ dis[to.to]=dis[now]+to.val;//进行一次松弛操作 cnt[to.to]=cnt[now]+1;//松弛次数+1 if(cnt[to.to]&gt;=n)return false; /* 每一轮松弛最少使一条边松至最短,那么最多松弛n-1次就能找到最短路 如果松弛了超过n-1次,则说明存在负环 */ if(!vis[to.to])Q.push(to.to),vis[to.to]=true; } } } return true;}int main(){ n=read(),m=read(),s=read(); for(int i = 1,u,v,w;i&lt;=m;i++){ u=read(),v=read(),w=read(); ro[u].push_back((node){v,w}); } bool NO_NEGTIVE_CIRCLE = spfa();//判断有无负环 if(NO_NEGTIVE_CIRCLE){ for(int i = 1;i&lt;=n;i++){ cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;; } }else cout&lt;&lt;-1; return 0;} 后话使用SPFA,我们可以完成差分约束","link":"/posts/14141.html"},{"title":"CF888G Xor-MST题解","text":"题意 给定 $n$ 个结点的无向完全图。每个点有一个点权为 $a_i$。连接 $i$ 号结点和 $j$ 号结点的边的边权为 $a_i\\oplus a_j$。 求这个图的 MST 的权值。 $1\\le n\\le 2\\times 10^5$，$0\\le a_i&lt; 2^{30}$。 分析这道题是对01Trie的应用 乍一看以为是Kruskal,然后发现边数太多不现实。 我们将点权插入01Trie，任意两个点权之间的异或值就是它们到根节点路径上的对应节点的异或值的累加，那么我们就不难发现，树上两个叶子节点的LCA深度越深，它们的异或结果也就越小。 观察到 我们在01Trie中插入点权时，只有$n-1$个节点是有$2$个儿子，其他节点都只有$0/1$个儿子，这$n-1$个节点正好符合树形结构。 那我们只需要递归查找01Trie,对于每个有$2$个子节点的节点，我们对左子树包含的所有点权与右子树中异或值最小的子树合并即可。 另外，我们可以发现，若将点权从小到大排序后插入，可以得到每一颗子树所代表的点权值是连续的，这可以方便我们的查询。 AC Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,root,idx=0;long long a[200005];struct node{ int ch[2]; int l_lim,r_lim;}tr[200005*20];void insert(int &amp;pos,int dep,long long val,int id){ if(!pos)pos=++idx; if(!tr[pos].l_lim)tr[pos].l_lim=id;//维护当前子树所代表点权范围 tr[pos].r_lim=id;//维护当前子树所代表点权范围 if(dep==-1)return; int c = (val&gt;&gt;dep)&amp;1; insert(tr[pos].ch[c],dep-1,val,id);}long long query(int pos,int dep,long long val){//查询异或和最小的板子 if(dep==-1)return 0; int c = (val&gt;&gt;dep)&amp;1;//当前位的值 if(tr[pos].ch[c])return query(tr[pos].ch[c],dep-1,val); //如果存在这个子树，那么当前位异或和可以为0 else return query(tr[pos].ch[c^1],dep-1,val)+(1&lt;&lt;dep); //如果不存在，那么当前位异或和为1&lt;&lt;dep}long long dfs(int pos,long long dep){ if(dep==-1)return 0; if(tr[pos].ch[0]&amp;&amp;tr[pos].ch[1]){//如果存在2个子节点 long long res= 9223372036854775807ll; for(int i = tr[tr[pos].ch[0]].l_lim;i&lt;=tr[tr[pos].ch[0]].r_lim;i++){//遍历左子树所代表的点权范围 res=min(res,query(tr[pos].ch[1],dep-1,a[i])/* 在右子树中查询与点权i异或和最小值 */+1LL*(1&lt;&lt;dep)/* 当前pos位的下一位一定是不同的，加上该点异或值 */); } return dfs(tr[pos].ch[0],dep-1)+dfs(tr[pos].ch[1],dep-1)+res;//统计左右子树答案 }else if(tr[pos].ch[0]) return dfs(tr[pos].ch[0],dep-1); else return dfs(tr[pos].ch[1],dep-1);}int main(){ n=read(); for(int i = 1;i&lt;=n;i++) a[i]=read(); sort(a+1,a+n+1);//将点权排序后插入 for(int i =1;i&lt;=n;i++) insert(root,31,a[i],i); cout&lt;&lt;dfs(root,31); return 0;}","link":"/posts/64709.html"},{"title":"CF1333E-Road to 1600题解","text":"构造题？ 人类智慧题挺震惊的，我居然想到了怎么构造它 题意 棋盘上有$1$到$N^2$的值 $\\mathrm{Rook}$可以走前后左右四个方向，$\\mathrm{Queen}$可以走八个方向 $\\mathrm{Rook}$和$\\mathrm{Queen}$都会挑他们能走到的最小的格子跳过去 如果当前他们跳不到任何格子，可以花$1 \\mathrm{vun}$跳过去 如果棋盘都被跳过了，就结束 给你棋盘大小$N \\times N$,要求你构造一个棋盘，使$\\mathrm{Rook}$花的钱比$\\mathrm{Queen}$少，若果没有，输$-1$。 思路我们手模一些棋盘可以发现 当$N\\le2$时一定无解。因为棋盘任意可达。 当$N = 3$时，我们可以通过构造一组$3 \\times 3$棋盘使得$\\mathrm{Queen}$最后必须使用$1 \\mathrm{vun}$跳过去。比如我构造的是$$\\begin{matrix}8&amp;7&amp;6 \\ 5&amp;1&amp;2 \\ 4&amp;9&amp;3\\end{matrix}$$$\\mathrm{Queen}$在最后一步必须从$8$跳到$9$而消耗$1 \\mathrm{vun}$，而$\\mathrm{Rook}$不用 当$N&gt;3$时，我们可以发现只要上下左右中有比当前位置值大$1$的位置，$\\mathrm{Rook}$和$\\mathrm{Queen}$一定会往那里走，因此我们在$3 \\times 3$棋盘基础上，向下向右扩展边长，最后把$\\mathrm{Rook}$和$\\mathrm{Queen}$全部引导到$3 \\times 3$棋盘中$1$的位置即可即我们可以构造出这样的$4 \\times 4$棋盘$$\\begin{matrix}8+7&amp;7+7&amp;6+7&amp;{\\color{blue}{6}} \\ 5+7&amp;1+7&amp;2+7&amp;{\\color{blue}{7}} \\ 4+7&amp;9+7&amp;3+7&amp;{\\color{red}{5}} \\ {\\color{red}{1}}&amp;{\\color{red}{2}}&amp;{\\color{red}{3}}&amp;{\\color{red}{4}}\\end{matrix}$$也就是$$\\begin{matrix}15&amp;14&amp;13&amp;{\\color{blue}{6}} \\ 12&amp;8&amp;9&amp;{\\color{blue}{7}} \\ 11&amp;16&amp;10&amp;{\\color{red}{5}} \\ {\\color{red}{1}}&amp;{\\color{red}{2}}&amp;{\\color{red}{3}}&amp;{\\color{red}{4}}\\end{matrix}$$ 再如$5 \\times 5$ $$\\begin{matrix}24&amp;23&amp;22&amp;{\\color{blue}{15}}&amp;{\\color{red}{1}} \\21&amp;17&amp;18&amp;{\\color{blue}{16}}&amp;{\\color{red}{2}} \\20&amp;25&amp;19&amp;{\\color{red}{14}}&amp;{\\color{red}{3}} \\{\\color{red}{10}}&amp;{\\color{red}{11}}&amp;{\\color{red}{12}}&amp;{\\color{red}{13}}&amp;{\\color{red}{4}} \\{\\color{red}{9}}&amp;{\\color{red}{8}}&amp;{\\color{red}{7}}&amp;{\\color{red}{6}}&amp;{\\color{red}{5}}\\end{matrix}$$ 其中我们看到蓝色部分需要调换顺序。这样就完成了构造。 AC Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int a[555][555],n,cnt=0;int ds[4][2]={{0,1},{-1,0},{1,0},{0,-1}};void dfs(int x,int y,int d,int maxn){ if(maxn==3) return ; if(y==2&amp;&amp;x==4){ a[1][4]=++cnt; a[2][4]=++cnt; return; } if(y==maxn&amp;&amp;x==maxn){ a[y][x]=++cnt; dfs(x+ds[d+1][0],y+ds[d+1][1],d+1,maxn); }else if(y==maxn&amp;&amp;x==1){ a[y][x]=++cnt; if(y-1==3)return; a[y-1][x]=++cnt; dfs(x+1,y-1,2,maxn-1); }else if(y==1&amp;&amp;x==maxn){ a[y][x]=++cnt; if(x-1==3)return; a[y][x-1]=++cnt; dfs(x-1,y+1,0,maxn-1); }else{ a[y][x]=++cnt; dfs(x+ds[d][0],y+ds[d][1],d,maxn); }}int main(){ n=read(); if(n&lt;=2){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } else if(n&gt;3){if(n&amp;1){ a[1][n]=++cnt; dfs(n,2,0,n); }else{ a[n][1]=++cnt; dfs(2,n,2,n); }} a[3][1]=cnt+4, a[3][2]=cnt+9, a[3][3]=cnt+3, a[2][1]=cnt+5, a[2][2]=cnt+1, a[2][3]=cnt+2, a[1][1]=cnt+8, a[1][2]=cnt+7, a[1][3]=cnt+6;//关键部分3x3矩阵的构造！ for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=n;j++){ cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; }}","link":"/posts/62261.html"},{"title":"CMD操作","text":"设置全屏 123456789101112void full_screen(){ HWND hwnd = GetForegroundWindow(); int cx = GetSystemMetrics(SM_CXSCREEN); /* 屏幕宽度 像素 */ int cy = GetSystemMetrics(SM_CYSCREEN); /* 屏幕高度 像素 */ LONG l_WinStyle = GetWindowLong(hwnd,GWL_STYLE); /* 获取窗口信息 */ /* 设置窗口信息 最大化 取消标题栏及边框 */ SetWindowLong(hwnd,GWL_STYLE,(l_WinStyle | WS_POPUP | WS_MAXIMIZE) &amp; ~WS_CAPTION &amp; ~WS_THICKFRAME &amp; ~WS_BORDER); SetWindowPos(hwnd, HWND_TOP, 0, 0, cx, cy, 0);} 获取字体大小12345678910111213141516171819202122COORD get_font_size(){ COORD font_size; HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); /* 字体信息 */ struct CONSOLE_FONT { DWORD index; COORD dim; } cfi; typedef COORD (WINAPI *PROCGETCONSOLEFONTSIZE)(HANDLE, DWORD); typedef BOOL (WINAPI *PROCGETCURRENTCONSOLEFONT)(HANDLE, BOOL, struct CONSOLE_FONT*); HMODULE hKernel32 = GetModuleHandle(&quot;kernel32&quot;); PROCGETCONSOLEFONTSIZE GetConsoleFontSize = (PROCGETCONSOLEFONTSIZE)GetProcAddress(hKernel32,&quot;GetConsoleFontSize&quot;); PROCGETCURRENTCONSOLEFONT GetCurrentConsoleFont = (PROCGETCURRENTCONSOLEFONT)GetProcAddress(hKernel32,&quot;GetCurrentConsoleFont&quot;); GetCurrentConsoleFont(handle, FALSE, &amp;cfi); /* 获取当前字体索引信息 */ font_size = GetConsoleFontSize(handle, cfi.index); /* 获取当前字体宽高信息[字符宽度及高度所占像素数] */ return font_size;} 获取窗口大小(单位：像素)12345678COORD get_screen_size(){ HWND hwnd = GetForegroundWindow(); COORD size; size.cx = GetSystemMetrics(SM_CXSCREEN); /* 屏幕宽度 */ size.cy = GetSystemMetrics(SM_CYSCREEN); /* 屏幕高度 */ return size;} 获取窗口大小(单位：字符)(依赖于get_font_size())1234567891011121314COORD get_screen_size(){ HWND hwnd = GetForegroundWindow(); HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); /* 标准输出缓冲区句柄 */ int cx = GetSystemMetrics(SM_CXSCREEN); /* 屏幕宽度 */ int cy = GetSystemMetrics(SM_CYSCREEN); /* 屏幕高度 */ COORD size = get_font_size(); char cmd[32] = { 0 }; size.X=cx/size.X, size.Y=cy/size.Y; return size;} 设置颜色1234567void SetColor(int fore=7,int back=0){ unsigned char m_color = fore; m_color += (back &lt;&lt; 4); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), m_color); return;} 隐藏光标1234void HideCursor(){ CONSOLE_CURSOR_INFO cursor_info={1,0}; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE),&amp;cursor_info);} 光标移动1234567void GoToxy(int x,int y){ COORD coord; coord.X=y;//这里调换了顺序，否则就是将输出指针移到y行，x列 coord.Y=x; HANDLE a=GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(a,coord);} 缓慢输出12345678void slowout(char *p){ while(1){ if(*p!=0) printf(&quot;%c&quot;,*p++); else break; Sleep(20); } Sleep(500);} 键盘、鼠标检测初始化1#define KEY_DOWN(VK_NONAME) ((GetAsyncKeyState(VK_NONAME) &amp; 0x8000) ? 1:0) 键符对照123456789101112131415161718192021222324252627282930313233343536373839404142434445常量名 对应按键 取值—————————————————————————————————————————————————————————VK_LBUTTON 鼠标左键 0x01VK_RBUTTON 鼠标右键 0x02VK_CANCEL Ctrl + Break 0x03VK_MBUTTON 鼠标中键 0x04VK_BACK Backspace 键 0x08VK_TAB Tab 键 0x09VK_RETURN 回车键 0x0DVK_SHIFT Shift 键 0x10VK_CONTROL Ctrl 键 0x11VK_MENU Alt 键 0x12VK_PAUSE Pause 键 0x13VK_CAPITAL Caps Lock 键 0x14VK_ESCAPE Esc 键 0x1BVK_SPACE 空格键 0x20VK_PRIOR Page Up 键 0x21VK_NEXT Page Down 键 0x22VK_END End 键 0x23VK_HOME Home 键 0x24VK_LEFT 左箭头键 0x25VK_UP 上箭头键 0x26VK_RIGHT 右箭头键 0x27VK_DOWN 下箭头键 0x28VK_SNAPSHOT Print Screen 键 0x2CVK_Insert Insert 键 0x2DVK_Delete Delete 键 0x2E'0' – '9' 数字 0 - 9 0x30 - 0x39'A' – 'Z' 字母 A - Z 0x41 - 0x5AVK_LWIN 左WinKey(104键盘才有) 0x5BVK_RWIN 右WinKey(104键盘才有) 0x5CVK_APPS AppsKey(104键盘才有) 0x5DVK_NUMPAD0 小键盘 0 键 0x60VK_NUMPAD1 小键盘 1 键 0x61VK_NUMPAD2 小键盘 2 键 0x62VK_NUMPAD3 小键盘 3 键 0x63VK_NUMPAD4 小键盘 4 键 0x64VK_NUMPAD5 小键盘 5 键 0x65VK_NUMPAD6 小键盘 6 键 0x66VK_NUMPAD7 小键盘 7 键 0x67VK_NUMPAD8 小键盘 8 键 0x68VK_NUMPAD9 小键盘 9 键 0x69VK_F1 - VK_F24 功能键F1 – F24 0x70 - 0x87VK_NUMLOCK Num Lock 键 0x90VK_SCROLL Scroll Lock 键 0x91 检测鼠标按下1234567891011121314151617181920212223while (1){ if (KEY_DOWN(MOUSE_MOVED)){//判断左键 printf(&quot;你按了鼠标左键&quot;); } else{ printf(&quot;你没按鼠标左键&quot;); } printf(&quot;\\n&quot;); if (KEY_DOWN(MOUSE_EVENT)){//判断右键 printf(&quot;你按了鼠标右键&quot;); } else{ printf(&quot;你没按鼠标右键&quot;); } printf(&quot;\\n&quot;); if (KEY_DOWN(MOUSE_WHEELED)){//判断滚轮 printf(&quot;你按了鼠标滚轮&quot;); } else{ printf(&quot;你没按鼠标滚轮&quot;); } system(&quot;cls&quot;);} 检测鼠标位置123POINT p;GetCursorPos(&amp;p);printf(&quot;(%d,%d)\\n&quot;,p.x,p.y); 多线程1234567#include&lt;iostream&gt;#include&lt;thread&gt;using namespace std;int main(){ thread th1(...);//第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。 thread th2(...);//第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。}","link":"/posts/59244.html"},{"title":"CRT中国剩余定理-exCRT拓展中国剩余定理","text":"中国剩余定理定义中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \\cdots, n_k$ 两两互质）： $$\\begin{cases}x &amp;\\equiv a_1 \\pmod {n_1} \\x &amp;\\equiv a_2 \\pmod {n_2} \\ &amp;\\vdots \\x &amp;\\equiv a_k \\pmod {n_k} \\\\end{cases}$$ 过程 计算所有模数的积 $n$； 对于第 $i$ 个方程： 计算 $m_i=\\frac{n}{n_i}$； 计算 $m_i$ 在模 $n_i$ 意义下的逆元 $m_i^{-1}$； 计算 $c_i=m_im_i^{-1}$（不要对 $n_i$ 取模）。 方程组在模 $n$ 意义下的唯一解为：$x=\\sum_{i=1}^k a_ic_i \\pmod n$。 证明我们需要证明上面算法计算所得的 $x$ 对于任意 $i=1,2,\\cdots,k$ 满足 $x\\equiv a_i \\pmod {n_i}$。 当 $i\\neq j$ 时，有 $m_j \\equiv 0 \\pmod {n_i}$，故 $c_j \\equiv m_j \\equiv 0 \\pmod {n_i}$。当 $i = j$ 时, 有 $c_i \\equiv m_i \\cdot (m_i^{-1} \\bmod {n_i}) \\equiv 1 \\pmod {n_i}$，所以我们有： $$\\begin{aligned}x&amp;\\equiv \\sum_{j=1}^k a_jc_j &amp;\\pmod {n_i} \\ &amp;\\equiv a_ic_i &amp;\\pmod {n_i} \\ &amp;\\equiv a_i \\cdot m_i \\cdot (m^{-1}_i \\bmod n_i) &amp;\\pmod {n_i} \\ &amp;\\equiv a_i &amp;\\pmod {n_i}\\end{aligned}$$ 即对于任意 $i=1,2,\\cdots,k$，上面算法得到的 $x$ 总是满足 $x\\equiv a_i \\pmod{n_i}$，即证明了解同余方程组的算法的正确性。 因为我们没有对输入的 $a_i$ 作特殊限制，所以任何一组输入 ${a_i}$ 都对应一个解 $x$。 另外，若 $x\\neq y$，则总存在 $i$ 使得 $x$ 和 $y$ 在模 $n_i$ 下不同余。 故系数列表 ${a_i}$ 与解 $x$ 之间是一一映射关系，方程组总是有唯一解。 实现12345678910int CRT(int a[], int n[]){ int N=1, ans=0; for(int i =1;i&lt;=n;i++) N*=n[i];//计算所有模数的乘积 for(int i = 1;i&lt;=n;i++){ int c=N/n[i],x,y; exgcd(c,n[i],x,y);//exgcd求逆元 其中x即为逆元 (ans+=(a[i]*c*x%N))%=N; } return (ans%N+N)%N;//映射到范围内的最小整数} 拓展中国剩余定理定义拓展中国剩余定理可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \\cdots, n_k$ 不一定两两互质）： $$\\begin{cases}x &amp;\\equiv a_1 \\pmod {n_1} \\x &amp;\\equiv a_2 \\pmod {n_2} \\ &amp;\\vdots \\x &amp;\\equiv a_k \\pmod {n_k} \\\\end{cases}$$ 此时CRT已不可行 其构造解 $x = \\sum_{i=1}^{n}r_ic_ic_i^{-1} \\pmod {M}$其中$c_ix \\equiv 1 \\pmod {m_i}$, 即$c_ix+ m_iy=1=\\gcd(c_i,mi)$根据裴蜀定理，$c_i,m_i$应该互质，$c_i = \\frac{m_i \\times \\cdots \\times m_n}{m_i}$如果$c_i,m_i$不互质，则$c_i^{-1}$不存在，算法无效 过程 前两个方程：$x \\equiv r_1 \\pmod {m_i}, \\ x \\equiv r_2 \\pmod {m_2}$转化为不定方程：$x=m_1p+r_1=m_2q+r_2$,则$m_1p-m_2q=r_2-r_1$ 由裴蜀定理，当$\\gcd(m_1,m_2) \\nmid (r_1-r_2)$时，无解当$\\gcd(m_1,m_2) \\mid (r_1-r_2)$时，有解可以通过扩展欧几里得算法解出来一组可行解 $(p, q)$； 则原来的两方程组成的模方程组的解$x\\equiv b\\pmod M$，其中 $b=m_1p+a_1$，$M=\\text{lcm}(m_1, m_2)$。 多个方程按照$1$至$3$合并即可，$n$个方程合并$n-1$次。 实现12345678910111213141516long long mul(long long a,long long b,long long mod){ long long c=a*b-(long long)((long double)a*b/mod+0.5)*mod; return c&lt;0?c+mod:c;}//有些情况下会暴longlong 用龟速乘解决一下long long exCRT(){ for(long long i = 2,x,y;i&lt;=n;i++){ long long d=exgcd(m[i-1],m[i],x,y); if((r[i]-r[i-1])%d!=0)return -1; x=mul(x,((r[i]-r[i-1])/d),(m[i]/d)); x=(x%(m[i]/d)+m[i]/d)%(m[i]/d); r[i]=m[i-1]*x+r[i-1]; m[i]=m[i-1]*m[i]/d; } return (r[n]%m[n]+m[n])%m[n];//区范围内最小正值}","link":"/posts/20279.html"},{"title":"DEBUG备忘录","text":"写代码 题目中要输入$n$、$m$,不要在应该用$n$的地方用$m$。 long long要开吗？你开了吗？哪些要开那些不要开？整形默认是int,1要写成1LL。 树形结构：递归往下的时候$l$和$r$有写反吗？ 取模了吗？你真的取完了吗？有些取模是负数，需要(a%mod+mod)%mod 未完待续。。。 知识性 ASCII码是7位二进制编码，以8位存储。 二分查找找不到数据时： 最多查找次数： $\\left \\lfloor \\log_2n \\right \\rfloor+1$ 最少查找次数：$\\left \\lfloor \\log_2(n+1) \\right \\rfloor$ 布尔型变量占用1字节，8比特。 冒泡排序为稳定排序，时间复杂度为$O(n^2)$。 十进制小数转二进制：乘2取整，顺序排列 123456789101112131415如：0.625=（0.101）B0.625*2=1.25======取出整数部分10.25*2=0.5========取出整数部分00.5*2=1==========取出整数部分1再如：0.7=（0.1 0110 0110...）B0.7*2=1.4========取出整数部分10.4*2=0.8========取出整数部分00.8*2=1.6========取出整数部分10.6*2=1.2========取出整数部分10.2*2=0.4========取出整数部分00.4*2=0.8========取出整数部分00.8*2=1.6========取出整数部分10.6*2=1.2========取出整数部分10.2*2=0.4========取出整数部分0 各种排序的时间复杂度: 类型 最好 平均 最坏 稳定性 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ 稳定 希尔排序(插入排序优化) $O(n)$ $O(n \\times 1.3)$ $O(n^2)$ 不稳定 选择排序 $O(n)$ $O(n^2)$ $O(n^2)$ 不稳定 堆排序 $O(n \\log_2n)$ $O(n \\log_2n)$ $O(n \\log_2n)$ 不稳定 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ 稳定 快速排序 $O(n \\log_2n)$ $O(n \\log_2n)$ $O(n^2)$ 不稳定 归并排序 $O(n \\log_2n)$ $O(n \\log_2n)$ $O(n \\log_2n)$ 稳定 逻辑运算符优先级:$﹁$高于$∧$，$∧$高于$∨$，$∨$高于$→$ 时间复杂度主定理：对于时间复杂度满足如下递推式：$T(n)=aT(\\frac{n}{b})+f(n)$如果$f\\left ( n \\right ) &lt; O\\left ( n^{log_ba} \\right )$，则$T\\left ( n \\right ) = \\Theta \\left ( n^{log_ba} \\right )$ 如果$f\\left ( n \\right ) = \\Theta \\left ( n^{log_ba}log^{k}n \\right )$，则$T\\left ( n \\right ) = \\Theta \\left ( n^{log_ba} log^{k+1}n \\right )$ 如果$f\\left ( n \\right ) &gt; \\Omega \\left ( n^{log_ba} \\right )$，则$T\\left ( n \\right ) = \\Theta \\left (f\\left ( n \\right ) \\right )$ 例子： $T\\left ( n \\right ) = 3T\\left ( n/2 \\right ) + n^{2}$ 解$a = 3, b = 2, f\\left ( n \\right ) = n^{2}$ 那么$log_ba = log_23$ ，那么$f\\left ( n \\right ) &gt; n^{2}$，根据主定理有$T\\left ( n \\right ) = O\\left ( n^{2} \\right )$ $T\\left ( n \\right ) = 4T\\left ( n/2 \\right ) + n^{2}$解$a = 4, b = 3, f\\left ( n \\right ) = n^{2}$那么$log_ba = log_24$，那么$f\\left ( n \\right ) = n^{2}$，根据主定理有$T\\left ( n \\right ) = O\\left ( n^{2}log_2n \\right )$ $T\\left ( n \\right ) = T\\left ( n/2 \\right ) + 2^{n}$，解$a = 1, b = 2, f\\left ( n \\right ) = 2^{n}$那么$log_ba = log_21$，那么$f\\left ( n \\right ) &gt; n^{0}$，根据主定理有$T\\left ( n \\right ) = O\\left ( 2^{n} \\right )$ $T\\left ( n \\right ) = 2^{n}T\\left ( n/2 \\right ) + n^{n}$，解$a = 2^{n}, b = 2, f\\left ( n \\right ) = n^{n}$那么因为a不是常数，所以不适用于主定理 $T\\left ( n \\right ) = 16T\\left ( n/4 \\right ) + n$，解$a=16, b = 4, f\\left ( n \\right ) = n$那么$log_ba = log_416$，那么$f\\left ( n \\right ) &lt; n^{2}$，根据主定理有$T\\left ( n \\right ) = O\\left ( n^{2} \\right )$ 渐进符号 符号 含义 想当于 Θ（西塔） 紧确界。 相当于”=” O （大欧） 上界。 相当于”&lt;=” o（小欧） 非紧的上界。 相当于”&lt;” Ω（大欧米伽） 下界。 相当于”&gt;=” ω（小欧米伽） 非紧的下界。 相当于”&gt;”","link":"/posts/60267.html"},{"title":"Dijkstra迪杰斯特拉算法","text":"题目描述给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。 数据保证你能从 $s$ 出发到任意点。 输入格式第一行为三个正整数 $n, m, s$。第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。 输出格式输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。 样例样例输入 #112345674 6 11 2 22 3 22 4 11 3 53 4 31 4 4 样例输出 #110 2 4 3 提示$1 \\leq n \\leq 10^5$； $1 \\leq m \\leq 2\\times 10^5$； $s = 1$； $1 \\leq u_i, v_i\\leq n$； $0 \\leq w_i \\leq 10 ^ 9$, $0 \\leq \\sum w_i \\leq 10 ^ 9$。 算法分析使用堆优化（优先队列） 12345678struct Qnode{ int w; int po; inline bool operator &lt;(const Qnode &amp;x)const{ return w&gt;x.w; }};priority_queue&lt;Qnode&gt;q; 初始化dis为极大值 12for(int i = 1;i&lt;=n;i++) dis[i]=2147483647; dis[f]=0; 主体 1234567891011121314151617dis[f]=0; q.push((Qnode){0,f}); while(!q.empty()){ Qnode now =q.top();q.pop(); int u=now.po; if(vis[u]) continue; vis[u]=1; if(road[u].size()){ for(int i = 0;i&lt;=road[u].size()-1;i++){ if(dis[road[u][i].to]&gt;dis[u]+road[u][i].val){ dis[road[u][i].to]=dis[u]+road[u][i].val;//更新路径 pre[road[u][i].to]=u; q.push((Qnode){dis[road[u][i].to],road[u][i].to}); } } } } Model12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct node{ int to; int val;};struct Qnode{ int w; int po; inline bool operator &lt;(const Qnode &amp;x)const{ return w&gt;x.w; }};priority_queue&lt;Qnode&gt;q;vector &lt;node&gt; road[100004];int vis[100004],pre[100004];int dis[100004];int main(){ int n,m,f,u,v,w; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;f); for(int i = 1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); road[u].push_back(node{v,w}); } for(int i = 1;i&lt;=n;i++) dis[i]=2147483647; dis[f]=0; q.push((Qnode){0,f}); while(!q.empty()){ Qnode now =q.top();q.pop(); int u=now.po; if(vis[u])continue; vis[u]=1; if(road[u].size()){ for(int i = 0;i&lt;=road[u].size()-1;i++){ if(dis[road[u][i].to]&gt;dis[u]+road[u][i].val){ dis[road[u][i].to]=dis[u]+road[u][i].val; pre[road[u][i].to]=u; q.push((Qnode){dis[road[u][i].to],road[u][i].to}); } } } } for(int i=1;i&lt;=n;i++){ printf(&quot;%d &quot;,dis[i]); } return 0;}","link":"/posts/4385.html"},{"title":"Floyed算法","text":"题目描述有向图中存在$n$个节点，每个节点之间有道路相连，共有$m$条道路，给出$Q$此询问，包含起点和终点,请输出两点间最短距离$L\\min$. 输入描述第一行$3$个整数$n,m,Q$.第$2$到$(m+1)$行，输入每条路的起点$u_i$，终点$v_i$，权值$w_i$.第$(m+2)$到$(m+Q+2)$行，输入起点$U_i$，终点$V_i$. 输出描述$m$行，每行一个整数，表示$U_i$到$V_i$的最短路径$L_i\\min$,如果到不了，输出No way.. $Model:$1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAXN 105#define refer127 2139062143using namespace std;int dist[MAXN][MAXN],p[MAXN][MAXN],n,m,q;int main(){ memset(p,255,sizeof(p)); memset(dist,127,sizeof(dist)); int u,v,w; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i = 1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w); dist[u][v]=w; p[u][v]=u; } for(int i = 1;i&lt;=n;i++) dist[i][i]=0; for(int i = 1;i&lt;=n;i++){ for(int j = 1;j&lt;=n;j++){ if(dist[j][i]!=0&amp;&amp;dist[j][i]!=refer127){ for(int w = 1;w&lt;=n;w++){ if(dist[i][w]!=refer127){ if(dist[j][w]&gt;dist[j][i]+dist[i][w]){ dist[j][w]=dist[j][i]+dist[i][w]; p[j][w]=p[i][w]; } } } } } } for(int i = 1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); if(dist[u][v]==refer127){ printf(&quot;No way.\\n&quot;); }else printf(&quot;%d\\n&quot;,dist[u][v]); }}","link":"/posts/30865.html"},{"title":"GCD欧几里得算法&amp;exGCD拓欧","text":"定义$GCD$即最大公约数,若$a_1,a_2,a_3$的最大公约数为$x$,则记为： $x=GCD(a_1,a_2,a_3)=(a_1,a_2,a_3);$$LCM$即最小公倍数,若$a_1,a_2,a_3$的最小公倍数为$x$,则记为：$x=LCM(a_1,a_2,a_3)=(a_1,a_2,a_3);$$exGCD$即拓展欧几里得定理,用来在已知$(a,b)$时,求解一组$(p,q)$,使得$pa+qb=GCD(a,b)$。 性质 $a,b$两个数的最大公约数乘以它们的最小公倍数就等于$a$和$b$本身的乘积。证明： 设$d=gcd(a,b),ao=a/d,bo=b/d$。根据最大公约数的定义,有$gcd(ao,bo)=1$。再根据最小公倍数的定义,有$lcm(ao,bo)$=$aob0$于是$lcm(a,b)=lcm(aod,bod)=lcm(ao,bo)d=aobod=a*b/d$。证毕。 求解$GCD$ 辗转相除法 用来求两个数的最大公约数,又称欧几里得算法, 其原理就是：$GCD(x,y)=GCD(x,y-x)$。 原理的证明如下： 设$z|x,z|y$,则$z|(y-x)$。 设$z$不是$x$的因子,则$z$不是$x,y-x$的公因子。 设$z|x,z$不是$y$的因子,则$z$不是$x,y-x$的公因子。 代码实现如下： 1234567int GCD(int x,int y){ return y==0? x:GCD(y,x%y);}//或者下面这个int GCD(int x,int y){ while(y^=x^=y^=x%=y);return x;} 使用欧几里得算法求最大公约数的复杂度为$O(\\log(a+b))$。欧几里得算法是最常用的求最大公约数的方法。不过,因为高精度除法(取模)不容易实现,需要做高精度运算时,可考虑用更相减损术代替欧几里得算法。 更相减损术 $\\forall a,b \\in N,a \\geq b$,有$gcd(a,b)=gcd(b,a-b)=gcd(a,a-b)$ $\\forall a,b \\in N,gcd(2a,2b)=2gcd(a,b)$ 证明： 根据最大公约数的定义,后者显然成立,我们主要证明前者。对于$a,b$的任意公约数$d$,因为$d|a,d|b$,所以$d|(a-b)$。因此$d$也是$b,a-b$的公约数。反之亦成立。故$a,b$的公约数集合与$b,a一b$的公约数集合相同。于是它们的最大公约数自然也相等。对于$a,a-b$同理。 证毕。 $exGCD$扩展欧几里德算法是用来在已知$(a,b)$时,求解一组$(p,q)$,使得$pa+qb=GCD(a,b)$。因为$GCD(a,b)=GCD(b,a%b)$ ,所以$pa+qb=GCD(a,b)=GCD(b,a%b)=pb+qa%b=pb+q(a-a/bb=qa+(p-a/b*q)*b$,这样它就将$a$与$b$的线性组合化简为$b$与$a%b$的线性组合。根据前边的结论：$a$和$b$都在减小,当$b$减小到$0$时,就可以得出$p=1,q=0$。然后递归回去就可以求出最终的p和q了。 12345678910111213int extended_gcd(int a，int b，int &amp;x，int &amp;y){ int ret，tmp; if (!b){ x=1; y=0; return a; } ret=extended_gcd(b，a % b，x，y); tmp=x; x=y; y=tmp-a / b * y; return ret; } 一种更为高效简单的做法： 123456789int exgcd(int a,int b,int &amp;x,int &amp;y){ if(b==0){ x=1,y=0; return a; } int d=exgcd(b, a%b, y, x); y-=a/b*x; return d;}","link":"/posts/4852.html"},{"title":"Competition-2022&#x2F;7&#x2F;30","text":"T1题目描述小明有一个正整数$n$，小明把它用汉字写出来。 但是小明比较笨，不会写正整数格式，只会把每一位写成汉字。 比如说，小明会把$324$写成“三二四”，而不是“三百二十四”。 接下来，小明比较无聊，他会数出他写出的这些字的笔画总数，作为新的$n$，然后重新开始这个过程。 现在已经知道小明一开始的正整数$n$，并且已知他会把这个过程进行$n$次。请你求出他第$k$次写下的所有字的笔画数，以帮助小明验证自己的答案。 输入格式第一行一个正整数$T$，表示数据组数。 接下来$T$行，每行两个正整数$n,k$。 输出格式$T$行，每行一个正整数，表示答案。 输入输出样例输入 #1123454234 2102 3111 2394 1 输出 #11234144310 输入 #21234567891091 12 13 14 15 16 17 18 19 1 输出 #2123456789123544222 说明/提示样例 #1 解释如下： 对第一组数据，小明第一次会写下“二三四”，共 10 画；第二次会写下“一零”，共 14 画（“零”有 13 画）。对第二组数据，小明第一次会写下“一零二”，共 16 画；第二次会写下“一六“，共 5 画；第三次会写下“五”，共四画。对第三组数据，小明第一次会写下“一一一”，共 3 画；第二次会写下“三”，共 3 画。对第四组数据，小明第一次会写下“三九四”，共 10 画。 样例 #2 提供了 1…9 的每个数的汉字笔画数。而“零”共有 13 画。 数据范围对 30% 的数据，$n \\leq 1000, k \\leq 2$。 对 70% 的数据，$n \\leq 10^9, k \\leq 1000$。 对 100% 的数据，$n \\leq 10^{18}, k \\leq 10^9, T \\leq 500$。 $AC$ $Code$T1.cpp >folded12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;typedef long long LL;const int a[10] = { 13, 1, 2, 3, 5, 4, 4, 2, 2, 2 };LL f(LL n) { if (n) return a[n % 10] + f(n / 10); else return 0; }int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { LL n; int k; scanf(&quot;%lld%d&quot;, &amp;n, &amp;k); while (k) { n = f(n); k--; if (1 &lt;= n &amp;&amp; n &lt;= 3) break; if (n == 4 || n == 5) { if (k &amp; 1) n ^= 1; break; } } printf(&quot;%lld\\n&quot;, n); } return 0;} T2题目描述小北写了一份 thoypn 语言代码。 thoypn 语言代码里只有两种语句：输出语句和循环语句。 而且 thoypn 语言类似 python 语言，用缩进来决定语法： 每一行只能写一条语句。 如果某条循环语句前面有 n 个 tab 的缩进，那么他后面至少一行要有大于等于 n + 1 个 tab 的缩进，这些行就是这条循环语句的循环体。而且他后面一行必须恰好有 n + 1个 tab 的缩进，不能多不能少。 不能凭空出现缩进，也就是说输出语句后面不能增加缩进。程序的第一行也必须不缩进。由于小北水平不行，他总是忘记加缩进。 华华想知道，通过给这份代码添加缩进，可以得到多少种不同的合法 thoypn 程序？ 输入格式第一行一个正整数 T，表示数据组数。 接下来每组数据中： 第一行一个正整数 n， 表示小北写的数据组数； 第二行一个长为 n、仅包含 F 和 P 的字符串 s。 如果 s 中第 i 个字符是 F，表示小北写的代码中第 i 行有一条循环语句；反之表示小北写的代码中第 i 行有一条输出语句。 输出格式对每组数据，输出一行一个正整数，表示答案。由于答案可能很大，你只需要输出对$10^9+7$取模得到的结果 输入输出样例输入123456734FFFP4FPFP4FPPP 输出123123 说明/提示对第一组数据，只有 1234for for for print 这一种方案。 对第二组数据，有 1234for print for print 和 1234for printfor print 两种方案。 对第三组数据，循环语句可能包含 1 或者 2 或者 3 条输出语句，因此有三种方案。 数据范围对 30% 的数据，$n \\leq 10$。 对 50% 的数据，$n \\leq 100$。 另有 20% 的数据，至多有 1010 个 F。 对 100% 的数据，$T \\leq 5, n \\leq 1000$。 $AC$ $Code$T2.cpp >folded12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1050;const int mod = 1000000007;char s[N];int f[N];int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { int n; scanf(&quot;%d%s&quot;, &amp;n, s); f[0] = 1; int k = 0; for (int i = 0; i &lt; n - 1; ++i) if (s[i] == 'F') { for (int j = ++k; j &gt; 0; --j) f[j] = f[j - 1]; f[0] = 0; } else { for (int j = k, t = 0; j &gt;= 0; --j) f[j] = t = (t + f[j]) % mod; } int ans = 0; for (int j = 0; j &lt;= k; ++j) ans = (ans + f[j]) % mod; printf(&quot;%d\\n&quot;, s[n - 1] == 'P' ? ans : 0); } return 0;} T3题目描述在很久很久以前，有一个王国。王国的国王手下有一些骑士。 我们把骑士们编号为骑士 1，骑士 2，…，骑士$n$。他们每次都是按照这个顺序出行，因此只有相邻的骑士（即骑士$i$和骑士$i+1$）之间才会认识。 某天国王需要他们做一件任务。为了做这件任务，骑士们需要分为若干队伍；每个队伍要么只有一名骑士，要么有两名互相认识的骑士（即相邻的骑士）。 每名骑士被评定了一个能力值。如果一个队伍只有一名骑士，那么队伍能力值就是这名骑士的能力值；如果队伍里有两名骑士，那么队伍能力值就是这两名骑士的能力值的和。 为了尽可能完成任务，国王需要队伍能力值的极差最小。 即设$A$是所有队伍能力值的最小值$B$是队伍能力值的最大值，则国王需要最小化$B-A$。请你计算出这个最小值。 输入格式第一行一个正整数$n$，表示骑士的数量。 第二行$n$个正整数$a_1, \\dots, a_n$，其中$a_i$表示第$i$名骑士的能力值。 输出格式一行一个正整数，表示答案。 输入输出样例输入 #11241 2 3 4 输出 #111 输入 #212108 6 3 4 9 2 7 2 9 3 输出 #216 说明/提示样例解释： 对样例 1，可以把骑士$1, 2$划分为一队，骑士$3$和骑士$4$各自分为一队。 对样例 2，可以$8, 6, [3, 4], [9, 2], [7, 2], [9, 3]$这样分组（方括号括起来的表示分在同一组），队伍能力值分别为$8, 6, 7, 11, 9, 12$，最大值减最小值为$12 - 6 = 6$。 数据范围对 10% 的数据，$n \\leq 5$。 对 20% 的数据，$n \\leq 25$。 对 40% 的数据，$n \\leq 100$。 对 60% 的数据，$n \\leq 1000$。 对 100% 的数据，$3 \\leq n \\leq 10^5, 1 \\leq a_i \\leq 10^9$。 $AC$ $Code$T3.cpp >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 100050;struct Msg { bool f[2][2]; Msg() {} Msg(bool a) { f[0][0] = a; f[0][1] = f[1][0] = true; f[1][1] = false; } friend Msg Merge(const Msg &amp;l, const Msg &amp;r, bool b) { Msg ans; for (int i = 0; i &lt; 2; ++i) for (int j = 0; j &lt; 2; ++j) ans.f[i][j] = (l.f[i][0] &amp;&amp; r.f[0][j]) || (l.f[i][1] &amp;&amp; r.f[1][j] &amp;&amp; b); return ans; }} msgv[N * 4];bool A[N], B[N];inline void upd(int o, int l, int r) { if (l == r) msgv[o] = Msg(A[l]); else { int mid = (l + r) / 2; msgv[o] = Merge(msgv[o &lt;&lt; 1], msgv[o &lt;&lt; 1 | 1], B[mid]); }}void Build(int o, int l, int r) { if (l == r) A[l] = false; else { int mid = (l + r) / 2; B[mid] = false; Build(o &lt;&lt; 1, l, mid); Build(o &lt;&lt; 1 | 1, mid + 1, r); } upd(o, l, r);}void ModifyA(int o, int l, int r, int x, bool a) { if (l &gt; x || r &lt; x) return; if (l == r) A[l] = a; else { int mid = (l + r) / 2; ModifyA(o &lt;&lt; 1, l, mid, x, a); ModifyA(o &lt;&lt; 1 | 1, mid + 1, r, x, a); } upd(o, l, r);}void ModifyB(int o, int l, int r, int x, bool b) { if (l &gt; x || r &lt;= x) return; int mid = (l + r) / 2; ModifyB(o &lt;&lt; 1, l, mid, x, b); ModifyB(o &lt;&lt; 1 | 1, mid + 1, r, x, b); if (mid == x) B[mid] = b; upd(o, l, r);}int n, V[N];struct Team { int ty, i, v; // 0 : A, 1 : B Team() {} Team(int ty, int i) : ty(ty), i(i) { v = V[i] + ty * V[i + 1]; } bool operator&lt;(const Team &amp;r) const { return v &lt; r.v; }} T[N * 2];int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;V[i]); int m = 0; for (int i = 1; i &lt;= n; ++i) T[m++] = Team(0, i); for (int i = 1; i &lt; n; ++i) T[m++] = Team(1, i); Build(1, 1, n); std::sort(T, T + m); int ans = 0x7fffffff; for (int i = 0, j = 0; i &lt; m; ++i) { while (!msgv[1].f[0][0] &amp;&amp; j &lt; m) { (T[j].ty ? ModifyB : ModifyA)(1, 1, n, T[j].i, true); ++j; } if (!msgv[1].f[0][0]) break; if (T[j - 1].v - T[i].v &lt; ans) ans = T[j - 1].v - T[i].v; (T[i].ty ? ModifyB : ModifyA)(1, 1, n, T[i].i, false); } printf(&quot;%d\\n&quot;, ans);} T4题目描述猫猫（这是一个人名）想要去魔法王国旅游。 魔法王国有$n$座城市。 由于魔法王国的人会传送，他们懒得修道路，只建了$n-1$条道路供旅行者通行。每条道路连接两座城市，并且这$n-1$条道路恰好把$n$座城市都连了起来。 猫猫在旅行前给每座城市评定了一个“魅力值”。她想要多逛一些城市，让自己经过的城市的魅力值总和最大。（即使她多次经过同一座城市，也不会重复计算魅力值） 但是魔法王国由于某些原因，不允许旅行者通过同一座城经过$k$次，因此猫猫不一定能把所有城市全部经过一遍。 （每进入一次城市就算经过一次，不允许路过城市而不进去） 请你帮猫猫规划路线，并输出最大的魅力值总和。 猫猫会从$1$号城市进入魔法王国；首次进入也算一次经过。并且由于魔法王国所有城市中都提供传送到王国外的服务，她不需要最后回到$1$号城市。 输入格式第一行两个正整数$n, k$，表示城市数量，每座城市能经过的次数。 第二行$n$个正整数$a_1, \\dots, a_n$，其中 $a_k$表示第$k$座城市的魅力值。 接下来$n-1$行，每行两个正整数$x$和$y$，表示存在一条连接第$x$座城市和第$y$座城市的道路。 保证这$n-1$条道路一定能把$n$座城市都连接起来。 输出格式一行一个正整数，表示经过城市的魅力值总和的最大值。 输入输出样例输入 #1123456789101110 15 6 6 4 7 3 9 9 3 91 32 102 31 81 75 26 23 92 4 输出 #1126 输入 #2123456789101110 25 6 6 4 7 3 9 9 3 91 32 102 31 81 75 26 23 92 4 输出 #2145 输入 #31234567891011121314151617181920212223242526272829303130 33 88 109 39 83 8 152 172 176 41 151 29 149 151 189 147 125 50 184 117 115 40 195 102 107 176 188 43 67 151 41 101 211 271 32 293 63 253 283 55 247 268 309 149 3011 1511 1711 3012 1612 1813 2416 1916 2016 2316 2616 3018 2422 2829 30 输出 #312667 说明/提示在样例 1 中，可以沿$1, 3, 2, 10$这样的路线走，可以获得$1, 2, 3, 10$四个城市的魅力值，一共为$5 + 6 + 6 + 9 = 26$。 在样例 2 中，可以沿$1, 8, 1, 3, 9, 3, 2, 5, 2, 10$这样的路线走，可以获得$1, 2, 3, 5, 8, 9, 10$七个城市的魅力值，一共为$5 + 6 + 6 + 7 + 9 + 3 + 9 = 45$。 数据范围 数据占比 n 的范围 k 的范围 10% $n \\leq 10$ $k \\leq 10$ 20% $n \\leq 10^5$ $k = 1$ 20% $n \\leq 10^5$ $k = 2$ 20% $n \\leq 1000$ $k \\leq 10^5$ 30% $n \\leq 10^54$ $k \\leq 10^5$ 对所有数据$a_n \\leq 2000$。 $AC$ $Code$T4.cpp >folded1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;const int N = 100050;std::vector&lt;int&gt; T[N];int n, A[N], f[N], g[N], k;inline bool cmp(int x, int y) { return f[x] &gt; f[y]; }void dfs(int x, int fa) { for (int y : T[x]) if (y != fa) dfs(y, x); std::sort(T[x].begin(), T[x].end(), cmp); if (fa) T[x].pop_back(); int l = T[x].size(), S = 0, u = 0; for (int i = 0; i &lt; k - 1 &amp;&amp; i &lt; l; ++i) S += f[T[x][i]]; f[x] = S + A[x]; g[x] = 0; if (k - 1 &lt; l) u = f[T[x][k - 1]]; for (int i = 0; i &lt; k - 1 &amp;&amp; i &lt; l; ++i) g[x] = std::max(g[x], S - f[T[x][i]] + g[T[x][i]] + u); for (int i = k - 1; i &lt; l; ++i) g[x] = std::max(g[x], S + g[T[x][i]]); g[x] += A[x];}int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;A[i]); for (int i = 1, x, y; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;y); T[x].push_back(y); T[y].push_back(x); } dfs(1, 0); printf(&quot;%d\\n&quot;, std::max(f[1], g[1])); return 0;}","link":"/posts/21054.html"},{"title":"Git版本控制","text":"入门使Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。 使用您当前目录作为Git仓库，我们只需使它初始化。 1git init 使用我们指定目录作为Git仓库。 1git init newrepo 从现在开始，我们将假设您在Git仓库根目录下，除非另有说明。 添加新文件我们有一个仓库，但什么也没有，可以使用add命令添加文件。 1git add filename 可以使用add ... 继续添加任务文件。 提交版本现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。 为此，我们将它们提交到仓库。 1git commit -m &quot;Adding files&quot; 如果您不使用-m，会出现编辑器来让你写自己的注释信息。 当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。 1git commit -a -m &quot;Changed some files&quot; git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。 千万注意，-a不会造成新文件被提交，只能修改。 发布版本我们先从服务器克隆一个库并上传。 1git clone ssh://example.com/~/www/project.git 现在我们修改之后可以进行推送到服务器。 1git push ssh://example.com/~/www/project.git 取回更新如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。 1git pull 从非默认位置更新到指定的url。 1git pull http://git.example.com/project.git 删除如何你想从资源库中删除文件，我们使用rm。 1git rm &quot;file&quot; 分支与合并分支在本地完成，速度快。要创建一个新的分支，我们使用branch命令。 1git branch test branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。 1git checkout test 第一个分支，或主分支，被称为&quot;master&quot;。 1git checkout master 对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。 12git checkout mastergit merge test 如果您想删除分支，我们使用-d标识。 1git branch -d test","link":"/posts/64901.html"},{"title":"LCA最近公共祖先模板","text":"题目描述给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。 输出格式输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。 样例 #1样例输入 #1123456789105 5 43 12 45 11 42 43 23 51 24 5 样例输出 #11234544144 提示对于 $30%$ 的数据，$N\\leq 10$，$M\\leq 10$。 对于 $70%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。 对于 $100%$ 的数据，$N\\leq 500000$，$M\\leq 500000$。 样例说明： 该树结构如下： 第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。 第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。 第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。 第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。 第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。 故输出依次为 $4, 4, 1, 4, 4$。 算法分析 模板 算法分析本题通过倍增的方法实现 首先我们要记录各个点的深度和他们$2^i$级的的祖先，用数组$\\rm{depth}$表示每个节点的深度，$fa[i][j]$表示节点ii的$2^j$级祖先。 12345678void dfs(int now, int fath) { fa[now][0] = fath; depth[now] = depth[fath] + 1; for(int i = 1; i &lt;= lg[depth[now]]; ++i) fa[now][i] = fa[fa[now][i-1]][i-1]; for(int i = 0;i&lt;=po[now].size()-1;i++){ if(po[now][i]!=fath) dfs(po[now][i],now); }} 加一个常数优化 1for(int i = 1;i&lt;=n;i++)lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i);//解释: gl[深度]指向2的i次方，gl[]中存的是i。 倍增LCA，先把两个点提到同一高度，再统一开始跳。 1234if(depth[x]&lt;depth[y])swap(x,y);for(;depth[x]&gt;depth[y];){ x = fa[x][lg[depth[x]-depth[y]] - 1];}//提到同一高度 但我们在跳的时候不能直接跳到它们的LCA，因为这可能会误判，所以我们要跳到它们LCA的下面一层，然后输出它们的父节点，这样就不会误判了。 12345if(x==y)return x;for(int k = lg[depth[x]] - 1; k &gt;= 0; --k) if(fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k];return fa[x][0]; $Model$1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector &lt;int&gt; po[500005];int depth[500001], fa[500001][22], lg[500001];inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}void dfs(int now, int fath) { fa[now][0] = fath; depth[now] = depth[fath] + 1; for(int i = 1; i &lt;= lg[depth[now]]; ++i) fa[now][i] = fa[fa[now][i-1]][i-1]; for(int i = 0;i&lt;=po[now].size()-1;i++){ if(po[now][i]!=fath) dfs(po[now][i],now); }}int LCA(int x,int y){ if(depth[x]&lt;depth[y])swap(x,y); for(;depth[x]&gt;depth[y];){ x = fa[x][lg[depth[x]-depth[y]] - 1]; } if(x==y)return x; for(int k = lg[depth[x]] - 1; k &gt;= 0; --k) if(fa[x][k] != fa[y][k]) x = fa[x][k], y = fa[y][k]; return fa[x][0];}int main(){ int n=read(),m=read(),s=read(),g1,g2; for(int i = 1;i&lt;n;i++){ g1=read(),g2=read(); po[g1].push_back(g2); po[g2].push_back(g1); } for(int i = 1;i&lt;=n;i++)lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); dfs(s,0); for(int i = 1;i&lt;=m;i++){ g1=read(),g2=read(); cout&lt;&lt;LCA(g1,g2)&lt;&lt;endl; }} .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/posts/63072.html"},{"title":"KMP&amp;AC自动机-字符串匹配","text":"KMPKMP的出现优化了在字符串中查找子串的过程。使复杂度达到$O(m+n)$ KMP算法要求提供主串$s$和模式串$pat$,要求求出模式串在主串中出现的位置。 next算法最重要的部分是求出$next$数组，也有很多说法比如说失配指针(fail)、board数组…大同小异。其意义是到当前位置之前最大的相同的前后缀长度。 123456789int nex[10005],m/* pat字符串长度 */;string pat;void get_nex(){ nex[0]=0;int pre_len=0/* 最长相同前后缀 */; for(int i = 1;i&lt;m;i++){ while(pre_len &amp;&amp; pat[i] !=pat[pre_len])pre_len=nex[pre_len];//利用已求出的nex[]数组更新当前pre_len(跳nex[]) if(pat[i]==pat[pre_len]/* 找到字符相同的位置 */)nex[i+1]=++pre_len;//更新下个位置的nex[i] }} 复杂度$O(m)$ query接下来是搜索，遍历主串一遍即可找到 1234567891011string s,pat;int n,m;int query(){ for(int i = 0,j=0/* 用i指向主串，用j指向模式串 */;i&lt;n;i++){ while(j &amp;&amp; s[i]!=pat[j])j = nex[j];//遇到不相等的地方，j就跳nex[]; if(s[i]==pat[j]) j++;//如果相等，j指针后移 if(j==m) return i-m+2;/* 返回相同子串开始的地方(这里约定下标开始是1) */ //若要输出所有的相同字串，记录i-m+2，不要退出，继续遍历即可 } return -1;//找不到，返回} 由于$i$始终递增不减,可知复杂度为$O(n)$ 模板12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int nex[100005],pat_len,s_len;string s,pat;void build_next(){ nex[0]=0;int pre_len=0; for(int i = 1;i&lt;pat_len;i++){ while(pre_len &amp;&amp; pat[i] !=pat[pre_len])pre_len=nex[pre_len]; if(pat[i]==pat[pre_len])nex[i+1]=++pre_len; }}int query(){ for(int i = 0,j=0;i&lt;s_len;i++){ while(j &amp;&amp; s[i]!=pat[j])j = nex[j]; if(s[i]==pat[j]) j++; if(j==pat_len) return i-pat_len+2; } return -1;}int main(){ cin&gt;&gt;s&gt;&gt;pat; s_len = s.length(),pat_len = pat.length(); build_next(); int sta=query(); if(sta==-1)cout&lt;&lt;&quot;Not found.&quot;&lt;&lt;endl; else cout&lt;&lt;sta&lt;&lt;endl; return 0;} AC自动机即Accepted自动机 Aho–Corasick Automaton 与KMP算法不同的是，AC自动机用于多模式串匹配，即一个主串匹配多个模式串。 简单来说，建立一个AC自动机有两个步骤： 基础的Trie结构：将所有的模式串构成一棵Trie，构造树边。 KMP的思想：对 Trie 树上所有的结点构造回跳边、转移边，即失配指针。然后就可以利用它进行多模式匹配了。 build_Trie建造一棵Trie树 1234567891011int ch[1000005][26],cnt[1000005],idx;string pat;void build_Trie(){ int pos=0;//当前位置信息 for(int i = 0;pat[i];i++){ int j = pat[i]-'a'; if(!ch[pos][j])ch[pos][j]=++idx; pos=ch[pos][j]; } ++cnt[pos];//当前节点代表多少字符串} build_AC在Trie树的基础上增加回跳边和转移边 树边：Trie中构建的边 (灰色边) 回跳边：指向当前节点的最长后缀。构建时，回跳边指向父节点的回跳边所指节点的儿子 (黄色边) 转移边：指向当前节点回跳边所指节点的儿子。(黑色边) 12345678910111213int ch[1000005][26],nex[1000005]/* 存储回跳边(等同于KMP中的nex[],名字都一样QaQ) */;void build_AC(){ queue&lt;int&gt;q;//BFS建立自动机 for(int i = 0;i&lt;26;i++) if(ch[0][i])q.push(ch[0][i]);//0号节点虚点，特殊处理，把所有的模式串开头加入队列 while(q.size()){ int now = q.front();q.pop(); for(int i = 0 ;i&lt;26;i++){ int to = ch[now][i]; if(to)nex[to]=ch[nex[now]][i],q.push(to);//如果有当前儿子存在，就用当前节点回跳边指向节点的儿子更新当前儿子的回跳边 else ch[now][i]=ch[nex[now]][i];//如果这个方向没有孩子，就用当前节点回跳边的孩子更新当前节点在这个方向的转移边 } }} query查询有多少模式串与主串匹配 扫描主串，依次取出每个字符，并建立两个指针$i,j$ $i$指针走主串对应的节点，沿着树边或转移边走，保证不回退； $j$指针沿着回跳边走，每次从当前节点回到根节点($0$),把以当前节点为止的后缀串全部取出不遗漏 12345678910int query(){ int ans=0; for(int k = 0,i=0;s[k];k++){ i=ch[i][s[k]-'a'];//扫描主串 for(int j = i;j&amp;&amp;~cnt[j]/* ① */;j=nex[j]/* j指针走回跳边，跳回根节点 */){ ans+=cnt[j],cnt[j]=-1/* 同①处，每次将当前节点代表字符串取出后，清零当前节点计数 */; } } return ans;//返回统计答案} 模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int ch[1000005][26],idx,n;int nex[1000005],cnt[1000005];string s,pat;void build_Trie(){ int pos=0; for(int i = 0;pat[i];i++){ int j = pat[i]-'a'; if(!ch[pos][j])ch[pos][j]=++idx; pos=ch[pos][j]; } ++cnt[pos];}void build_AC(){ queue&lt;int&gt;q; for(int i = 0;i&lt;26;i++) if(ch[0][i])q.push(ch[0][i]); while(q.size()){ int now = q.front();q.pop(); for(int i = 0 ;i&lt;26;i++){ int to = ch[now][i]; if(to)nex[to]=ch[nex[now]][i],q.push(to); else ch[now][i]=ch[nex[now]][i]; } }}int query(){ int ans=0; for(int k = 0,i=0;s[k];k++){ i=ch[i][s[k]-'a']; for(int j = i;j&amp;&amp;~cnt[j];j=nex[j])ans+=cnt[j],cnt[j]=-1; } return ans;}int main(){ cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++)cin&gt;&gt;pat,build_Trie(); build_AC(); cin&gt;&gt;s; cout&lt;&lt;query(); return 0;}","link":"/posts/18166.html"},{"title":"LG6619-[省选联考 2020 A&#x2F;B 卷] 冰火战士题解","text":"虽然说这题题意还是比较好懂的，但我代码调了好久。 题意选取一个最合适的温度$k$,使得$$\\large{\\min \\left( \\sum_{i \\in \\mathrm{ice},x_i \\le k} y_i, \\sum_{i \\in \\mathrm{fire},x_i \\ge k} y_i\\right)}$$的值最大。如果有多个$k$能使价值最大，则选最大的$k$。 分析首先由题意我们知道，对于$\\mathrm{ice}$来说，我们得到的是一个递增序列。对于$\\mathrm{fire}$来说，我们得到的是一个递减序列。把两个序列合起来，我们可以得到一个单峰曲线。那么我们很容易想到我们用二分选取最优温度。 然后呢？ 我就在这里卡死了，万能的题解给出了一个不错的解法 –&gt;我们找到$\\mathrm{ice}$的能量$f_i$小于$\\mathrm{fire}$的能量$g_i$的最高温度$k$,那么一定有$f(k+1) \\ge g(k+1)$，在这个时候我们再找到一个$k’$,使$g(k+1)=g(k)$,那么答案就是$\\max(k,k’)$ 很有道理，于是 开始打代码 又偷瞄了一眼题解，发现前车之鉴只能拿$60pts$，于是看到了解决方案 显而易见 我们可以用一种直接在树状数组上二分（倍增）的做法，加上吸氧即可通过本题！ 为什么可以倍增呢？如果我们现在在$p$位置，我们在树状数组上倍增的时候，跳的步长$d$递减如$2^{20},2^{19},2^{18},2^{17},2^{16} \\cdots 2^0$，而我们知道，树状数组一个点上存储的是$\\left[p+1,p+d\\right]$上的所有信息，那么我们最不用重新算前后缀和，直接将$p+d$上点的信息加起来即可。 具体看代码实现。 AC Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;inline int read(){int x=0,f=1;char c=getchar();for(;!isdigit(c);c=getchar())if(c=='-')f=-1;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);return x*f;}struct query{ int opt; int k; int t,temp,power;}req[2000005];int n,tr[2][2000005],SUM;int temp[2000005],tot;//树状数组部分int lowbit(int x){ return x&amp;(-x);}void add(int pos,int y,int whi){ for(int i = pos;i&lt;=tot;i+=lowbit(i)){ tr[whi][i]+=y; }}int query(int x,int whi){ int ans=0; for(int i = x;i;i-=lowbit(i)){ ans+=tr[whi][i]; } return ans;}//树状数组部分int main(){ n=read(); for(int i = 1;i&lt;=n;i++){ req[i].opt=read(); if(req[i].opt&amp;1){ req[i].t=read(),req[i].temp=read(),req[i].power=read(); temp[++tot]=req[i].temp; }else req[i].k=read(); } sort(temp+1,temp+tot+1); tot=unique(temp+1,temp+tot+1)-temp-1;//离散化温度 for(int i = 1;i&lt;=n;i++){ if(req[i].opt&amp;1){ req[i].temp=lower_bound(temp+1,temp+tot+1,req[i].temp)-temp; } }//将每个点的温度改为离散化后的值 for(int i = 1;i&lt;=n;i++){ if(req[i].opt&amp;1) add(req[i].temp+req[i].t,req[i].power,req[i].t),SUM+=req[i].t*req[i].power/* 这里是为了方便后续求前后缀和 */; else{ int whi = req[i].k; add(req[whi].temp+req[whi].t,-req[whi].power,req[whi].t),SUM-=req[whi].t*req[whi].power; } //对操作后的树进行修改 int sum0=0,sum1=SUM,f0=0,pos0=0; for(int i = 20;i&gt;=0;i--){//倍增 int now_pos = pos0+(1&lt;&lt;i),now_sum0 = sum0+tr[0][now_pos],now_sum1=sum1-tr[1][now_pos]; if(now_pos&gt;tot)continue; if(now_sum0&lt;now_sum1){ pos0 = now_pos; sum0 = now_sum0,sum1 = now_sum1; } } f0=sum0,sum0=0,sum1 = SUM; //到这里算出了k的值即这里的pos0 int f1=0,pos1=0; if (pos0 &lt; tot){ f1 = min(query(pos0+1,0),SUM-query(pos0+1,1)); //找到g(k+1) for(int i = 20;i&gt;=0;i--){ int now_pos = pos1 + (1 &lt;&lt; i),now_sum0 = sum0+tr[0][now_pos],now_sum1=sum1-tr[1][now_pos]; if(now_pos&gt;tot)continue; if(now_sum0&lt;now_sum1){ pos1 = now_pos; sum0 = now_sum0,sum1 = now_sum1; }else if(min(now_sum0, now_sum1) == f1){ pos1 = now_pos; sum0 = now_sum0,sum1 = now_sum1; } } //把k'的位置搜出来 } if(!(f0|f1))cout&lt;&lt;&quot;Peace\\n&quot;; else if(f0&gt;f1)cout&lt;&lt;temp[pos0]&lt;&lt;&quot; &quot;&lt;&lt;(f0&lt;&lt;1)&lt;&lt;endl; else cout&lt;&lt;temp[pos1]&lt;&lt;&quot; &quot;&lt;&lt;(f1&lt;&lt;1)&lt;&lt;endl; } return 0;}","link":"/posts/12915.html"},{"title":"Lantern Parade the Culture of Taizhou","text":"Ladies and gentlemen, good afternoon! It’s my honor to give a speech about Taizhou’s culture. I’ll mainly talk about the Lantern Parade on Lantern Festival. Taizhou, nestled between the cities of the Wenzhou and Ningbo, is a vibrant city in Zhejiang province. The Lantern Parade demonstrates the passionate and energetic life of Taizhou people. On that day, villagers take out their sacrificial offerings and place them in front of their houses to pray for the good. During the parade at night, performers wear red festival dresses, dancing with lanterns of varies shapes, such as those of dragons, horses, little kids, and so on. Marching along the street, the parade was surrounded by enthusiastic villagers, and the performers are chaored by the deafening sound of the firework. The grand parade, along with the table-full offerings and the gorgeous firework, makes every corner of the village filled with the flavour of the year. Looking back onto my childhood, I enjoyed every chance to participate in the Lantern parade. After savouring grandma’s sweet brown sugar dumplings, the parade kicked off with the first sound of the firework. We stood against the door, watching the reddening light enveloping the growing crowds. Finally, at the end of the street came the parade. Who came first were some guys beating gongs. The nearby houses were thumping by the strike of the sound. Next was the dragon dance, which was bound to be my favorite performance. A line of performers rotated their rod to manipulate the dragon into rolling or leaping. Dragon chased away the darkness, making the coming year strong and mighty. Following that were the lanterns of the emperor’s car, innocent children and the twelve Chinese zodiac signs. The parade ended with the silly crazy horse lantern running in a frenzy. The lantern parade left a lasting impression in my memory and was eternally engraved in my life. I will be dedicated to learning the Taizhou’s lantern culture, pass it on and carry it forward in the future! That’s all. Thanks for listening.","link":"/posts/1474.html"},{"title":"NOIP考试准备","text":"进场前 身份证 准考证 水、零食、巧克力 防疫资料 代码模板准备 进场 检查有没有VSCode并检查TDM-GCC或MinGW。添加到Path。 检查DevCpp设中文,编译调试信息 模板书写123456789101112131415#include&lt;iostream&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int main(){ freopen(&quot;.in&quot;,&quot;r&quot;,stdin); freopen(&quot;.out&quot;,&quot;w&quot;,stdout); fclose(stdin); fclose(stdout); return 0;} 有时间(应该没时间) 123456789101112131415161718192021222324252627282930313233343536//launch.json{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\Program Files (x86)\\\\TDM-GCC\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; } ]} 12345678910111213141516171819202122232425262728293031//tasks.json{ &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;command&quot;: &quot;D:\\\\Program Files (x86)\\\\TDM-GCC\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;-Wall&quot;, &quot;-std=c++14&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;detail&quot;: &quot;调试器生成的任务。&quot; } ], &quot;version&quot;: &quot;2.0.0&quot;} 123456789101112131415161718192021//c_cpp_properties.json{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;D:\\\\Program Files (x86)\\\\TDM-GCC\\\\bin\\\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu17&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot; } ], &quot;version&quot;: 4} 朕用算法模板先打高精模板 高精加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=100005;int A[N],B[N],C[N],la,lb,lc; /* 高精加 */void add(int A[],int B[],int C[]){ for(int i = 0;i&lt;lc;i++){ C[i]+=A[i]+B[i]; C[i+1]=C[i]/10; C[i]%=10; } if(C[lc])lc++;}/* 高精减 */bool cmp(int A[],int B[]){ for(int i = la-1;~i;i--)if(A[i]!=B[i])return A[i]&gt;B[i]; return true;}void sub(int A[],int B[],int C[]){ for(int i = 0;i&lt;lc;i++){ if(A[i]&lt;B[i])A[i+1]--,A[i]+=10; C[i]=A[i]-B[i]; } while(lc&amp;&amp;C[lc]==0)lc--;}/* 高精乘 */void mul(int A[],int B[],int C[]){ for(int i = 0;i&lt;la;i++){ for(int j =0;j&lt;lb;j++){ C[i+j]+=A[i]*B[j]; C[i+j+1]+=C[i+j]/10; C[i+j]%=10; } } while(lc&amp;&amp;C[lc]==0)lc--;}/* 高精除 */void div(int A[],int b,int C[]){ long long r=0; for(int i = la-1;~i;i--){ r=(r&lt;&lt;1)+(r&lt;&lt;3)+A[i]; C[la-i-1] = r/b; r%=b; } reverse(C,C+lc); while(lc&amp;&amp;C[lc]==0)lc--;}int main(){ string a,b; cin&gt;&gt;a&gt;&gt;b; la=a.length(),lb=b.length(),lc=max(la,lb); for(int i = la-1;~i;i--)A[la-i-1]=a[i]-'0'; for(int i = lb-1;~i;i--)B[lb-i-1]=b[i]-'0'; /* 高精加 */ add(A,B,C); /* 高精减 */ if(cmp(A,B))swap(A,B),cout&lt;&lt;'-'; sub(A,B,C); /* 高精乘 */ lc=la+lb; mul(A,B,C); /* 高精除 */ int bb; cin&gt;&gt;bb; lc=la=a.size(); div(A,bb,C); for(int i = lc-1;~i;i--)cout&lt;&lt;C[i]; return 0;} 再打一遍线段树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;int a[100005];struct node{ int l; int r; long long val; int lazy;}tree[6000005];inline long long read(){ long long x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}void pushup(int pos){ tree[pos].val=tree[pos&lt;&lt;1].val+tree[pos&lt;&lt;1|1].val;}void pushdown(int pos){ if(tree[pos].lazy){ tree[pos&lt;&lt;1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1].r-tree[pos&lt;&lt;1].l+1); tree[pos&lt;&lt;1|1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1|1].r-tree[pos&lt;&lt;1|1].l+1); tree[pos&lt;&lt;1].lazy+=tree[pos].lazy; tree[pos&lt;&lt;1|1].lazy+=tree[pos].lazy; tree[pos].lazy=0; } return;}void updata(int pos,int l,int r,int data){ if(tree[pos].l&gt;=l&amp;&amp;tree[pos].r&lt;=r){ tree[pos].val+=((tree[pos].r-tree[pos].l+1)*data); tree[pos].lazy+=data; return; } pushdown(pos); int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; if(mid&gt;=l) updata(pos&lt;&lt;1,l,r,data); if(mid&lt;r) updata(pos&lt;&lt;1|1,l,r,data); pushup(pos);}long long query(int x,int y,int pos){ pushdown(pos); if(x&lt;=tree[pos].l&amp;&amp;y&gt;=tree[pos].r) return tree[pos].val; int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; long long ans=0; if(mid&gt;=x)ans+=query(x,y,pos&lt;&lt;1); if(mid&lt;y)ans+=query(x,y,pos&lt;&lt;1|1); return ans;}void build(int pos,int l,int r){ tree[pos].l=l,tree[pos].r=r; if(l==r){ tree[pos].val=read(); return; } int mid=(l+r)&gt;&gt;1; build(pos&lt;&lt;1,l,mid); build(pos&lt;&lt;1|1,mid+1,r); pushup(pos); return;}int main(){ int n,m,opt,x,y,k; cin&gt;&gt;n&gt;&gt;m; build(1,1,n); for(int i = 1;i&lt;=m;i++){ cin&gt;&gt;opt; if(opt==1){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; updata(1,x,y,k); }else{ cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(x,y,1)&lt;&lt;endl; } }} 有时间 快速幂 1234567const int mod = 1e9+9;long long fastpow(long long x,long long y){ if(y==1)return x; long long w=fastpow(x,y&gt;&gt;1)%mod; if(y&amp;1==0) return (w*w)%mod; else return ((w*w)%mod*x%mod)%mod;} KMP 1234567891011121314151617int ne[1000006];int main(){ string s,p; cin&gt;&gt;s&gt;&gt;p; int n=s.size(),m=p.size(); for (int i = 1, j = 0; i &lt; m; i ++ ){ while (j &amp;&amp; p[i] != p[j]) j = ne[j]; if (p[i] == p[j]) j++,ne[i+1] =j; } for (int i=0, j = 0; i &lt; n; i ++ ){ while (j &amp;&amp; s[i] != p[j]) j = ne[j]; if (s[i] == p[j]) j ++ ; if (j == m) cout&lt;&lt;i-m+2&lt;&lt;endl; } for (int i=1;i&lt;=m;i++) cout&lt;&lt;ne[i]&lt;&lt;&quot; &quot;; return 0;}","link":"/posts/32398.html"},{"title":"Latex公式大全","text":"数学公式$\\LaTeX$的插入将数学公式写在 $ $ 之间，代表的是插入行内数学公式（通常称为行内模式）。将数学公式写在 $$ $$ 之间，会使公式独立成一行并强制居中（通常称为独立模式）。 声调 / 变音符号1$\\dot{a} \\ddot{a} \\acute{a} \\grave{a}$ $\\quad\\dot{a}\\quad\\ddot{a}\\quad\\acute{a}\\quad\\grave{a}$ 1$\\check{a} \\breve{a} \\tilde{a} \\bar{a}$ $\\quad\\check{a}\\quad\\breve{a}\\quad\\tilde{a}\\quad\\bar{a}$ 1$\\hat{a} \\widehat{a} \\vec{a}$ $\\quad\\hat{a}\\quad\\widehat{a}\\quad\\vec{a}$ 标准函数1$\\exp_a b=a^b \\exp b=e^b 10^m$ $\\quad\\exp_a b=a^b\\quad\\exp b=e^b\\quad10^m$ 1$\\sin a \\cos b \\tan c \\sec d \\csc e \\cot f$ $\\quad\\sin a\\quad\\cos b\\quad\\tan c\\quad\\sec d\\quad\\csc e\\quad\\cot f$ 1$\\arcsin a \\arccos b \\arctan c$ $\\quad\\arcsin a\\quad\\arccos b\\quad\\arctan c$ 1$\\sinh a \\cosh b \\tanh c \\coth d$ $\\quad{\\sinh a}\\quad{\\cosh b}\\quad{\\tanh c}\\quad{\\coth d}$ 1$\\operatorname{argsh} a \\operatorname{argch} b \\operatorname{argth} c$ PS：\\operatorname{} 貌似可以将任何字符转换成标准函数的形式。$\\quad\\operatorname{argsh} a\\quad\\operatorname{argch} b\\quad\\operatorname{argth} c$ 1$\\left\\vert a\\right\\vert \\min(x,y) \\max(x,y)$ $\\quad\\left\\vert a\\right\\vert\\quad\\min(x,y)\\quad\\max(x,y)$ 界限1$\\min x \\max y \\inf s \\sup t$ $\\quad\\min x\\quad\\max y\\quad\\inf s\\quad\\sup t$ 1$\\lim u \\liminf v \\limsup w$ $\\quad\\lim u\\quad\\liminf v\\quad\\limsup w$ 1$\\dim p \\deg q \\det m \\ker\\phi$ $\\quad\\dim p\\quad\\deg q\\quad\\det m\\quad\\ker\\phi$ 投射PS：感觉这翻译很奇怪，应该是映射吧。 1$\\Pr j \\hom l \\lVert z\\rVert \\arg z$ PS：个人认为 \\lVert、\\rVert 与 \\Vert 和 \\| 并没有什么区别。$\\quad\\Pr j\\quad\\hom l\\quad\\lVert z\\rVert\\quad\\arg z$ 微分及导数1$dt \\mathrm{d}t \\partial t \\nabla\\psi$ $\\quad dt\\quad\\mathrm{d}t\\quad\\partial t\\quad\\nabla\\psi$ 1$\\prime \\backprime f^\\prime f' f'' f^{(3)} \\dot{y} \\ddot{y}$ $\\quad\\prime\\quad\\backprime\\quad f^\\prime\\quad f’\\quad f’’\\quad f^{(3)}\\quad\\dot{y}\\quad\\ddot{y}$ 类字母符号及常数1$\\infty \\aleph \\complement \\backepsilon \\eth \\Finv \\hbar$ $\\quad\\infty\\quad\\aleph\\quad\\complement\\quad\\backepsilon\\quad\\eth\\quad\\Finv\\quad\\hbar$ 1$\\Im \\imath \\jmath \\Bbbk \\ell \\mho \\wp \\Re \\circledS$ $\\quad\\Im\\quad\\imath\\quad\\jmath\\quad\\Bbbk\\quad\\ell\\quad\\mho\\quad\\wp\\quad\\Re\\quad\\circledS$ 模算数1$a\\equiv1\\pmod{m}$ $\\quad a\\equiv1\\pmod{m}$ 1$a\\bmod b$ $\\quad a\\bmod b$ 1$\\gcd(m,n) \\operatorname{lcm}(m,n)$ $\\quad\\gcd(m,n)\\quad\\operatorname{lcm}(m,n)$ 1$\\mid \\nmid \\shortmid \\nshortmid$ PS：\\mid 可以用 | 代替。（管理员注：\\mid 实际上差不多是 \\mathrel{|}，两侧的 spacing 有区别的）$\\quad\\mid\\quad\\nmid\\quad\\shortmid\\quad\\nshortmid$ 1$a\\%b$ $\\quad a%b$（管理员注：不建议在公式中使用 \\% 作为取模，一般仅作百分号使用） 根号1$\\surd \\sqrt{2} \\sqrt[n]{} \\sqrt[n]{x}$ $\\quad\\surd\\quad\\sqrt{2}\\quad\\sqrt[n]{}\\quad\\sqrt[n]{x}$ 运算符1$+ - \\pm \\mp \\dotplus$ $\\quad+\\quad-\\quad\\pm\\quad\\mp\\quad\\dotplus$ 1$\\times \\div \\divideontimes / \\backslash$ $\\quad\\times\\quad\\div\\quad\\divideontimes\\quad/\\quad\\backslash$ 1$\\cdot * \\star \\circ \\bullet$ PS：* 可以用 \\ast 代替。$\\quad\\cdot\\quad*\\quad\\star\\quad\\circ\\quad\\bullet$ 1$\\boxplus \\boxminus \\boxtimes \\boxdot$ $\\quad\\boxplus\\quad\\boxminus\\quad\\boxtimes\\quad\\boxdot$ 1$\\oplus \\ominus \\otimes \\oslash \\odot$ $\\quad\\oplus\\quad\\ominus\\quad\\otimes\\quad\\oslash\\quad\\odot$ 1$\\circleddash \\circledcirc \\circledast$ $\\quad\\circleddash\\quad\\circledcirc\\quad\\circledast$ 1$\\bigoplus \\bigotimes \\bigodot$ $\\quad\\bigoplus\\quad\\bigotimes\\quad\\bigodot$ 集合1$\\{ \\} \\emptyset \\varnothing$ $\\quad{\\quad}\\quad\\emptyset\\quad\\varnothing$ 1$\\in \\notin \\not\\in \\ni \\not\\ni$ PS：\\not 是在下一个字符上画斜杠。$\\quad\\in\\quad\\notin\\quad\\not\\in\\quad\\ni\\quad\\not\\ni$ 1$\\cap \\Cap \\sqcap \\bigcap$ $\\quad\\cap\\quad\\Cap\\quad\\sqcap\\quad\\bigcap$ 1$\\cup \\Cup \\sqcup \\bigcup \\bigsqcup \\uplus \\biguplus$ $\\quad\\cup\\quad\\Cup\\quad\\sqcup\\quad\\bigcup\\quad\\bigsqcup\\quad\\uplus\\quad\\biguplus$ 1$\\setminus \\smallsetminus \\times$ $\\quad\\setminus\\quad\\smallsetminus\\quad\\times$ 1$\\subset \\Subset \\sqsubset$ $\\quad\\subset\\quad\\Subset\\quad\\sqsubset$ 1$\\supset \\Supset \\sqsupset$ $\\quad\\supset\\quad\\Supset\\quad\\sqsupset$ 1$\\subseteq \\nsubseteq \\subsetneq \\varsubsetneq \\sqsubseteq$ $\\quad\\subseteq\\quad\\nsubseteq\\quad\\subsetneq\\quad\\varsubsetneq\\quad\\sqsubseteq$ 1$\\supseteq \\nsupseteq \\supsetneq \\varsupsetneq \\sqsupseteq$ $\\quad\\supseteq\\quad\\nsupseteq\\quad\\supsetneq\\quad\\varsupsetneq\\quad\\sqsupseteq$ 1$\\subseteqq \\nsubseteqq \\subsetneqq \\varsubsetneqq$ $\\quad\\subseteqq\\quad\\nsubseteqq\\quad\\subsetneqq\\quad\\varsubsetneqq$ 1$\\supseteqq \\nsupseteqq \\supsetneqq \\varsupsetneqq$ $\\quad\\supseteqq\\quad\\nsupseteqq\\quad\\supsetneqq\\quad\\varsupsetneqq$ 关系符号1$= \\ne \\neq \\equiv \\not\\equiv$ PS：表示并没有看出来 \\ne 和 \\neq 的区别……（管理员注：因为是一样的）$\\quad=\\quad\\ne\\quad\\neq\\quad\\equiv\\quad\\not\\equiv$ 1$\\doteq \\doteqdot \\overset{\\underset{def}{}}{=} :=$ $\\quad\\doteq\\quad\\doteqdot\\quad\\overset{\\underset{def}{}}{=}\\quad:=$ 1$\\sim \\nsim \\backsim \\thicksim \\simeq \\backsimeq \\eqsim \\cong \\ncong$ $\\quad\\sim\\quad\\nsim\\quad\\backsim\\quad\\thicksim\\quad\\simeq\\quad\\backsimeq\\quad\\eqsim\\quad\\cong\\quad\\ncong$ 1$\\approx \\thickapprox \\approxeq \\asymp \\propto \\varpropto$ $\\quad\\approx\\quad\\thickapprox\\quad\\approxeq\\quad\\asymp\\quad\\propto\\quad\\varpropto$ 1$&lt; \\nless \\ll \\not\\ll \\lll \\not\\lll \\lessdot$ $&lt; \\ \\nless \\ \\ll \\ \\not \\ \\ll \\ \\lll \\ \\not \\ \\lll \\ \\lessdot$ 1$&gt; \\ngtr \\gg \\not\\gg \\ggg \\not\\ggg \\gtrdot$ $&gt; \\ \\ngtr \\ \\gg \\ \\not \\ \\gg \\ \\ggg \\ \\not \\ \\ggg \\ \\gtrdot$ 1$\\le \\leq \\lneq \\leqq \\nleq \\nleqq \\lneqq \\lvertneqq$ $\\quad\\le\\quad\\leq\\quad\\lneq\\quad\\leqq\\quad\\nleq\\quad\\nleqq\\quad\\lneqq\\quad\\lvertneqq$ 1$\\ge \\geq \\gneq \\geqq \\ngeq \\ngeqq \\gneqq \\gvertneqq$ $\\quad\\ge\\quad\\geq\\quad\\gneq\\quad\\geqq\\quad\\ngeq\\quad\\ngeqq\\quad\\gneqq\\quad\\gvertneqq$ 1$\\lessgtr \\lesseqgtr \\lesseqqgtr \\gtrless \\gtreqless \\gtreqqless$ $\\quad\\lessgtr\\quad\\lesseqgtr\\quad\\lesseqqgtr\\quad\\gtrless\\quad\\gtreqless\\quad\\gtreqqless$ 1$\\leqslant \\nleqslant \\eqslantless$ $\\quad\\leqslant\\quad\\nleqslant\\quad\\eqslantless$ 1$\\geqslant \\ngeqslant \\eqslantgtr$ $\\quad\\geqslant\\quad\\ngeqslant\\quad\\eqslantgtr$ 1$\\lesssim \\lnsim \\lessapprox \\lnapprox$ $\\quad\\lesssim\\quad\\lnsim\\quad\\lessapprox\\quad\\lnapprox$ 1$\\gtrsim \\gnsim \\gtrapprox \\gnapprox$ $\\quad\\gtrsim\\quad\\gnsim\\quad\\gtrapprox\\quad\\gnapprox$ 1$\\prec \\nprec \\preceq \\npreceq \\precneqq$ $\\quad\\prec\\quad\\nprec\\quad\\preceq\\quad\\npreceq\\quad\\precneqq$ 1$\\succ \\nsucc \\succeq \\nsucceq \\succneqq$ $\\quad\\succ\\quad\\nsucc\\quad\\succeq\\quad\\nsucceq\\quad\\succneqq$ 1$\\preccurlyeq \\curlyeqprec$ $\\quad\\preccurlyeq\\quad\\curlyeqprec$ 1$\\succcurlyeq \\curlyeqsucc$ $\\quad\\succcurlyeq\\quad\\curlyeqsucc$ 1$\\precsim \\precnsim \\precapprox \\precnapprox$ $\\quad\\precsim\\quad\\precnsim\\quad\\precapprox\\quad\\precnapprox$ 1$\\succsim \\succnsim \\succapprox \\succnapprox$ $\\quad\\succsim\\quad\\succnsim\\quad\\succapprox\\quad\\succnapprox$ 几何符号12$\\parallel \\nparallel \\shortparallel \\nshortparallel$ ps:\\parallel应该和\\|是一样的。 $\\quad\\parallel\\quad\\nparallel\\quad\\shortparallel\\quad\\nshortparallel$ 1$\\perp \\angle \\sphericalangle \\measuredangle 45^\\circ$ $\\quad\\perp\\quad\\angle\\quad\\sphericalangle\\quad\\measuredangle\\quad45^\\circ$ 1$\\Box \\blacksquare \\diamond \\Diamond \\lozenge \\blacklozenge \\bigstar$ $\\quad\\Box\\quad\\blacksquare\\quad\\diamond\\quad\\Diamond\\quad\\lozenge\\quad\\blacklozenge\\quad\\bigstar$ 12$\\bigcirc \\triangle \\bigtriangleup \\bigtriangledown$ ps:并没有看出\\triangle和\\bigtriangleup有什么区别。 $\\quad\\bigcirc\\quad\\triangle\\quad\\bigtriangleup\\quad\\bigtriangledown$ 1$\\vartriangle \\triangledown \\triangleleft \\triangleright$ $\\quad\\vartriangle\\quad\\triangledown\\quad\\triangleleft\\quad\\triangleright$ 1$\\blacktriangle \\blacktriangledown \\blacktriangleleft \\blacktriangleright$ $\\quad\\blacktriangle\\quad\\blacktriangledown\\quad\\blacktriangleleft\\quad\\blacktriangleright$ 逻辑符号1$\\forall \\exists \\nexists$ $\\quad\\forall\\quad\\exists\\quad\\nexists$ 12$\\therefore \\because \\And$ ps:\\And也可用\\&amp;，至少我没看出来这两个有什么差别。 $\\quad\\therefore\\quad\\because\\quad\\And$ 1$\\lor \\vee \\curlyvee \\bigvee$ $\\quad\\lor\\quad\\vee\\quad\\curlyvee\\quad\\bigvee$ 1$\\land \\wedge \\curlywedge \\bigwedge$ $\\quad\\land\\quad\\wedge\\quad\\curlywedge\\quad\\bigwedge$ 1$\\bar{q} \\bar{abc} \\overline{q} \\overline{abc}$ $\\quad\\bar{q}\\quad\\bar{abc}\\quad\\overline{q}\\quad\\overline{abc}$ 1$\\lnot \\neg \\bot \\top$ $\\quad\\lnot\\quad\\neg\\quad\\bot\\quad\\top$ 1$\\vdash \\dashv \\vDash \\Vdash \\models$ $\\quad\\vdash\\quad\\dashv\\quad\\vDash\\quad\\Vdash\\quad\\models$ 1$\\Vvdash \\nvdash \\nVdash \\nvDash \\nVDash$ $\\quad\\Vvdash\\quad\\nvdash\\quad\\nVdash\\quad\\nvDash\\quad\\nVDash$ 1$\\ulcorner \\urcorner \\llcorner \\lrcorner$ $\\quad\\ulcorner\\quad\\urcorner\\quad\\llcorner\\quad\\lrcorner$ 箭头1$\\Rrightarrow \\Lleftarrow$ $\\quad\\Rrightarrow\\quad\\Lleftarrow$ 1$\\Rightarrow \\nRightarrow \\Longrightarrow \\implies$ $\\quad\\Rightarrow\\quad\\nRightarrow\\quad\\Longrightarrow\\quad\\implies$ 1$\\Leftarrow \\nLeftarrow \\Longleftarrow$ $\\quad\\Leftarrow\\quad\\nLeftarrow\\quad\\Longleftarrow$ 1$\\Leftrightarrow \\nLeftrightarrow \\Longleftrightarrow \\iff$ $\\quad\\Leftrightarrow\\quad\\nLeftrightarrow\\quad\\Longleftrightarrow\\quad\\iff$ 1$\\Uparrow \\Downarrow \\Updownarrow$ $\\quad\\Uparrow\\quad\\Downarrow\\quad\\Updownarrow$ 12$\\leftarrow \\rightarrow \\nleftarrow \\nrightarrow \\leftrightarrow \\nleftrightarrow \\longleftarrow \\longrightarrow \\longleftrightarrow$ ps:\\leftarrow可用\\gets代替，\\rightarrow可用\\to代替。 $\\quad\\leftarrow\\quad\\rightarrow\\quad\\nleftarrow\\quad\\nrightarrow\\quad\\leftrightarrow\\quad\\nleftrightarrow\\quad\\longleftarrow\\quad\\longrightarrow\\quad\\longleftrightarrow$ 1$\\uparrow \\downarrow \\updownarrow \\nearrow \\searrow \\nwarrow \\swarrow$ $\\quad\\uparrow\\quad\\downarrow\\quad\\updownarrow\\quad\\nearrow\\quad\\searrow\\quad\\nwarrow\\quad\\swarrow$ 1$\\mapsto \\longmapsto$ $\\quad\\mapsto\\quad\\longmapsto$ 1$\\rightharpoonup \\rightharpoondown \\leftharpoonup \\leftharpoondown \\upharpoonleft \\upharpoonright \\downharpoonleft \\downharpoonright \\leftrightharpoons \\rightleftharpoons$ $\\quad\\rightharpoonup\\quad\\rightharpoondown\\quad\\leftharpoonup\\quad\\leftharpoondown\\quad\\upharpoonleft\\quad\\upharpoonright\\quad\\downharpoonleft\\quad\\downharpoonright\\quad\\leftrightharpoons\\quad\\rightleftharpoons$ 1$\\curvearrowleft \\circlearrowleft \\Lsh \\upuparrows \\rightrightarrows \\rightleftarrows \\rightarrowtail \\looparrowright$ $\\quad\\curvearrowleft\\quad\\circlearrowleft\\quad\\Lsh\\quad\\upuparrows\\quad\\rightrightarrows\\quad\\rightleftarrows\\quad\\rightarrowtail\\quad\\looparrowright$ 1$\\curvearrowright \\circlearrowright \\Rsh \\downdownarrows \\leftleftarrows \\leftrightarrows \\leftarrowtail \\looparrowleft$ $\\quad\\curvearrowright\\quad\\circlearrowright\\quad\\Rsh\\quad\\downdownarrows\\quad\\leftleftarrows\\quad\\leftrightarrows\\quad\\leftarrowtail\\quad\\looparrowleft$ 1$\\hookrightarrow \\hookleftarrow \\multimap \\leftrightsquigarrow \\rightsquigarrow \\twoheadrightarrow \\twoheadleftarrow$ $\\quad\\hookrightarrow\\quad\\hookleftarrow\\quad\\multimap\\quad\\leftrightsquigarrow\\quad\\rightsquigarrow\\quad\\twoheadrightarrow\\quad\\twoheadleftarrow$ 1$\\xleftarrow{left} \\xrightarrow{right} \\xLeftarrow{Left} \\xRightarrow{Right} \\xleftrightarrow{left\\&amp; right} \\xLeftrightarrow{Left\\&amp; Right}$ $\\quad\\xleftarrow{left}\\quad \\xrightarrow{right} \\quad \\xLeftarrow{Left} \\quad \\xRightarrow{Right} \\quad \\xleftrightarrow{left&amp; right} \\quad \\xLeftrightarrow{Left&amp; Right}$ 特殊符号12$\\amalg \\% \\dagger \\ddagger \\ldots \\cdots$ ps:\\dots和\\ldots貌似是一样的。 $\\quad\\amalg\\quad%\\quad\\dagger\\quad\\ddagger\\quad\\ldots\\quad\\cdots$ 1$\\smile \\frown \\wr$ $\\quad\\smile\\quad\\frown\\quad\\wr$ 1$\\diamondsuit \\heartsuit \\clubsuit \\spadesuit \\Game \\flat \\natural \\sharp$ $\\quad\\diamondsuit\\quad\\heartsuit\\quad\\clubsuit\\quad\\spadesuit\\quad\\Game\\quad\\flat\\quad\\natural\\quad\\sharp$以下是$Wiki$中没有分类的符号，我暂且将其归入特殊符号中 1$\\diagup \\diagdown \\centerdot \\ltimes \\rtimes \\leftthreetimes \\rightthreetimes$ $\\quad\\diagup\\quad\\diagdown\\quad\\centerdot\\quad\\ltimes\\quad\\rtimes\\quad\\leftthreetimes\\quad\\rightthreetimes$ 1$\\eqcirc \\circeq \\triangleq \\bumpeq \\Bumpeq \\doteqdot \\risingdotseq \\fallingdotseq$ $\\quad\\eqcirc\\quad\\circeq\\quad\\triangleq\\quad\\bumpeq\\quad\\Bumpeq\\quad\\doteqdot\\quad\\risingdotseq\\quad\\fallingdotseq$ 1$\\intercal \\barwedge \\veebar \\doublebarwedge \\between \\pitchfork$ $\\quad\\intercal\\quad\\barwedge\\quad\\veebar\\quad\\doublebarwedge\\quad\\between\\quad\\pitchfork$ 1$\\vartriangleleft \\ntriangleleft \\vartriangleright \\ntriangleright$ $\\quad\\vartriangleleft\\quad\\ntriangleleft\\quad\\vartriangleright\\quad\\ntriangleright$ 1$\\trianglelefteq \\ntrianglelefteq \\trianglerighteq \\ntrianglerighteq$ $\\quad\\trianglelefteq\\quad\\ntrianglelefteq\\quad\\trianglerighteq\\quad\\ntrianglerighteq$ 123$\\LaTeX$ ps:应评论要求加上，其实介于阅读体验还是少用些。 $\\quad\\LaTeX$ 上标、下标及积分等上标1$a^2$ $\\quad a^2$ 下标1$a_2$ $\\quad a_2$ 组合1$a^{2+2} a_{i,j}$ $\\quad a^{2+2}\\quad a_{i,j}$ 结合上下标1$a^2_2$ $\\quad a^2_2$ 前置上下标12${}^2_1\\!X^3_4$ ps:\\!的作用在下面空格一栏有讲述。 $\\quad {}^2_1!X^3_4$ 导数1$ (HTML)x' (PNG)x^\\prime (错误)x\\prime$ $\\quad x’\\quad x^\\prime\\quad x\\prime$ 导数点1$\\dot{x} \\ddot{x}$ $\\quad\\dot{x}\\quad\\ddot{x}$ 向量1$\\vec{x} \\overleftarrow{AB} \\overrightarrow{AB} \\widehat{AB}$ $\\quad\\vec{a}\\quad\\overleftarrow{AB}\\quad\\overrightarrow{AB}\\quad\\widehat{AB}$ 上弧12$\\overset{\\frown}{AB}$ ps:正确的语法应该是\\overarc，但因为没有引入amsmath宏包，所以无法使用，只能用这个替代下。 $\\quad\\overset{\\frown}{AB}$ 上划线1$\\overline{ABC}$ $\\quad\\overline{ABC}$ 下划线1$\\underline{ABC}$ $\\quad\\underline{ABC}$ 上括号1234$\\overbrace{1+2+\\cdots+100}$ $\\begin{matrix}5050\\\\\\overbrace{1+2+\\cdots+100}\\end{matrix}$ ps:'\\\\'是换行的意思。 $\\quad\\overbrace{1+2+\\cdots+100}$$\\quad\\begin{matrix}5050\\\\overbrace{1+2+\\cdots+100}\\end{matrix}$ 下括号123$\\underbrace{1+2+\\cdots+100}$ $\\begin{matrix}\\underbrace{1+2+\\cdots+100}\\\\5050\\end{matrix}$ $\\quad\\underbrace{1+2+\\cdots+100}$$\\quad\\begin{matrix}\\underbrace{1+2+\\cdots+100}\\5050\\end{matrix}$ 求和1$\\sum_{i=1}^na_i \\sum\\limits_{i=1}^na_i$ $\\quad\\sum_{i=1}^na_i\\quad\\sum\\limits_{i=1}^na_i$ 求积1$\\prod_{i=1}^na_i \\prod\\limits_{i=1}^na_i$ $\\quad\\prod_{i=1}^na_i\\quad\\prod\\limits_{i=1}^na_i$ 上积1$\\coprod_{i=1}^na_i \\coprod\\limits_{i=1}^na_i$ $\\quad\\coprod_{i=1}^na_i\\quad\\coprod\\limits_{i=1}^na_i$ 极限1$\\lim_{n\\to\\infty}x_n \\lim\\limits_{n\\to\\infty}x_n$ $\\quad\\lim_{n\\to\\infty}x_n\\quad\\lim\\limits_{n\\to\\infty}x_n$ 积分12$\\int_{-N}^{N}e^x\\,dx$ ps:\\,的作用在下面空格一栏有讲。 $\\quad\\int_{-N}^{N}e^x,dx$ 双重积分1$\\iint_M^Ndx\\,dy$ $\\quad\\iint_M^Ndx,dy$ 三重积分1$\\iiint_M^Ndx\\,dy\\,dz$ $\\quad\\iiint_M^Ndx,dy,dz$ 闭合的曲线、曲面积分1$\\oint_Cx^3\\,dx+4y^2\\,dy$ $\\quad\\oint_Cx^3,dx+4y^2,dy$ 交集1$\\bigcap_1^np \\bigcap\\limits_1^np$ $\\quad\\bigcap_1^np\\quad\\bigcap\\limits_1^np$ 并集1$\\bigcup_1^np \\bigcup\\limits_1^np$ $\\quad\\bigcup_1^np\\quad\\bigcup\\limits_1^np$ 分数、矩阵等分数1$\\frac{1}{2}=0.5$ $\\quad\\frac{1}{2}=0.5$ 小型分数12$\\tfrac{1}{2}=0.5$ ps:并不清楚为什么洛谷的LaTeX里普通分数和小型分数一样大…… $\\quad\\tfrac{1}{2}=0.5$ 大型分数1$\\dfrac{1}{2}=0.5 \\dfrac{1}{x+\\dfrac{3}{y+\\dfrac{1}{5}}}$ $\\quad\\dfrac{1}{2}=0.5\\qquad\\dfrac{1}{x+\\dfrac{3}{y+\\dfrac{1}{5}}}$ 二项式系数1$\\dbinom{n}{m}=\\dbinom{n}{n-m}=C_n^m=C_n^{n-m}$ $\\quad\\dbinom{n}{m}=\\dbinom{n}{n-m}=C_n^m=C_n^{n-m}$ 小型二项式系数1$\\tbinom{n}{m}=\\tbinom{n}{n-m}=C_n^m=C_n^{n-m}$ $\\quad\\tbinom{n}{m}=\\tbinom{n}{n-m}=C_n^m=C_n^{n-m}$ 1$\\binom{n}{m}=\\binom{n}{n-m}=C_n^m=C_n^{n-m}$ $\\quad\\binom{n}{m}=\\binom{n}{n-m}=C_n^m=C_n^{n-m}$ 矩阵12$\\begin{matrix}a&amp;b\\\\c&amp;d\\end{matrix}$ ps:&amp;是使上下行对齐。 $\\quad\\begin{matrix}a&amp;b\\c&amp;d\\end{matrix}$ 1$\\begin{vmatrix}a&amp;b\\\\c&amp;d\\end{vmatrix}$ $\\quad\\begin{vmatrix}a&amp;b\\c&amp;d\\end{vmatrix}$ 1$\\begin{Vmatrix}a&amp;b\\\\c&amp;d\\end{Vmatrix}$ $\\quad\\begin{Vmatrix}a&amp;b\\c&amp;d\\end{Vmatrix}$ 12$\\begin{bmatrix}a&amp;\\cdots&amp;b\\\\\\vdots&amp;\\ddots&amp;\\vdots\\\\c&amp;\\cdots&amp;d\\end{bmatrix}$ ps:\\vdots是竖着3个点，\\ddots是斜着3个点。 $\\quad\\begin{bmatrix}a&amp;\\cdots&amp;b\\\\vdots&amp;\\ddots&amp;\\vdots\\c&amp;\\cdots&amp;d\\end{bmatrix}$ 1$\\begin{Bmatrix}a&amp;c\\\\b&amp;d\\end{Bmatrix}$ $\\quad\\begin{Bmatrix}a&amp;c\\b&amp;d\\end{Bmatrix}$ 1$\\begin{pmatrix}a&amp;c\\\\b&amp;d\\end{pmatrix}$ $\\quad\\begin{pmatrix}a&amp;c\\b&amp;d\\end{pmatrix}$ 矩阵嵌套1$\\begin{vmatrix} \\begin{Bmatrix}A &amp; \\\\ c &amp; d \\end{Bmatrix} &amp; x\\\\ \\dfrac{1}{2} &amp; \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{matrix} \\end{vmatrix}$ $\\quad \\begin{vmatrix} \\begin{Bmatrix}A &amp; \\ c &amp; d \\end{Bmatrix} &amp; x\\ \\dfrac{1}{2} &amp; \\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\end{matrix} \\end{vmatrix}$ 条件定义(如分段函数)1$f(x)=\\begin{cases}x-1&amp;x\\leqslant3\\\\x^2+3x-1&amp;x&amp;gt;3\\end{cases}$ $\\quad f(x)=\\begin{cases}x-1&amp;x\\leqslant3\\x^2+3x-1&amp;x&gt;3\\end{cases}$ 方程组1$\\begin{cases}2x+9y-5z=10\\\\4x+20y+z=24\\\\x-\\dfrac{1}{2}y+3z=8\\end{cases}$ $\\quad\\begin{cases}2x+9y-5z=10\\4x+20y+z=24\\x-\\dfrac{1}{2}y+3z=8\\end{cases}$ 多行等式12345$\\begin{aligned}f(x) &amp; = (x + 1)^2 \\\\ &amp; = x^2 + 2x + 1\\end{aligned}$$\\begin{aligned}a_1 &amp; = 1 \\\\ a_2 &amp; = 2 \\\\ &amp; \\dots \\\\ a_n &amp; = n\\end{aligned}$ ps:原语法为align，现在是aligned。 $\\quad\\begin{aligned}f(x) &amp; = (x + 1)^2 \\ &amp; = x^2 + 2x + 1\\end{aligned}\\qquad\\begin{aligned}a_1 &amp; = 1 \\ a_2 &amp; = 2 \\ &amp; \\dots \\ a_n &amp; = n\\end{aligned}$ 数组/表格12$\\begin{array}{|c|c||c|}x&amp;y&amp;z\\\\8&amp;2&amp;4\\\\2&amp;3&amp;9\\\\10&amp;\\dfrac{3}{4}&amp;\\sqrt{3}\\\\a&amp;b&amp;c\\end{array}$ ps:\\begin{array}{}←这个大括号里是形如'|c|c||c|'这样的格式，'|'是两列的分割线，'c'是表示这里有一列，而内容中使用'&amp;'来分开每一列的内容。这里可能讲的不是很清楚，所以最好还是自己尝试一下。 $\\quad\\begin{array}{|c|c||c|}x&amp;y&amp;z\\8&amp;2&amp;4\\2&amp;3&amp;9\\10&amp;\\dfrac{3}{4}&amp;\\sqrt{3}\\a&amp;b&amp;c\\end{array}$ 字体希腊字母貌似洛谷对一些希腊字母不支持，也许是因为像英文字母，所以我这里只好用英文字母代替了。 1$A B\\Gamma\\Delta EZH\\Theta$ $\\quad A B\\Gamma\\Delta EZH\\Theta$ 1$IK\\Lambda MN\\Xi O\\Pi$ $\\quad IK\\Lambda MN\\Xi O\\Pi$ 1$P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega$ $\\quad P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega$ 1$\\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta$ $\\quad\\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta$ 1$\\iota\\kappa\\lambda\\mu\\nu\\xi\\omicron\\pi$ $\\quad\\iota\\kappa\\lambda\\mu\\nu\\xi\\omicron\\pi$ 1$\\rho\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega$ $\\quad\\rho\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega$ 1$\\varepsilon\\digamma\\varkappa\\varpi$ $\\quad\\varepsilon\\digamma\\varkappa\\varpi$ 1$\\varrho\\varsigma\\vartheta\\varphi$ $\\quad\\varrho\\varsigma\\vartheta\\varphi$ 希伯来符号1$\\aleph\\beth\\gimel\\daleth$ $\\quad\\aleph\\beth\\gimel\\daleth$ 黑板粗体12$\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ ps:仅支持大写英文字母。 $\\quad\\mathbb{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ 粗体1234$\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathbf{abcdefghijklmnopqrstuvwxyz}$$\\mathbf{0123456789}$ ps:支持大小写英文字母、数字和大写希腊字母。 $\\quad\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\mathbf{abcdefghijklmnopqrstuvwxyz}$ $\\quad\\mathbf{A B\\Gamma\\Delta EZH\\Theta}$ $\\quad\\mathbf{IK\\Lambda MN\\Xi O\\Pi}$ $\\quad\\mathbf{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\quad\\mathbf{0123456789}$ 斜体(英文字母和小写希腊字母默认)1234$\\mathit{A B\\Gamma\\Delta EZH\\Theta}$ $\\mathit{IK\\Lambda MN\\Xi O\\Pi}$ $\\mathit{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\mathit{0123456789}$ $\\quad\\mathit{A B\\Gamma\\Delta EZH\\Theta}$ $\\quad\\mathit{IK\\Lambda MN\\Xi O\\Pi}$ $\\quad\\mathit{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\quad\\mathit{0123456789}$ 罗马体1234$\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathrm{abcdefghijklmnopqrstuvwxyz}$ $\\mathrm{0123456789}$ ps:支持大小写英文字母和数字。 $\\quad\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\mathrm{abcdefghijklmnopqrstuvwxyz}$ $\\quad\\mathrm{0123456789}$ 打字机字体1234567$\\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathtt{abcdefghijklmnopqrstuvwxyz}$ $\\mathtt{A B\\Gamma\\Delta EZH\\Theta}$ $\\mathtt{IK\\Lambda MN\\Xi O\\Pi}$ $\\mathtt{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\mathtt{0123456789}$ ps:支持大小写英文字母、大写希腊字母和数字。 $\\quad \\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad \\mathtt{abcdefghijklmnopqrstuvwxyz}$ $\\quad \\mathtt{A B\\Gamma\\Delta EZH\\Theta}$ $\\quad \\mathtt{IK\\Lambda MN\\Xi O\\Pi}$ $\\quad \\mathtt{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\quad \\mathtt{0123456789}$ 无衬线体1234567$\\mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathsf{abcdefghijklmnopqrstuvwxyz}$ $\\mathsf{A B\\Gamma\\Delta EZH\\Theta}$ $\\mathsf{IK\\Lambda MN\\Xi O\\Pi}$ $\\mathsf{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\mathsf{0123456789}$ ps:支持大小写英文字母、大写希腊字母和数字。 $\\quad\\mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\mathsf{abcdefghijklmnopqrstuvwxyz}$ $\\quad\\mathsf{A B\\Gamma\\Delta EZH\\Theta}$ $\\quad\\mathsf{IK\\Lambda MN\\Xi O\\Pi}$ $\\quad\\mathsf{P\\Sigma T\\Upsilon\\Phi X\\Psi\\Omega}$ $\\quad\\mathsf{0123456789}$ 手写体/花体123$\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathcal{0123456789}$ ps:支持大写英文字母和数字。 $\\quad\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\mathcal{0123456789}$ $Fraktur$体1234$\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\mathfrak{abcdefghijklmnopqrstuvwxyz}$ $\\mathfrak{0123456789}$ ps:支持大小写英文字母和数字。 $\\quad\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\mathfrak{abcdefghijklmnopqrstuvwxyz}$ $\\quad\\mathfrak{0123456789}$ 小型非斜体字1234$\\scriptstyle\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\scriptstyle\\text{abcdefghijklmnopqrstuvwxyz}$ $\\scriptstyle\\text{0123456789}$ ps:支持大小写英文字母和数字，\\text见下一栏。 $\\quad\\scriptstyle\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$ $\\quad\\scriptstyle\\text{abcdefghijklmnopqrstuvwxyz}$ $\\quad\\scriptstyle\\text{0123456789}$ 混合字体斜体字符12$x y z$ ps:忽略公式源码中的空格，要强制空格的看下面空格一栏。 $\\quad x y z$ 非斜体字符12$\\text{x y z} \\text{中文}$ ps:不会忽略空格，支持大小写英文字母和数字，以及中文。 $\\quad\\text{x y z}\\quad\\text{中文}$ 混合斜体与非斜体12$\\text{if }n\\text{ is even}$ ps:注意在\\text中使用空格来显得更好看，或者可以用强制空格代替。 $\\quad\\text{if }n\\text{ is even}$ 括号普通括号12$(\\dfrac{1}{2}) (\\dfrac{1}{x+\\dfrac{2}{3}})$ ps:对于较大的式子显得比较难看。 $\\quad(\\dfrac{1}{2})\\qquad(\\dfrac{1}{x+\\dfrac{2}{3}})$ 根据式子大小匹配的括号1$\\left(\\dfrac{1}{2}\\right) \\left(\\dfrac{1}{x+\\dfrac{2}{3}}\\right)$ $\\quad\\left(\\dfrac{1}{2}\\right)\\qquad\\left(\\dfrac{1}{x+\\dfrac{2}{3}}\\right)$此功能$($使用\\left和\\right$)$可以推广到不同的括号： 圆括号/小括号1$\\left(\\dfrac{1}{2}\\right)$ $\\quad\\left(\\dfrac{1}{2}\\right)$ 方括号/中括号1$\\left[\\dfrac{1}{2}\\right]$ $\\quad\\left[\\dfrac{1}{2}\\right]$ 花括号/大括号12$\\left\\{\\dfrac{1}{2}\\right\\}$ ps:注意大括号要用\\{和\\}。 $\\quad\\left{\\dfrac{1}{2}\\right}$ 角括号12$\\left\\langle\\dfrac{1}{2}\\right\\rangle$ ps:\\langle可以用&amp;lt;，\\rangle可以用&amp;gt;。 $\\quad\\left\\langle\\dfrac{1}{2}\\right\\rangle$ 单竖线/绝对值1$\\left|\\dfrac{1}{2}\\right|$ $\\quad\\left|\\dfrac{1}{2}\\right|$ 双竖线1$\\left\\|\\dfrac{1}{2}\\right\\|$ $\\quad\\left|\\dfrac{1}{2}\\right|$ 向下取整1$\\left\\lfloor\\dfrac{1}{2}\\right\\rfloor$ $\\quad\\left\\lfloor\\dfrac{1}{2}\\right\\rfloor$ 向上取整1$\\left\\lceil\\dfrac{1}{2}\\right\\rceil$ $\\quad\\left\\lceil\\dfrac{1}{2}\\right\\rceil$ 斜线1$\\left/\\dfrac{1}{2}\\right/$ $\\quad\\left/\\dfrac{1}{2}\\right/$ 反斜线1$\\left\\backslash\\dfrac{1}{2}\\right\\backslash$ $\\quad\\left\\backslash\\dfrac{1}{2}\\right\\backslash$ 上下箭头1$\\left\\uparrow\\dfrac{1}{2}\\right\\uparrow$ $\\quad\\left\\uparrow\\dfrac{1}{2}\\right\\uparrow$ 1$\\left\\Downarrow\\dfrac{1}{2}\\right\\Downarrow$ $\\quad\\left\\Downarrow\\dfrac{1}{2}\\right\\Downarrow$ 1$\\left\\updownarrow\\dfrac{1}{2}\\right\\updownarrow$ $\\quad\\left\\updownarrow\\dfrac{1}{2}\\right\\updownarrow$因为上下箭头太多了，这里就不一一示范了 混合括号其实上述括号都可以混合使用，这里就随便列两个了。 1$\\left&lt;\\dfrac{1}{2}\\right/$ $\\left&lt;\\dfrac{1}{2}\\right/$ 1$\\left(\\dfrac{1}{2},1\\right]$ $\\quad\\left(\\dfrac{1}{2},1\\right]$ 单左括号上述括号都适用，这里就随便列一个。 1$\\left(\\dfrac{1}{2}\\right.$ $\\quad\\left(\\dfrac{1}{2}\\right.$ 单右括号同上。 1$\\left.\\dfrac{1}{2}\\right]$ $\\quad\\left.\\dfrac{1}{2}\\right]$ 强制括号大小12$\\Bigg(\\bigg[\\Big\\{\\big&lt;x\\big&gt;\\Big\\}\\bigg]\\Bigg)$ ps:即使用\\Bigg、\\bigg、\\Big、\\big来控制括号大小。 $\\Bigg(\\bigg[\\Big{\\big&lt;x\\big&gt;\\Big}\\bigg]\\Bigg)$ 空格一般$LaTeX$能自动处理大多数空格，但必要时候需要强制控制大小。 紧贴1$x\\!y$ $\\quad x!y$宽度为$-\\frac{m}{6}$ 无空格1$xy$ $\\quad xy$宽度为$0$ 小空格1$x\\,y$ $\\quad x,y$宽度为$\\frac{m}{6}$ 中等空格1$x\\;y$ $\\quad x;y$宽度为$\\frac{2m}{7}$ 大空格1$x\\ y$ $\\quad x\\ y$宽度为$\\frac{m}{3}$ $quad$空格1$x\\quad y$ $\\quad x\\quad y$宽度为$m$ 两个$quad$空格1$x\\qquad y$ $\\quad x\\qquad y$宽度为$2m$ 颜色语法字体颜色：{\\color{色调}{表达式}}背景颜色：{\\color{文字色调{}}colorbox{表达式(可以打中文)}} 洛谷内支持的颜色(洛谷里有挺多颜色是不支持的，而且有些颜色和$Wiki$上不太一样……)${\\color{Aquamarine}{Aquamarine}}$${\\color{Black}{Black}}$${\\color{Blue}{Blue}}$${\\color{BlueViolet}{BlueViolet}}$${\\color{Brown}{Brown}}$${\\color{CadetBlue}{CadetBlue}}$${\\color{CornflowerBlue}{CornflowerBlue}}$${\\color{Cyan}{Cyan}}$${\\color{DarkOrchid}{DarkOrchid}}$${\\color{ForestGreen}{ForestGreen}}$${\\color{Fuchsia}{Fuchsia}}$${\\color{Goldenrod}{Goldenrod}}$${\\color{Gold}{Gold}}$${\\color{Gray}{Gray}}$${\\color{CadetBlue}{CadetBlue}}$${\\color{Green}{Green}}$${\\color{GreenYellow}{GreenYellow}}$${\\color{Lavender}{Lavender}}$${\\color{LimeGreen}{LimeGreen}}$${\\color{Magenta}{Magenta}}$${\\color{Maroon}{Maroon}}$${\\color{Orange}{Orange}}$${\\color{OrangeRed}{OrangeRed}}$${\\color{Orchid}{Orchid}}$${\\color{Plum}{Plum}}$${\\color{Purple}{Purple}}$${\\color{Red}{Red}}$${\\color{RoyalBlue}{RoyalBlue}}$${\\color{Salmon}{Salmon}}$${\\color{SeaGreen}{SeaGreen}}$${\\color{SkyBlue}{SkyBlue}}$${\\color{SpringGreen}{SpringGreen}}$${\\color{Tan}{Tan}}$${\\color{Thistle}{Thistle}}$${\\color{Turquoise}{Turquoise} }$${\\color{Violet}{Violet}}$${\\color{White}{White}}\\gets$这是白= = ${\\color{Yellow}{Yellow}}$${\\color{YellowGreen}{YellowGreen}}$随便举个例子： 1$x=\\dfrac{-b\\pm\\sqrt{\\color{Red}{b}^2-4ac}}{\\color{Blue}{2a}}$ $\\quad x=\\dfrac{-b\\pm\\sqrt{\\color{Red}{b}^2-4ac}}{\\color{Blue}{2a}}$ 1$\\color{Blue}\\colorbox{Yellow}{LaTeX公式大全}$ $\\color{Blue}\\colorbox{Yellow}{LaTeX公式大全}$ 把数学公式框起来123$$\\boxed{\\sum\\limits_{i = 1}^{n} i = \\dfrac{n(n - 1)}{2}}$$ ps:对于行内模式同样有效，不过大多情况用于独立模式。 $$\\boxed{\\sum\\limits_{i = 1}^{n} i = \\dfrac{n(n - 1)}{2}}$$","link":"/posts/10473.html"},{"title":"P8481 Binary search 题解","text":"这题其实有最简单最暴力最直接的DFS算法。 我们可以看到，本题其实以及给出了示例代码： 1234567891011121314int find(int *num,int x,int len){ int l=0,r=len-1,mid,cnt=0,w; while(l&lt;r) { cnt++; w=rand()%2; mid=(l+r+w)/2; if(num[mid]-w&lt;x) l=mid+!w; else r=mid-w; } return mid;} 但是代码中给出的是rand()， 所以其实将rand()值改为固定的$0,1$,则有： 123456int mid1=(l+r)&gt;&gt;1; if(num[mid1]&gt;=search){ dfs(cnt+1,l,mid1); }else{ dfs(cnt+1,mid1+1,r); } 和 123456int mid2=(l+r+1)&gt;&gt;1;if(num[mid2]-1&gt;=search){ dfs(cnt+1,l,mid2-1); }else{ dfs(cnt+1,mid2,r); } 其实完全就是改示例代码，根本就不需要动脑子。 最后我们只需要将上述代码整合，二分递归出最小的查找值即可。 AC Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;int num[1048578],search;int dp[1048578][3];int find(int *num,int x,int len){ int l=0,r=len-1,mid,cnt=0,w; while(l&lt;r) { cnt++; w=rand()%2; mid=(l+r+w)/2; if(num[mid]-w&lt;x) l=mid+!w; else r=mid-w; } return mid;}long long ans=9223372036854775807ll;void dfs(long long cnt,int l,int r){ //基本DFS。 if(l==r){ ans=min(ans,cnt); return ; } int mid1=(l+r)&gt;&gt;1,mid2=(l+r+1)&gt;&gt;1; //两种方案分类讨论。 if(num[mid1]&gt;=search){ dfs(cnt+1,l,mid1); }else{ dfs(cnt+1,mid1+1,r); } if(num[mid2]-1&gt;=search){ dfs(cnt+1,l,mid2-1); }else{ dfs(cnt+1,mid2,r); } }int main(){ int n; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;num[i]; } int m; cin&gt;&gt;m; for(int i = 1;i&lt;=m;i++){ cin&gt;&gt;search; ans=9223372036854775807ll; //一定要初始化最大值！！！ dfs(0,1,n); cout&lt;&lt;ans&lt;&lt;endl; }} 完结撒花！！！","link":"/posts/12742.html"},{"title":"Pandas笔记","text":"注意：这篇文档只适用于高考，完全不是Pandas文档。 DataFrame提供数据： ID data01 data02 data03 data04 data05 data06 data07 data08 1 810 841 947 221 114 886 489 380 2 903 225 742 722 536 448 224 917 3 387 380 853 336 963 384 22 360 4 926 487 321 819 427 944 615 178 5 24 667 199 842 323 565 556 90 6 974 661 443 753 888 293 730 117 读入数据 1df = pd.read_excel(&quot;test.xlsx&quot;) 1234567 ID data01 data02 data03 data04 data05 data06 data07 data080 1 813 620 621 63 31 883 860 2361 2 244 84 767 592 151 110 941 9112 3 339 776 993 779 699 247 230 2393 4 952 415 814 617 308 930 625 9114 5 812 706 378 959 52 700 711 545 6 946 208 860 82 977 835 873 268 把首列设为index 1df = pd.read_excel(&quot;test.xlsx&quot;,index_col=0) 12345678 data01 data02 data03 data04 data05 data06 data07 data08ID1 813 620 621 63 31 883 860 2362 244 84 767 592 151 110 941 9113 339 776 993 779 699 247 230 2394 952 415 814 617 308 930 625 9115 812 706 378 959 52 700 711 546 946 208 860 82 977 835 873 268 一些操作.Treturn DataFrame 行列转换 1234df = pd.read_excel(&quot;test.xlsx&quot;)print(df)print()print(df.T) 123456789101112131415161718 ID data01 data02 data03 data04 data05 data06 data07 data080 1 813 620 621 63 31 883 860 2361 2 244 84 767 592 151 110 941 9112 3 339 776 993 779 699 247 230 2393 4 952 415 814 617 308 930 625 9114 5 812 706 378 959 52 700 711 545 6 946 208 860 82 977 835 873 268 0 1 2 3 4 5ID 1 2 3 4 5 6data01 813 244 339 952 812 946data02 620 84 776 415 706 208data03 621 767 993 814 378 860data04 63 592 779 617 959 82data05 31 151 699 308 52 977data06 883 110 247 930 700 835data07 860 941 230 625 711 873data08 236 911 239 911 54 268 .at[index,columns]读取return values 12print(df.at[5,&quot;ID&quot;])print(df.at[4,&quot;data06&quot;]) 126700 操作123print(df.at[4,&quot;data06&quot;])df.at[4,&quot;data06&quot;]=114print(df.at[4,&quot;data06&quot;]) 12700114 .columnsreturn 类似list 1print(df.columns) 123Index(['ID', 'data01', 'data02', 'data03', 'data04', 'data05', 'data06', 'data07', 'data08'], dtype='object') .indexreturn 类似list 1print(df.index) 1RangeIndex(start=0, stop=6, step=1) .pop(columns)删除某一列然后将删除的值返回 return Series 12345print(df)print()print(df.pop(&quot;data05&quot;))print()print(df) 1234567891011121314151617181920212223 ID data01 data02 data03 data04 data05 data06 data07 data080 1 813 620 621 63 31 883 860 2361 2 244 84 767 592 151 110 941 9112 3 339 776 993 779 699 247 230 2393 4 952 415 814 617 308 930 625 9114 5 812 706 378 959 52 700 711 545 6 946 208 860 82 977 835 873 2680 311 1512 6993 3084 525 977Name: data05, dtype: int64 ID data01 data02 data03 data04 data06 data07 data080 1 813 620 621 63 883 860 2361 2 244 84 767 592 110 941 9112 3 339 776 993 779 247 230 2393 4 952 415 814 617 930 625 9114 5 812 706 378 959 700 711 545 6 946 208 860 82 835 873 268 .size获取整个表格数据个数 return int 1print(df.size) 154 .count(axis=0, numeric_only=False)return Series 更改数据： ID name data01 data02 data03 data04 data05 data06 data07 data08 1 John 215 406 844 901 202 41 352 266 2 Bob 308 612 528 546 39 95 146 163 3 Michael 608 695 620 707 679 44 255 793 4 Alice 466 275 154 519 193 529 338 480 5 Merry 867 545 283 475 867 709 118 359 6 Harry 975 195 980 997 218 734 546 338 12345print(df.count())print()print(df.count(axis=1))print()print(df.count(numeric_only=True)) 123456789101112131415161718192021222324252627282930ID 6name 6data01 6data02 6data03 6data04 6data05 6data06 6data07 6data08 6dtype: int640 101 102 103 104 105 10dtype: int64ID 6data01 6data02 6data03 6data04 6data05 6data06 6data07 6data08 6dtype: int64 .drop(labels=None, axis=0, index=None, columns=None)return DataFrame 删除列123print(df)df = df.drop(columns=[&quot;data02&quot;,&quot;data03&quot;])print(df) 或者 123print(df)df = df.drop([&quot;data02&quot;,&quot;data03&quot;],axis=1)print(df) 1234567891011121314 ID name data01 data02 data03 data04 data05 data06 data07 data080 1 John 73 479 984 435 550 396 80 6601 2 Bob 84 785 929 828 742 80 864 2572 3 Michael 80 444 874 345 141 172 906 613 4 Alice 870 380 328 396 564 362 371 5994 5 Merry 668 997 189 113 410 969 542 3325 6 Harry 536 732 969 609 852 517 444 346 ID name data01 data04 data05 data06 data07 data080 1 John 73 435 550 396 80 6601 2 Bob 84 828 742 80 864 2572 3 Michael 80 345 141 172 906 613 4 Alice 870 396 564 362 371 5994 5 Merry 668 113 410 969 542 3325 6 Harry 536 609 852 517 444 346 删除行123print(df)df = df.drop([2,5])print(df) 或者 123print(df)df = df.drop(index=[2,5])print(df) 123456789101112 ID name data01 data02 data03 data04 data05 data06 data07 data080 1 John 73 479 984 435 550 396 80 6601 2 Bob 84 785 929 828 742 80 864 2572 3 Michael 80 444 874 345 141 172 906 613 4 Alice 870 380 328 396 564 362 371 5994 5 Merry 668 997 189 113 410 969 542 3325 6 Harry 536 732 969 609 852 517 444 346 ID name data01 data02 data03 data04 data05 data06 data07 data080 1 John 73 479 984 435 550 396 80 6601 2 Bob 84 785 929 828 742 80 864 2573 4 Alice 870 380 328 396 564 362 371 5994 5 Merry 668 997 189 113 410 969 542 332 .groupby(axis=0, as_index=True, sort=True)return DataFrameGroupBy 更改数据： ID name data01 data02 data03 data04 1 John 285 53 863 853 2 Bob 349 568 33 322 3 Michael 886 840 91 726 4 Alice 67 752 106 75 5 Merry 443 414 956 496 6 Harry 235 860 230 211 7 John 800 604 245 659 8 Bob 693 558 761 266 9 Michael 532 577 504 381 10 Alice 703 118 867 707 11 Merry 253 861 240 334 12 Harry 585 288 361 135 13 John 828 974 814 811 14 Bob 730 781 13 693 15 Michael 274 3 521 624 16 Alice 437 587 476 683 17 John 494 936 475 396 18 Bob 390 535 506 874 19 Michael 892 70 203 417 20 Alice 510 464 510 70 123456789101112print(df)print()df_gb = df.groupby(&quot;name&quot;)print(df_gb)print()print(df_gb.all())print()df_gb = df.groupby(&quot;name&quot;,as_index=False)print(df_gb.all())print()df_gb = df.groupby(&quot;name&quot;,sort=False)print(df_gb.all()) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 7263 4 Alice 67 752 106 754 5 Merry 443 414 956 4965 6 Harry 235 860 230 2116 7 John 800 604 245 6597 8 Bob 693 558 761 2668 9 Michael 532 577 504 3819 10 Alice 703 118 867 70710 11 Merry 253 861 240 33411 12 Harry 585 288 361 13512 13 John 828 974 814 81113 14 Bob 730 781 13 69314 15 Michael 274 3 521 62415 16 Alice 437 587 476 68316 17 John 494 936 475 39617 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001ECA31A79D0&gt; ID data01 data02 data03 data04nameAlice True True True True TrueBob True True True True TrueHarry True True True True TrueJohn True True True True TrueMerry True True True True TrueMichael True True True True True name ID data01 data02 data03 data040 Alice True True True True True1 Bob True True True True True2 Harry True True True True True3 John True True True True True4 Merry True True True True True5 Michael True True True True True ID data01 data02 data03 data04nameJohn True True True True TrueBob True True True True TrueMichael True True True True TrueAlice True True True True TrueMerry True True True True TrueHarry True True True True True .count()返回每个群组内项目的计数 return DataFrame 12df_gb = df.groupby(&quot;name&quot;)print(df_gb.count()) 12345678 ID data01 data02 data03 data04nameAlice 4 4 4 4 4Bob 4 4 4 4 4Harry 2 2 2 2 2John 4 4 4 4 4Merry 2 2 2 2 2Michael 4 4 4 4 4 .max(numeric_only=False)计算每个群组中的最大值 注意： numeric_only=False在教科书版本中默认为True，这个选项若为False会使非整形和浮点型条目报错！！！以下.min()、.mean()、.sum()同理. return DataFrame 12df_gb = df.groupby(&quot;name&quot;)print(df_gb.max()) 12345678 ID data01 data02 data03 data04nameAlice 20 703 752 867 707Bob 18 730 781 761 874Harry 12 585 860 361 211John 17 828 974 863 853Merry 11 443 861 956 496Michael 19 892 840 521 726 .min(numeric_only=False)计算每个群组中的最小值 return DataFrame 12df_gb = df.groupby(&quot;name&quot;)print(df_gb.min()) 12345678 ID data01 data02 data03 data04nameAlice 4 67 118 106 70Bob 2 349 535 13 266Harry 6 235 288 230 135John 1 285 53 245 396Merry 5 253 414 240 334Michael 3 274 3 91 381 .mean(numeric_only=False)计算每个群组中数据的平均数 return DataFrame 12df_gb = df.groupby(&quot;name&quot;)print(df_gb.mean()) 12345678 ID data01 data02 data03 data04nameAlice 12.5 429.25 480.25 489.75 383.75Bob 10.5 540.50 610.50 328.25 538.75Harry 9.0 410.00 574.00 295.50 173.00John 9.5 601.75 641.75 599.25 679.75Merry 8.0 348.00 637.50 598.00 415.00Michael 11.5 646.00 372.50 329.75 537.00 .sum(numeric_only=False)给每个群组中的数据求和 return DataFrame 12df_gb = df.groupby(&quot;name&quot;)print(df_gb.sum()) 12345678 ID data01 data02 data03 data04nameAlice 50 1717 1921 1959 1535Bob 42 2162 2442 1313 2155Harry 18 820 1148 591 346John 38 2407 2567 2397 2719Merry 16 696 1275 1196 830Michael 46 2584 1490 1319 2148 .head(n=5)返回每个群组中前n项 return DataFrame 1234567df_gb = df.groupby(&quot;name&quot;)print(df_gb.head(1))print()print(df_gb.head(n=1))print()print(df_gb.head(2))print() 1234567891011121314151617181920212223242526272829 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 7263 4 Alice 67 752 106 754 5 Merry 443 414 956 4965 6 Harry 235 860 230 211 ID name data01 data02 data03 data04 0 1 John 285 53 863 853 1 2 Bob 349 568 33 322 2 3 Michael 886 840 91 726 3 4 Alice 67 752 106 75 4 5 Merry 443 414 956 496 5 6 Harry 235 860 230 211 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 7263 4 Alice 67 752 106 754 5 Merry 443 414 956 4965 6 Harry 235 860 230 2116 7 John 800 604 245 6597 8 Bob 693 558 761 2668 9 Michael 532 577 504 3819 10 Alice 703 118 867 70710 11 Merry 253 861 240 33411 12 Harry 585 288 361 135 .tail(n=5)返回每个群组中后n项 return DataFrame 1234567df_gb = df.groupby(&quot;name&quot;)print(df_gb.tail(1))print()print(df_gb.tail(n=1))print()print(df_gb.tail(2))print() 1234567891011121314151617181920212223242526272829 ID name data01 data02 data03 data0410 11 Merry 253 861 240 33411 12 Harry 585 288 361 13516 17 John 494 936 475 39617 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70 ID name data01 data02 data03 data0410 11 Merry 253 861 240 33411 12 Harry 585 288 361 13516 17 John 494 936 475 39617 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70 ID name data01 data02 data03 data044 5 Merry 443 414 956 4965 6 Harry 235 860 230 21110 11 Merry 253 861 240 33411 12 Harry 585 288 361 13512 13 John 828 974 814 81113 14 Bob 730 781 13 69314 15 Michael 274 3 521 62415 16 Alice 437 587 476 68316 17 John 494 936 475 39617 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70 .head(n=5)返回DataFrame的前n项 return DataFrame 123456print(df.head())print()print(df.head(3))print()print(df.head(n=6))print() 12345678910111213141516171819 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 7263 4 Alice 67 752 106 754 5 Merry 443 414 956 496 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 726 ID name data01 data02 data03 data040 1 John 285 53 863 8531 2 Bob 349 568 33 3222 3 Michael 886 840 91 7263 4 Alice 67 752 106 754 5 Merry 443 414 956 4965 6 Harry 235 860 230 211 .tail(n=5)返回DataFrame的后n项 return DataFrame 1234print(df.tail())print()print(df.tail(3))print() 1234567891011 ID name data01 data02 data03 data0415 16 Alice 437 587 476 68316 17 John 494 936 475 39617 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70 ID name data01 data02 data03 data0417 18 Bob 390 535 506 87418 19 Michael 892 70 203 41719 20 Alice 510 464 510 70 .max(axis=0, numeric_only=False)返回行或列的最大值 return Series 1print(df.max()) 1234567ID 20name Michaeldata01 892data02 974data03 956data04 874dtype: object 对于axis=True我们发现 1print(df.max(axis=1)) 1234567891011121314151617181920212223242526Traceback (most recent call last): File &quot;e:\\pyCode\\pandas\\test.py&quot;, line 14, in &lt;module&gt; print(df.max(axis=1)) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\generic.py&quot;, line 11646, in max return NDFrame.max(self, axis, skipna, numeric_only, **kwargs) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\generic.py&quot;, line 11185, in max return self._stat_function( File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\generic.py&quot;, line 11158, in _stat_function return self._reduce( File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\frame.py&quot;, line 10524, in _reduce res = df._mgr.reduce(blk_func) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\internals\\managers.py&quot;, line 1534, in reduce nbs = blk.reduce(func) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\internals\\blocks.py&quot;, line 339, in reduce result = func(self.values) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\frame.py&quot;, line 10487, in blk_func return op(values, axis=axis, skipna=skipna, **kwds) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\nanops.py&quot;, line 158, in f result = alt(values, axis=axis, skipna=skipna, **kwds) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\nanops.py&quot;, line 421, in new_func result = func(values, axis=axis, skipna=skipna, mask=mask, **kwargs) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\pandas\\core\\nanops.py&quot;, line 1094, in reduction result = getattr(values, meth)(axis) File &quot;C:\\Users\\pandas_test\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages\\numpy\\core\\_methods.py&quot;, line 41, in _amax return umr_maximum(a, axis, None, out, keepdims, initial, where)TypeError: '&gt;=' not supported between instances of 'int' and 'str' 这就是上面说的numeric_only=False造成的我们可以看到错误为 1TypeError: '&gt;=' not supported between instances of 'int' and 'str' 但考试笔试请忽略 正确的应该是 1print(df.max(axis=1, numeric_only=True)) 这样会默认省掉name这一列 1234567891011121314151617181920210 8631 5682 8863 7524 9565 8606 8007 7618 5779 86710 86111 58512 97413 78114 62415 68316 93617 87418 89219 510dtype: int64 .min(axis=0, numeric_only=False)返回行或列的最小值 return Series 1234print(df.min())print()print(df.min(axis=1,numeric_only=True))print() 1234567891011121314151617181920212223242526272829ID 1name Alicedata01 67data02 3data03 13data04 70dtype: object 0 11 22 33 44 55 66 77 88 99 1010 1111 1212 1313 1314 315 1616 1717 1818 1919 20dtype: int64 .mean(axis=0, numeric_only=False)返回行或列的平均值 return Series 1234print(df.mean(numeric_only=True))print()print(df.mean(axis=1,numeric_only=True))print() 12345678910111213141516171819202122232425262728ID 10.50data01 519.30data02 542.15data03 438.75data04 486.65dtype: float640 411.01 254.82 509.23 200.84 462.85 308.46 463.07 457.28 400.69 481.010 339.811 276.212 688.013 446.214 287.415 439.816 463.617 464.618 320.219 314.8dtype: float64 .sum(axis=0, numeric_only=False)对行或列求和 return Series 123456print(df.sum())print()print(df.sum(numeric_only=True))print()print(df.sum(axis=1,numeric_only=True))print() 123456789101112131415161718192021222324252627282930313233343536ID 210name JohnBobMichaelAliceMerryHarryJohnBobMichaelAli...data01 10386data02 10843data03 8775data04 9733dtype: objectID 210data01 10386data02 10843data03 8775data04 9733dtype: int64 0 2055 1 1274 2 2546 3 1004 4 2314 5 15426 23157 22868 20039 240510 169911 138112 344013 223114 143715 219916 231817 232318 160119 1574dtype: int64 .to_excel() .to_csv() …导出到excel,csv等等 return .xlsx, .xls, .csv… 12df.to_excel(&quot;export.xlsx&quot;)df.to_csv(&quot;export.csv&quot;)","link":"/posts/34833.html"},{"title":"Pause Giant AI Experiments An Open Letter","text":"We call on all AI labs to immediately pause for at least 6 months the training of AI systems more powerful than GPT-4. PUBLISHEDMarch 22, 2023 AI systems with human-competitive intelligence can pose profound risks to society and humanity, as shown by extensive research and acknowledged by top AI labs. As stated in the widely-endorsed Asilomar AI Principles, Advanced AI could represent a profound change in the history of life on Earth, and should be planned for and managed with commensurate care and resources. Unfortunately, this level of planning and management is not happening, even though recent months have seen AI labs locked in an out-of-control race to develop and deploy ever more powerful digital minds that no one – not even their creators – can understand, predict, or reliably control.Contemporary AI systems are now becoming human-competitive at general tasks, and we must ask ourselves: Should we let machines flood our information channels with propaganda and untruth? Should we automate away all the jobs, including the fulfilling ones? Should we develop nonhuman minds that might eventually outnumber, outsmart, obsolete and replace us? Should we risk loss of control of our civilization? Such decisions must not be delegated to unelected tech leaders. Powerful AI systems should be developed only once we are confident that their effects will be positive and their risks will be manageable. This confidence must be well justified and increase with the magnitude of a system’s potential effects. OpenAI’s recent statement regarding artificial general intelligence, states that “At some point, it may be important to get independent review before starting to train future systems, and for the most advanced efforts to agree to limit the rate of growth of compute used for creating new models.” We agree. That point is now.Therefore, we call on all AI labs to immediately pause for at least 6 months the training of AI systems more powerful than GPT-4. This pause should be public and verifiable, and include all key actors. If such a pause cannot be enacted quickly, governments should step in and institute a moratorium.AI labs and independent experts should use this pause to jointly develop and implement a set of shared safety protocols for advanced AI design and development that are rigorously audited and overseen by independent outside experts. These protocols should ensure that systems adhering to them are safe beyond a reasonable doubt. This does not mean a pause on AI development in general, merely a stepping back from the dangerous race to ever-larger unpredictable black-box models with emergent capabilities.AI research and development should be refocused on making today’s powerful, state-of-the-art systems more accurate, safe, interpretable, transparent, robust, aligned, trustworthy, and loyal.In parallel, AI developers must work with policymakers to dramatically accelerate development of robust AI governance systems. These should at a minimum include: new and capable regulatory authorities dedicated to AI; oversight and tracking of highly capable AI systems and large pools of computational capability; provenance and watermarking systems to help distinguish real from synthetic and to track model leaks; a robust auditing and certification ecosystem; liability for AI-caused harm; robust public funding for technical AI safety research; and well-resourced institutions for coping with the dramatic economic and political disruptions (especially to democracy) that AI will cause.Humanity can enjoy a flourishing future with AI. Having succeeded in creating powerful AI systems, we can now enjoy an “AI summer” in which we reap the rewards, engineer these systems for the clear benefit of all, and give society a chance to adapt. Society has hit pause on other technologies with potentially catastrophic effects on society. We can do so here. Let’s enjoy a long AI summer, not rush unprepared into a fall.We have prepared some FAQs in response to questions and discussion in the media and elsewhere. You can find them here.In addition to this open letter, we have published a set of policy recommendations which can be found here.","link":"/posts/51448.html"},{"title":"QuickRead&#x2F;Write 快读快写","text":"快读 123456inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;} 快写12345void write(int x){ if(x&lt;0) putchar('-'),x=-x; if(x&gt;9) write(x/10); putchar(x%10+'0');} $cin$加速器(此时cin、cout和scanf、printf不可混用)12std::ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);","link":"/posts/17536.html"},{"title":"Segment Tree线段树","text":"题目描述如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 输入格式第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 输出格式输出包含若干行整数，即为所有操作 2 的结果。 样例 #1样例输入 #112345675 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 样例输出 #112311820 提示对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中任意元素的和在 $[-2^{63}, 2^{63})$ 内。 【样例解释】 算法分析 模板-区间和 模板-区间乘余mod 建树12345678void build(int pos,int l,int r){ tree[pos].l=l,tree[pos].r=r; if(l==r) {tree[pos].val=read()%mod;return;} int mid=(l+r)&gt;&gt;1; build(pos&lt;&lt;1,l,mid); build(pos&lt;&lt;1|1,mid+1,r); pushup(pos);} 上放123void pushup(int pos){ tree[pos].val=(tree[pos&lt;&lt;1].val+tree[pos&lt;&lt;1|1].val)%mod;} 下放和12345678910void pushdown(int pos){ if(tree[pos].lazy){ tree[pos&lt;&lt;1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1].r-tree[pos&lt;&lt;1].l+1); tree[pos&lt;&lt;1|1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1|1].r-tree[pos&lt;&lt;1|1].l+1); tree[pos&lt;&lt;1].lazy+=tree[pos].lazy; tree[pos&lt;&lt;1|1].lazy+=tree[pos].lazy; tree[pos].lazy=0; } return;} 和与积12345678910111213141516void pushdown(int pos){ if(tree[pos].lazy||tree[pos].mu!=1){ tree[pos&lt;&lt;1].mu=(tree[pos&lt;&lt;1].mu*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].mu=(tree[pos&lt;&lt;1|1].mu*tree[pos].mu)%mod; tree[pos&lt;&lt;1].lazy=(tree[pos&lt;&lt;1].lazy*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].lazy=(tree[pos&lt;&lt;1|1].lazy*tree[pos].mu)%mod; tree[pos&lt;&lt;1].val=(tree[pos&lt;&lt;1].val*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].val=(tree[pos&lt;&lt;1|1].val*tree[pos].mu)%mod; tree[pos].mu=1; tree[pos&lt;&lt;1].val=(tree[pos&lt;&lt;1].val+tree[pos].lazy*(tree[pos&lt;&lt;1].r-tree[pos&lt;&lt;1].l+1))%mod; tree[pos&lt;&lt;1|1].val=(tree[pos&lt;&lt;1|1].val+tree[pos].lazy*(tree[pos&lt;&lt;1|1].r-tree[pos&lt;&lt;1|1].l+1))%mod; tree[pos&lt;&lt;1].lazy=(tree[pos].lazy+tree[pos&lt;&lt;1].lazy)%mod; tree[pos&lt;&lt;1|1].lazy=(tree[pos].lazy+tree[pos&lt;&lt;1|1].lazy)%mod; tree[pos].lazy=0; }} 更新单点更新（加）12345678void updatepoint(int pos,int x,int data){ if(tree[pos].l==x&amp;&amp;tree[pos].r==x) tree[pos].val+=data; pushdown(pos); int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; if(mid&lt;x) updatepoint(pos&lt;&lt;1|1,x,data); else updatepoint(pos&lt;&lt;1,x,data); pushup(pos);} 区间更新和12345678910111213void updatarea_add(int pos,int x,int y,int data){ int l = tree[pos].l,r=tree[pos].r; int len=r-l+1,mid=(l+r)&gt;&gt;1; if(l&gt;=x&amp;&amp;r&lt;=y){ tree[pos].val+=len*data; tree[pos].lazy+=data; return; } pushdown(pos); if(mid&gt;=x) updatarea_add(pos&lt;&lt;1,x,y,data); if(mid&lt;y) updatarea_add(pos&lt;&lt;1|1,x,y,data); pushup(pos);} 积1234567891011121314void updatearea_acu(int pos,int x,int y,int data){ int l = tree[pos].l,r=tree[pos].r; int mid=(l+r)&gt;&gt;1; if(l&gt;=x&amp;&amp;r&lt;=y){ tree[pos].val=(tree[pos].val*data)%mod; tree[pos].lazy=(tree[pos].lazy*data)%mod; tree[pos].mu=(tree[pos].mu*data)%mod; return; } pushdown(pos); if(mid&gt;=x) updatearea_acu(pos&lt;&lt;1,x,y,data); if(mid&lt;y) updatearea_acu(pos&lt;&lt;1|1,x,y,data); pushup(pos);} 查询单点查询1234567int querypoint(int pos,int x){ if(tree[pos].l==x&amp;&amp;tree[pos].r==x) return tree[pos].val; pushdown(pos); int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; if(mid&lt;x) return querypoint(pos&lt;&lt;1|1,x); else return querypoint(pos&lt;&lt;1,x);} 区间和查询12345678910long long queryarea(int x,int y,int pos){ int l = tree[pos].l,r=tree[pos].r; if(x&lt;=l&amp;&amp;r&lt;=y) return tree[pos].val; pushdown(pos); int mid=(l+r)&gt;&gt;1; long long ans=0; if(mid&gt;=x) ans=(ans+queryarea(x,y,pos&lt;&lt;1))//%mod;&lt;--按需 if(mid&lt;y) ans=(ans+queryarea(x,y,pos&lt;&lt;1|1))//%mod;&lt;--按需 return ans;} $Model$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;int a[100005];struct node{ int l; int r; long long val; int lazy;}tree[6000005];inline long long read(){ long long x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}void pushup(int pos){ tree[pos].val=tree[pos&lt;&lt;1].val+tree[pos&lt;&lt;1|1].val;}void pushdown(int pos){ if(tree[pos].lazy){ tree[pos&lt;&lt;1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1].r-tree[pos&lt;&lt;1].l+1); tree[pos&lt;&lt;1|1].val+=tree[pos].lazy*(tree[pos&lt;&lt;1|1].r-tree[pos&lt;&lt;1|1].l+1); tree[pos&lt;&lt;1].lazy+=tree[pos].lazy; tree[pos&lt;&lt;1|1].lazy+=tree[pos].lazy; tree[pos].lazy=0; } return;}void updata(int pos,int l,int r,int data){ if(tree[pos].l&gt;=l&amp;&amp;tree[pos].r&lt;=r){ tree[pos].val+=((tree[pos].r-tree[pos].l+1)*data); tree[pos].lazy+=data; return; } pushdown(pos); int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; if(mid&gt;=l) updata(pos&lt;&lt;1,l,r,data); if(mid&lt;r) updata(pos&lt;&lt;1|1,l,r,data); pushup(pos);}long long query(int x,int y,int pos){ pushdown(pos); if(x&lt;=tree[pos].l&amp;&amp;y&gt;=tree[pos].r) return tree[pos].val; int mid=(tree[pos].l+tree[pos].r)&gt;&gt;1; long long ans=0; if(mid&gt;=x)ans+=query(x,y,pos&lt;&lt;1); if(mid&lt;y)ans+=query(x,y,pos&lt;&lt;1|1); return ans;}void build(int pos,int l,int r){ tree[pos].l=l,tree[pos].r=r; if(l==r){ tree[pos].val=read(); return; } int mid=(l+r)&gt;&gt;1; build(pos&lt;&lt;1,l,mid); build(pos&lt;&lt;1|1,mid+1,r); pushup(pos); return;}int main(){ int n,m,opt,x,y,k; cin&gt;&gt;n&gt;&gt;m; build(1,1,n); for(int i = 1;i&lt;=m;i++){ cin&gt;&gt;opt; if(opt==1){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; updata(1,x,y,k); }else{ cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(x,y,1)&lt;&lt;endl; } }} $Model$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;int mod;int a[100005];struct node{ int l; int r; long long val; long long lazy; long long mu=1;}tree[400005];inline long long read(){ long long x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}void pushup(int pos){ tree[pos].val=(tree[pos&lt;&lt;1].val+tree[pos&lt;&lt;1|1].val)%mod;}void pushdown(int pos){ if(tree[pos].lazy||tree[pos].mu!=1){ tree[pos&lt;&lt;1].mu=(tree[pos&lt;&lt;1].mu*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].mu=(tree[pos&lt;&lt;1|1].mu*tree[pos].mu)%mod; tree[pos&lt;&lt;1].lazy=(tree[pos&lt;&lt;1].lazy*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].lazy=(tree[pos&lt;&lt;1|1].lazy*tree[pos].mu)%mod; tree[pos&lt;&lt;1].val=(tree[pos&lt;&lt;1].val*tree[pos].mu)%mod; tree[pos&lt;&lt;1|1].val=(tree[pos&lt;&lt;1|1].val*tree[pos].mu)%mod; tree[pos].mu=1; tree[pos&lt;&lt;1].val=(tree[pos&lt;&lt;1].val+tree[pos].lazy*(tree[pos&lt;&lt;1].r-tree[pos&lt;&lt;1].l+1))%mod; tree[pos&lt;&lt;1|1].val=(tree[pos&lt;&lt;1|1].val+tree[pos].lazy*(tree[pos&lt;&lt;1|1].r-tree[pos&lt;&lt;1|1].l+1))%mod; tree[pos&lt;&lt;1].lazy=(tree[pos].lazy+tree[pos&lt;&lt;1].lazy)%mod; tree[pos&lt;&lt;1|1].lazy=(tree[pos].lazy+tree[pos&lt;&lt;1|1].lazy)%mod; tree[pos].lazy=0; }}void update_add(int pos,int x,int y,int data){ int l = tree[pos].l,r=tree[pos].r; int len=r-l+1,mid=(l+r)&gt;&gt;1; if(l&gt;=x&amp;&amp;r&lt;=y){ tree[pos].val+=len*data; tree[pos].lazy+=data; return; } pushdown(pos); if(mid&gt;=x) update_add(pos&lt;&lt;1,x,y,data); if(mid&lt;y) update_add(pos&lt;&lt;1|1,x,y,data); pushup(pos);}void update_acu(int pos,int x,int y,int data){ int l = tree[pos].l,r=tree[pos].r; int mid=(l+r)&gt;&gt;1; if(l&gt;=x&amp;&amp;r&lt;=y){ tree[pos].val=(tree[pos].val*data)%mod; tree[pos].lazy=(tree[pos].lazy*data)%mod; tree[pos].mu=(tree[pos].mu*data)%mod; return; } pushdown(pos); if(mid&gt;=x) update_acu(pos&lt;&lt;1,x,y,data); if(mid&lt;y) update_acu(pos&lt;&lt;1|1,x,y,data); pushup(pos);}long long query(int x,int y,int pos){ int l = tree[pos].l,r=tree[pos].r; if(x&lt;=l&amp;&amp;r&lt;=y) return tree[pos].val; pushdown(pos); int mid=(l+r)&gt;&gt;1; long long ans=0; if(mid&gt;=x) ans=(ans+query(x,y,pos&lt;&lt;1))%mod; if(mid&lt;y) ans=(ans+query(x,y,pos&lt;&lt;1|1))%mod; return ans;}void build(int pos,int l,int r){ tree[pos].l=l,tree[pos].r=r; if(l==r) {tree[pos].val=read()%mod;return;} int mid=(l+r)&gt;&gt;1; build(pos&lt;&lt;1,l,mid); build(pos&lt;&lt;1|1,mid+1,r); pushup(pos);}int main(){ int n,m,opt,x,y,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod; build(1,1,n); for(int i = 1;i&lt;=m;i++){ cin&gt;&gt;opt; if(opt==1){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; update_acu(1,x,y,k); }else if(opt==2){ cin&gt;&gt;x&gt;&gt;y&gt;&gt;k; update_add(1,x,y,k); }else{ cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(x,y,1)&lt;&lt;endl; } }} .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/posts/8302.html"},{"title":"T247910题解","text":"第一步：分析题目 清空 一段管道 的费用为从根节点出发道某段管道所用费用的积. 请输出清空 所有管道 所需费用; 可以看出，对于每一棵子树，其子节点的数据均与其根节点的数据有关，因此很容易想到把每一个节点的数据都进行记录，并进行前序遍历。故有： 1234struct node{ int F,L,R,C,len=1; //F父节点，L左孩子，R右孩子，C所用花费，len答案长度（默认为1） long long res[250]={1}; //res每一段结果数组(第一位必为1，否则0乘以任何数等于0)}a[110]; //节点个数 并通过如下代码输入： 123456cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;ro&gt;&gt;f1&gt;&gt;s1&gt;&gt;f2&gt;&gt;s2; //ro,f1,s1,f2,s2分别为当前节点，左孩子，到左孩子所用值，右孩子，到右孩子所用值 if(f1) a[ro].L=f1,a[f1].F=ro,a[f1].C=s1; if(f2) a[ro].R=f2,a[f2].F=ro,a[f2].C=s2; } 为进行前序遍历,先找到根： 1234567queue &lt;int&gt; Q;for(int i = 1;i&lt;=n;i++){ if(a[i].F==0){ //若此节点无父亲，则为根节点 root=i; break; }} 第二步：分析数据范围 对于 100% 的数据，保证1&lt;=n&lt;=110,所有输入数据不大于LLONG_MAX 对于30%的数据，保证答案在long long 以内 对于70%的数据，无限制 显而易见，本题应使用高精； 由于输入数据不大于 LLONG_MAX，故本题为高精乘低精，高精加高精； 为进行高精乘低精，故有： 1234567891011121314void cheng(int x,int who,int child){ //x乘数，who父亲，child孩子 int p=0; //进位 a[child].len=a[who].len; for(int i=0;i&lt;a[child].len;i++){ a[child].res[i]=a[who].res[i]*x+p; //对每一位进行处理 p=a[child].res[i]/10; //更新进位 a[child].res[i]%=10; //更新当前位 } while(p){ //处理总位数 a[child].res[a[child].len]=p; p/=10; a[child].res[a[child].len++]%=10; //更新位数len }} 为进行高精加高精，故有： 123456789101112long long RES[1000]; //最终答案int LEN=1; //最终答案位数void add(int who){ //当前节点 int l=max(LEN,a[who].len),p=0; //l取最大位数进行加法运算，p进位 LEN=l; for(int i=0;i&lt;l;i++){ RES[i]=RES[i]+a[who].res[i]+p; p=RES[i]/10; RES[i]%=10; } if(p) RES[LEN++]=p; //更新最终位数} 第三步：树的遍历本题可以用递归，也可以用队列，这里给出队列的做法： 123456789101112131415Q.push(root); //把一开始找到的根加入队列while(!Q.empty()){ int now=Q.front(); Q.pop(); if(a[now].L){ //如果有左儿子 Q.push(a[now].L); cheng(a[a[now].L].C,now,a[now].L); //高精乘法 add(a[now].L); //高精加 } if(a[now].R){ //如果有右儿子 Q.push(a[now].R); cheng(a[a[now].R].C,now,a[now].R); //高精乘法 add(a[now].R); ////高精加 }} 最后输出答案： 123for(int i = LEN-1;i&gt;=0;i--){ cout&lt;&lt;RES[i];} $ AC$ $ Code $1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;struct node{ int F,L,R,C,len=1; long long res[250]={1};}a[110];queue &lt;int&gt; Q;long long RES[1000];int len=1;void cheng(int x,int who,int child){ int p=0; a[child].len=a[who].len; for(int i=0;i&lt;a[child].len;i++){ a[child].res[i]=a[who].res[i]*x+p; p=a[child].res[i]/10; a[child].res[i]%=10; } while(p){ a[child].res[a[child].len]=p; p/=10; a[child].res[a[child].len++]%=10; }}void add(int who){ int l=max(len,a[who].len),p=0; len=l; for(int i=0;i&lt;l;i++){ RES[i]=RES[i]+a[who].res[i]+p; p=RES[i]/10; RES[i]%=10; } if(p) RES[len++]=p;}int main(){ int n,ro,f1,s1,f2,s2,root; cin&gt;&gt;n; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;ro&gt;&gt;f1&gt;&gt;s1&gt;&gt;f2&gt;&gt;s2; if(f1) a[ro].L=f1,a[f1].F=ro,a[f1].C=s1; if(f2) a[ro].R=f2,a[f2].F=ro,a[f2].C=s2; } for(int i = 1;i&lt;=n;i++){ if(a[i].F==0){ root=i; break; } } Q.push(root); while(!Q.empty()){ int now=Q.front(); Q.pop(); if(a[now].L){ Q.push(a[now].L); cheng(a[a[now].L].C,now,a[now].L); add(a[now].L); } if(a[now].R){ Q.push(a[now].R); cheng(a[a[now].R].C,now,a[now].R); add(a[now].R); } } for(int i = len-1;i&gt;=0;i--){ cout&lt;&lt;RES[i]; }}","link":"/posts/61850.html"},{"title":"T266160 [NMOI-J 2022] 神の繁星 题解","text":"题目背景繁星之神有$n$颗星星。 每一颗星星都有它的年龄，当每颗星星到达$c$岁后，就因为坍缩而无论如何也无法发出空间之神徵御铉可以看见的光了(即空间之神徵御铉看不见这颗星星)。 由于这些星星非常懒惰,自己不愿意发光。于是繁星之神会选出一颗 $x$ 岁的星星来当繁星的领袖，来引导其他星星一起发光。当它发光时，其他所有满足条件的星星会在他的引领下和它一起发光。 但是，这颗星星的能力有限，仅能带动跟它年龄差不超过$y$岁的星星发光。 现在数学极好的徵御铉想知道，这颗星星能带动几颗星星发光(数星星的时间忽略不计)。 输入格式第一行输入四个数字 $n,x,y,c$。第二行输入 $n$ 个数字 $ai$,分别代表每颗星星的年龄。 输出格式输出徵御铉数出的星星个数（即他可以看见多少星星）。 样例 #1样例输入 #1125 7 3 106 8 3 10 11 样例输出 #112 提示对于 $100%$ 的数据，保证 $1≤n≤10^6,1≤x,y≤10^9,c≤10^9,x&gt;y,1\\le\\forall ai ≤10^9$。 题意分析本题来源：甚至你们有些人都写过：牛客儿童节比赛-孩子王 本题题意： 条件有三 星星与领袖的年龄差$\\leq y$ 星星的年龄$&lt; c$; $\\color{Red}{领袖的年龄&lt; c}$ 上代码123456789101112131415161718#include&lt;iostream&gt;using namespace std;int abs(int value){return value &lt; 0?-value:value;}int main(){ int n,x,y,c,age,ans=0; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;c; if(x&gt;=c){ cout&lt;&lt;0; return 0; } for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;age; if(abs(age-x)&lt;=y&amp;&amp;age&lt;c){ ans++; } } cout&lt;&lt;ans;} .","link":"/posts/47304.html"},{"title":"T266276 [NMOI-J 2022] 神の贪婪 题解","text":"题目描述本题来源：力扣-875. 爱吃香蕉的珂珂这个神秘空间不算很大，里面有$n$份作业,第$i$份作业中有$a_i$张试卷。 虽然现在嫉妒之神在嫉妒傲慢之神没有时间把守这个神秘空间，但是$h$小时之后傲慢之神就会去吃饭，因为傲慢之神的吃饭时间太长，嫉妒之神不愿继续浪费时间对牛弹琴了，所以就会在$h$小时后回到神秘空间继续把守。 因为该空间的掌控者是嫉妒之神，若嫉妒之神回来之前徵御铉还没有离开，那么到时候想离开就得耗费空间之神的大量神力,而这里的作业也因为被施加了神力而无法带走，于是徵御铉只能在这个神秘空间里卷。 徵御铉特别享受写作业的过程，所以就算他可以以接近光速的速度写完该份作业中全部的试卷，但是他希望自己写作业的速度尽可能的慢。 每写完一份作业，如果时间不满一小时，那么他会用这个小时剩下的时间来回味数学题的美好~~~~ 虽然空间之神已经算到了以什么速度$m$（单位:张试卷/小时）写作业既能使自己不消耗神力，也能使这个$m$最小来享受写作业的感觉并且写完全部作业，但是按照风俗，他需要象征性的”向你求助”。 简化题意有$n$份作业,求一个最小的速度$m$，使得徵御铉的写完全部作业的时间小于等于$h$小时,写试卷的每份作业的时间若不满小时，则按照小时计算，若无论$m$取何值都无法满足条件,输出”$-1$”。 输入格式第一行两个正整数 $n,h$ ,意义见上文。 第二行$n$个非负整数$a_i$，表示第$i$份作业中有$a_i$张试卷 输出格式一个整数$m$，若无法满足条件，输出$-1$ 样例 #1样例输入 #1124 83 6 7 11 样例输出 #114 样例 #2样例输入 #2125 530 11 23 4 20 样例输出 #2130 样例 #3样例输入 #3125 630 11 23 4 20 样例输出 #3123 提示数据范围：$1 \\leq n \\leq 10^4,1 \\leq h \\leq 10^9,1 \\leq a_i \\leq 10^9$ 分析题意简单的二分满足两个条件： 速度最慢 在$h$个小时内做完 细节处理对于作业量小于$m$的情况，无需特殊处理，向上取整即可 上代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int a[10004],n,h,l=1,r=0,mid,t=0;signed main(){ cin&gt;&gt;n&gt;&gt;h; if(n&gt;h){ cout&lt;&lt;-1; return 0; } for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;a[i]; r=r&gt;a[i]? r:a[i]; } while(l&lt;r){ t=0; mid=(l+r)&gt;&gt;1; for(int i = 1;i&lt;=n;i++) t+=ceil(1.0*a[i]/mid); if(t&lt;=h) r=mid; else l=mid+1; } cout&lt;&lt;l; return 0;}","link":"/posts/6365.html"},{"title":"Tarjan缩点","text":"用这篇博客记录一下学习Tarjan缩点的风风雨雨 三种缩点的时间复杂度均为$\\Large{O(n+m)}$ 定义：$\\mathrm{dfn[x]}$时间戳：表示遍历到$x$之前遍历过多少个点$\\mathrm{low[x]}$追溯值：表示从$x$出发在不经过父子边的情况下能到达的最早的祖先的$\\mathrm{dfn[x]}$值。 有向图强联通分量缩点(SCC)SCC的作用是将一个有向有环图的环缩成一个点，使其形成一个DAG，方便后续的运算。 伪代码1234567891011121314Tarjan(当前节点): //入 初次进入当前节点 给当前节点赋新的 时间戳 和 追溯值 将当前节点入栈 //回 遍历 当前节点的所有 孩子: 如果 节点无时间戳(未被访问)： Tarjan(孩子) 用 孩子的追溯值 更新 当前节点的追溯值 如果 当前节点在栈中: 用 孩子的时间戳 更新 当前节点的追溯值 //离 如果 当前节点的时间戳 等于 追溯值：(说明这里已经形成了一个强联通分量) 弹栈(此时弹出来的都是强联通分量中的点) 直到 把当前节点弹出来 Model Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,m;vector&lt;int&gt;po[200004];deque&lt;int&gt;stk;int dfn[200004],low[200004],tot=0,cnt=0;bool instack[200004];void Tarjan(int pos){ //入 dfn[pos]=low[pos]=++tot; stk.push_front(pos); instack[pos]=true; //回 for(int to:po[pos]){ if(!dfn[to]){ Tarjan(to); low[pos]=min(low[pos],low[to]); }else if(instack[to]){ low[pos]=min(low[pos],dfn[to]); } } //离 if(dfn[pos]==low[pos]){ int y;++cnt; do{ y=stk.front();stk.pop_front(); instack[y]=false; }while(y!=pos); }}int main(){ n=read(),m=read(); for(int i = 1,x,y;i&lt;=m;i++){ x=read(),y=read(); po[x].push_back(y); } for(int i = 1;i&lt;=n;i++){//可能图形不是联通的 if(dfn[i])continue; Tarjan(i); } cout&lt;&lt;cnt;} 无向图无向图有两个缩点方式：点双 和 边双； 解释一下两者的区别： 点双 边双 定义 在一张联通的无向图中，对于两个点$u$和$v$,如果无论删去哪个点($u$和$v$本身除外)，都不能使它们不联通，我们就说$u$和$v$点双联通 在一张联通的无向图中，对于两个点$u$和$v$,如果无论删去哪条边，都不能使它们不联通，我们就说$u$和$v$边双联通 性质 图中任意一个割点都在至少两个点双中任意一个不是割点的点都只存在于一个点双中 割边不属于任意边双，而其它非割边的边都属于且仅属于一个边双。对于一个边双中的任意两个点，它们之间都有至少两条边不重复的路径。 点双联通分量缩点(v-DCC)伪代码12345678910111213141516171819202122232425262728int 根（当前进入时的根）Tarjan(当前节点): 初次进入当前节点 给当前节点赋新的 时间戳 和 追溯值 将当前节点入栈 如果 当前节点 等于 根 且 当前节点没有任何与它相连的边:（特判孤立点，因为如果不判无法进入下面的遍历，从而当前节点不会被作为点双联通分量） 新建一个点双联通分量 并将当前节点 加入 退出 int 孩子数量 遍历 当前节点的所有 孩子: 如果 节点无时间戳(未被访问)： Tarjan(孩子) 用 孩子的追溯值 更新 当前节点的追溯值 如果 孩子的追溯值 比 当前节点的时间戳 要大:(假如儿子在不经过父子边的情况下不能到达当前节点的祖先，那么当前节点就是割点) 孩子数量++（这是我的孩子） 如果 当前节点不是根 或者 孩子数量大于1: 当前节点就是割点 //Q: 解释一下？ //A: 如果当前节点是 根，那么显然没有孩子能到他的祖先节点 //但是 如果是根并且孩子数量大于1，那么这个点依然能成为割点 //例子可以看下方的图 新建一个点双 弹栈 直到 把孩子弹出 把当前节点加入点双 //Q: 为什么不把当前节点弹掉？ //A: 当前节点一定属于多个边双，若弹掉当前节点会导致其无法被加入其他点双 否则: 用 孩子的时间戳 更新 当前节点的 追溯值（假如走到了一个dfn更小的，那么更新low） 这个点不是割点，但没有孩子能走到他的祖先节点，若不特判将被判成割点 这个点是割点，因为它有两个孩子 Model Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}vector&lt;int&gt;ro[2000005];vector&lt;int&gt;dcc[2000005];stack&lt;int&gt;stk;int dfn[2000005],low[2000005],cut[2000005],id[2000005],tot=0,cnt=0,root;bool instack[2000005];inline void Tarjan(int pos){ dfn[pos]=low[pos]=++tot; stk.push(pos); if(pos==root&amp;&amp;!ro[pos].size()){ dcc[++cnt].push_back(pos); return; } int child = 0; for(int to:ro[pos]){ if(!dfn[to]){ Tarjan(to); low[pos]=min(low[pos],low[to]); if(low[to]&gt;=dfn[pos]){ child++; if(pos!=root||child&gt;1)cut[pos]=true; cnt++; while(true){ int z = stk.top();stk.pop(); dcc[cnt].push_back(z); if(z==to)break; } dcc[cnt].push_back(pos); } }else low[pos]=min(low[pos],dfn[to]); }}int main(){ int n=read(),m=read(); for(int i = 1,u,v;i&lt;=m;i++){ u=read(),v=read(); if(u==v)continue; //这里记得判断u==v的情况，这种情况下不要加边，否则会出现自环 ro[u].emplace_back(v); ro[v].emplace_back(u); } for (root=1;root&lt;=n;root++) if (!dfn[root]) Tarjan(root); cout&lt;&lt;cnt&lt;&lt;endl; for(int i = 1;i&lt;=cnt;i++){ cout&lt;&lt;dcc[i].size(); for(int whi:dcc[i]){ cout&lt;&lt;&quot; &quot;&lt;&lt;whi; } cout&lt;&lt;endl; } return 0;} 边双联通分量缩点(e-DCC)1234567891011121314Tarjan(当前节点, 入边): 初次进入当前节点 给当前节点赋新的 时间戳 和 追溯值 将当前节点入栈 遍历 当前节点的所有边: 如果 节点无时间戳(未被访问)： Tarjan(边所指的孩子，当前边) 用孩子的追溯值更新当前节点的追溯值 如果 孩子的追溯值 大于 当前节点时间戳:(回不到当前节点了) 当前边及其反边就是割边 否则如果 当前边不是 入边的反边:(即 不回到当前节点的父亲)： 用孩子节点的时间戳更新当前节点的追溯值（不通过父边可能能走到更早的祖先） 如果 当前节点的时间戳 等于 当前节点的追溯值:(只能到自己) 新建边双 弹栈直到把自己弹掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,m,tot,cnt,idx=1;/* 这里注意边的编号idx要从1开始因为对于奇数x, x^1=x+1对于偶数x, x^1=x-1方便找反边 */struct EDGE{/* 由于涉及到边的编号问题，使用前向星比较方便 */ int v; int ne;}edge[4000005];int h[500005],dfn[4000005],low[4000005],bri[4000005];vector&lt;int&gt;dcc[500005];stack&lt;int&gt;stk;void add(int a,int b){ edge[++idx].v = b; edge[idx].ne = h[a]; h[a]=idx;}void Tarjan(int pos,int in_edge){ dfn[pos] = low[pos] = ++tot; stk.push(pos); for(int i = h[pos];i;i = edge[i].ne){ int to = edge[i].v; if(!dfn[to]){ Tarjan(to,i); low[pos] = min(low[pos],low[to]); if(low[to]&gt;dfn[pos]) bri[i] = bri[i^1] = true; }else if(i != (in_edge^1))low[pos] = min(low[pos],dfn[to]); } if(dfn[pos]==low[pos]){ ++cnt; while(true){ int y = stk.top();stk.pop(); dcc[cnt].push_back(y); if(y==pos)break; } }}int main(){ n=read(),m=read(); for(int i = 1,u,v;i&lt;=m;i++){ u=read(),v=read(); add(u,v);add(v,u); } for(int i = 1;i&lt;=n;i++) Tarjan(i,0); cout&lt;&lt;cnt&lt;&lt;endl; for(int i = 1;i&lt;=cnt;i++){ cout&lt;&lt;dcc[i].size(); for(int node:dcc[i]){ cout&lt;&lt;&quot; &quot;&lt;&lt;node; } cout&lt;&lt;endl; } return 0;}","link":"/posts/9856.html"},{"title":"U218941 题解","text":"一、分析题目 有些饭非常多，可以看作可以一直吃，有些饭很少，只能吃一次。 请你帮助他求出他最多可以吃多少饭，并输出此时所需时间。 从题目我们可以看出，本题为混合背包； 贪心最多90pts； 那么，对于每一顿饭 若能吃无数次，则有： 123for(int w = a[i].t;w&lt;=t;w++){ //t为时间 dp[w]=max(dp[w],dp[w-a[i].t]+a[i].c); //完全背包} 若只能吃一次，则有： 123for(int w = t;w&gt;=a[i].t;w--){ //t为时间 dp[w]=max(dp[w],dp[w-a[i].t]+a[i].c); //01背包} 二、数据范围 保证0&lt;=ti ; 无穷大符号是”+&amp; 所以 当ti==0时，输出+&amp;； 1234if(a[i].t==0&amp;&amp;a[i].c){ cout&lt;&lt;&quot;+&amp;&quot;&lt;&lt;endl; return 0;} 三、$AC$ $Code$123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;long long dp[1000010];struct supur{ int t,c,flag;}a[1000001];int main(){ int n,t; cin&gt;&gt;n&gt;&gt;t; for(int i = 1;i&lt;=n;i++){ cin&gt;&gt;a[i].t&gt;&gt;a[i].c&gt;&gt;a[i].flag; if(a[i].t==0&amp;&amp;a[i].c){cout&lt;&lt;&quot;+&amp;&quot;&lt;&lt;endl;return 0;} } for(int i = 1;i&lt;=n;i++){ if(a[i].flag==0){ for(int w = a[i].t;w&lt;=t;w++){ dp[w]=max(dp[w],dp[w-a[i].t]+a[i].c); } }else{ for(int w = t;w&gt;=a[i].t;w--){ dp[w]=max(dp[w],dp[w-a[i].t]+a[i].c); } } } cout&lt;&lt;dp[t]; return 0;}","link":"/posts/12884.html"},{"title":"Ubuntu关闭图形界面","text":"实际上本方法不仅仅适用于Ubuntu22.04版本，应该也适用于20.04等其他版本。 关闭图形界面，启用tty终端登录的方法如下： 1sudo systemctl set-default multi-user.target 重新启用图形界面的方法： 1sudo systemctl set-default graphical.target 最后重启 1reboot","link":"/posts/19813.html"},{"title":"Ubuntu打包zip","text":"在Linux系统中，压缩文件夹是经常使用到的操作之一。zip是一种常见的压缩格式，Ubuntu自带的zip命令可以方便地完成文件夹的压缩。本文将介绍Ubuntu中使用zip命令压缩文件夹的详细步骤。 一、安装zip命令如果您的Ubuntu系统没有安装zip命令，可以使用以下命令进行安装： 12sudo apt-get updatesudo apt-get install zip 输入密码并等待安装完成。 二、压缩单个文件夹在命令行中，使用zip命令压缩单个文件夹非常简单。以下是基本的命令格式： zip -r 压缩包名.zip 要压缩的文件夹路径其中，-r参数表示递归压缩子目录。 例如，如果要将目录/home/user/documents压缩为documents.zip，可以使用以下命令： 1zip -r documents.zip /home/user/documents 执行上述命令后，压缩包documents.zip将会生成在当前命令行所在目录下。 三、压缩多个文件夹如果要同时压缩多个文件夹，可以在命令行中依次指定要压缩的文件夹路径，并用空格进行分隔。例如，要同时压缩/home/user/documents和/home/user/pictures两个文件夹，可以使用以下命令： 1zip -r archive.zip /home/user/documents /home/user/pictures 执行上述命令后，压缩包archive.zip将会生成在当前命令行所在目录下。 四、使用过滤器有时候，在压缩文件夹时，您可能只需要压缩其中的部分文件或目录。zip命令提供了一些过滤器选项，可以满足您的需求。 以下是几个常用的过滤器： -x：排除指定的文件或目录。-i：仅包括指定的文件或目录。例如，要压缩目录/home/user/documents，但排除其中的/home/user/documents/cache目录，可以使用以下命令： 1zip -r documents.zip /home/user/documents -x /home/user/documents/cache 执行上述命令后，压缩包documents.zip将会生成在当前命令行所在目录下，其中不包含/home/user/documents/cache目录。","link":"/posts/55592.html"},{"title":"VSCode安装包下载加速","text":"比如加载链接： 1https://az764295.vo.msecnd.net/stable/6445d93c81ebe42c4cbd7a60712e0b17d9463e97/VSCodeSetup-x64-1.81.0.exe 将前缀az764295.vo.msecnd.net替换成vscode.cdn.azure.cn","link":"/posts/42906.html"},{"title":"WOL(Wake On Lan)实现","text":"花了几个月钻研，终于成功啦👏👏👏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;WinSock2.h&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;const int maxn=1005;struct node{ int id; string name; unsigned char mac[6]; int port;}mach[maxn];int choose,tot=0;hostent *host;string s;void init(){ ifstream ifs; ifs.open(&quot;save.bak0&quot;, ios::in); int temp; ifs &gt;&gt;s; ifs &gt;&gt;tot; for(int i = 0;i&lt;tot;i++){ ifs &gt;&gt;mach[i].name; ifs &gt;&gt;mach[i].id; for(int j = 0;j&lt;=5;j++){ ifs &gt;&gt;temp; mach[i].mac[j]=temp; } ifs &gt;&gt;mach[i].port; } ifs.close();}void save(){ freopen(&quot;save.bak0&quot;,&quot;w&quot;,stdout); cout&lt;&lt;s&lt;&lt;endl&lt;&lt;endl; cout&lt;&lt;tot&lt;&lt;endl&lt;&lt;endl; for(int i = 0;i&lt;tot;i++){ cout&lt;&lt;mach[i].name&lt;&lt;endl; cout&lt;&lt;mach[i].id&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[0]&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[1]&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[2]&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[3]&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[4]&lt;&lt;endl; cout&lt;&lt;(int)mach[i].mac[5]&lt;&lt;endl; cout&lt;&lt;mach[i].port&lt;&lt;endl&lt;&lt;endl; } fclose(stdin);}bool wol(int which){ unsigned char packet[102]; struct sockaddr_in addr; int sockfd, i,j, on = 1; for(i=0;i&lt;6;i++){ packet[i] = 0xFF; } for(i=1;i&lt;17;i++){ for(j=0;j&lt;6;j++){ packet[i*6+j] = mach[which].mac[j]; } } sockfd = socket(AF_INET, SOCK_DGRAM, 0); setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,(char*)&amp;on, sizeof(on)); if(sockfd &lt; 0){ return false; } memset((void*)&amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(mach[which].port); addr.sin_addr.s_addr = inet_addr(inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[0])); sendto(sockfd,(char*)&amp;packet, sizeof(packet), 0, (struct sockaddr *)&amp;addr, sizeof(addr)); return true;}int main(){ init(); printf(&quot;Welcome back, Better_OIer!\\n\\n&quot;); printf(&quot;Checking Server IP...&quot;); WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); host = gethostbyname(s.c_str()); while(!host) { printf(&quot;\\nGet IP address error!\\n&quot;); printf(&quot;Change server name?(y/n):(Default=N) &quot;); char flag; cin&gt;&gt;flag; if(flag!='y'&amp;&amp;flag!='Y')goto en; printf(&quot;Enter your new server name: &quot;); cin&gt;&gt;s; host = gethostbyname(s.c_str()); } printf(&quot;Successful!\\n&quot;); printf(&quot;Address type: %s\\n&quot;, (host-&gt;h_addrtype == AF_INET) ? &quot;AF_INET&quot; : &quot;AF_INET6&quot;); printf(&quot;IP address: %s\\n\\n&quot;, inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[0])); printf(&quot;Choose machines you want to wake up:\\n&quot;); for(int i = 0;i&lt;tot;i++){ printf(&quot;%3d %s\\n&quot;,mach[i].id,mach[i].name.c_str()); } printf(&quot;Enter 1 to %d:(0 to wake up all the %d machine): &quot;,tot,tot); cin&gt;&gt;choose; puts(&quot;&quot;); if(choose==0){ printf(&quot;Waking up all the machine...\\n&quot;); for(int i = 0;i&lt;tot;i++){ if(wol(i)){ printf(&quot;Successfully wake up %s(id=%d)!!!\\n&quot;,mach[i].name.c_str(),mach[i].id); }else{ printf(&quot;Error when waking up %s(id=%d)!!!\\n&quot;,mach[i].name.c_str(),mach[i].id); } } } else if(choose == 'q'||choose=='Q')goto en; else{ if(wol(--choose)){ printf(&quot;Successfully wake up %s(id=%d)!!!\\n&quot;,mach[choose].name.c_str(),mach[choose].id); }else{ printf(&quot;Error when waking up %s(id=%d)!!!\\n&quot;,mach[choose].name.c_str(),mach[choose].id); } } en: printf(&quot;\\nQuit in 3s...&quot;); save(); Sleep(3000); return 0;} 当前配置的save.bak0: 123456789101112131415161718192021222324BetterOIer.tpddns.cn2Server1802297323246810NEW_DESKTOP21804615323510599","link":"/posts/8163.html"},{"title":"Westlake University Registration Essay","text":"My Origin VersionDear Westlake University Admissions Committee, My name is Zheng Yuxuan. In this essay I will paint the picture I envision of living and studying at Westlake University. For study, as I have been curious and passionate about information technology since I was a child, I desire to pursue further education in this field at Westlake University. I would like to explore the intersection of artificial intelligence and computer hardware. I’m also eager to explore the combination of computers and life sciences (e.g. Brain-Machine Interface). Though this is a challenging field, I’ll work against all the odds to make it worth all the while. At the same time, I’m willing to go abroad for exchanges to expand my international perspective as well as build bonds with like-minded people all over the world. In terms of college life, I intend to adjust the abnormal work routine in senior high school, find a balance between work and rest to fully experience the beauty of life. I’ll regain my interests, such as playing the piano, cooking and designing and flying model aircraft. I’ll engage in the International Collegiate Programming Contest to win medals as well as foster positive relationships with my teammates. In my spare time, I’ll immerse myself in reading to further my personal growth. I’ll participate in some voluntary work to improve my social skills and leadership abilities. Anticipating a colorful and fruitful journal in Westlake University! XW’s VersionMy name is Zheng Yuxuan, and through this essay, I will depict the life and studies I envision at Westlake University. In terms of my studies, I have been curious and passionate about information technology since I was a child. Hence, I am eager to further my education in this field at Westlake University. Specifically, I am keen to delve into the convergence of artificial intelligence and computer hardware. And I am equally excited about exploring the combination of computers and life sciences (e.g. Brain-Machine Interface). Despite the challenges, I am determined to surmount all obstacles to make it a worthwhile endeavor. Additionally, I am open to international exchanges to broaden my global perspective and allow me to bond with like-minded individuals from around the world. In terms of campus life, I plan to transition from the demanding schedule of high school and strike a healthy balance between work and leisure to fully savor the richness of life. I aim to reignite my passions, such as playing the piano, cooking, and designing and flying model aircraft. I’ll participate in the International Collegiate Programming Contest to win medals as well as cultivate positive relationships with my teammates. During my free time, I will immerse myself in reading to enhance my personal growth. I will also engage in voluntary work to improve my social skills and leadership capabilities. I look forward to embarking on a vibrant and rewarding journey at Westlake University. Sincerely,Zheng Yuxuan My Final VersionMy name is Zheng Yuxuan, and through this essay, I will depict the life and studies I envision at Westlake University. For study, as I have been curious and passionate about information technology since I was a child, I desire to pursue further education in this field at Westlake University. Specifically, I am keen to delve into the convergence of AI and computer hardware. And I am equally excited about exploring the combination of computers and life sciences (e.g. Brain-Machine Interface). Additionally, I am open to international exchanges to broaden my global perspective and allow me to bond with like-minded individuals from around the world. In terms of campus life, I intend to transition from the demanding schedule of high school and strike a healthy balance between work and leisure to fully savor the richness of life. I’ll regain my interests, such as playing the piano, cooking and designing and flying model aircraft. I’ll engage in the International Collegiate Programming Contest to win medals as well as cultivate a united team spirit. During my free time, I will immerse myself in reading to enhance my personal growth. I’ll also participate in some voluntary work to improve my social skills and leadership capabilities. I look forward to embarking on a vibrant and rewarding journey at Westlake University. 碎碎念Blimey! 为什么要限字数！！！","link":"/posts/24635.html"},{"title":"Why Kiki&#39;s Delivery Service Is The Perfect Coming of Age Story","text":"Studio Ghibli is well known for producing timeless classics that have engaging protagonists and enchanting storylines. Spirited Away, Castle in the Sky and My Neighbor Totoro are all examples of movies that have captured hearts in both the East and West. And now that the Ghibli catalog is hitting streaming services for the first time, old and new fans alike are diving back into these worlds of cozy fantasy. Kiki’s Delivery Service, released in 1989, is no different. Based on the lesser-known book of the same name by Eiko Kadono, the movie focuses on a 13-year old witch named Kiki who, per ancient traditions, must leave home for a year to make a living in a different town. Though Kiki is a witch, this isn’t your typical magical girl anime where she can use her magic to turn her problems into lollipops and rainbows. Kiki has to fight through various personal and external obstacles to make a life for herself. Like many of Miyazaki’s female protagonists, Kiki is a multifaceted character with an endearing tenacity and she makes it easy for us to understand the rollercoaster of emotions she rides as she grows and matures through the movie. With Miyazaki’s masterful direction and Studio Ghibli’s impeccable execution, Kiki’s Delivery Service is a beautiful coming of age story that captures the trials and tribulations of growing up with its charming characters, an intriguing premise and realistic conflicts. For those in need of some nourishing entertainment during these uncertain times, there’s no better film to watch right now. The movie’s core concept is about gaining financial independence from one’s parents and that’s a key part of growing up. Kiki leaves home at 13, an age people consider to be the threshold into the teen years, and sets out to make her fortune with inspiring optimism. Kiki knows full well that she has to find a job and though she is determined as anybody to start her search, like any aspiring graduate, she finds herself smacked across the face with reality: The beautiful oceanside town is filled with indifferent people, a police officer tries to detain her for flying on her broom and she needs an ID to stay at a hotel. As a gorgeous sunset paints the sky, Kiki is still very much alone and we start worrying that she hasn’t found a place to stay. Anybody having trouble with finding a job recognizes how discouraged and stressed Kiki must be in a world indifferent to her struggles. Thankfully this is a G-rated movie so Kiki quickly finds a job at a bakery with a friendly couple (Osono and Fukuo) but her troubles aren’t over. After a cute shopping scene, she finds out how quickly her money runs out, which forces her to get back to setting up her business. But in one day she has a job, a rent-free room and networking connections without needing LinkedIn or Indeed. Even after Kiki has “made it” with a freelance gig with decent perks from Osono, she has to face another hurdle – fitting in with her peers. This is exacerbated by her status as the only witch in town and having to wear a black dress she labels boring. Whenever Kiki has a run-in with her friend Tombo’s gang, and other girls her age, we can see her put her head down and plow forward with closed body language. Kiki is perfectly sociable with people older than her but it seems that she has some social anxiety when it comes to other girls her age. RELATED: Why Kiki’s Delivery Service Is Still One Of Miyazaki’s Best FilmsPart of growing up, particularly but not limited to the adolescent phase, includes wanting to fit in with others as a way to understand one’s identity. Kiki has friends back home but in this new city and a new school filled with older kids, she has to start from scratch. Additionally, children make friends with unconscious ease, bonding over things as inane as eating mud pies, yet when people grow up, these activities are frowned upon and they have to find new ways to socialize with their peers. Kiki lacks any shared experiences with these town girls as a witch and it’s sad to see this bubbly character feel so awkward around Tombo’s friends. It’s not hard to understand why she feels this way as one of Tombo’s friends spoke to Kiki quite rudely after a rough delivery in the rain. Kiki’s hurt reaction and later brooding is a direct parallel to adolescents who have become self-conscious and are extremely sensitive to their peers’ opinions. Self-doubt is the natural evolution of self-consciousness and Kiki (and young adults in general) have this in spades. After lashing out at Tombo, we see her retreat into a sullen shell and she admits to Jiji (her familiar) that she thinks there’s something wrong with her. It’s possible the other girls made her feel inferior and Kiki begins to question herself and tries to understand her maelstrom of emotions. Right after, and in quick succession, Kiki can no longer talk to Jiji and she loses her ability to fly. Losing these powers throws her into a deep depression. She admits to Osono that she feels like she’s lost everything. Metaphorically speaking, Kiki’s loss speaks to the deeper insecurities she harbors about her identity as a witch and how her self-doubt stops her from finding her true potential. Enter Ursula, a quirky artist who bears no resemblance to a certain purple sea witch, who brings Kiki on a much-needed vacation. During this trip, Ursula tells Kiki that she may have artist’s block and suggests that she take a mental health break. Ursula’s advice is very relevant as artist’s block is partially caused by self-doubt and a mental break allows Kiki to realize that there’s more to herself than just being a witch. But after a deep talk with Ursula about trying to understand one’s passions, Kiki begins to find her inner strength as the older woman urges her to think about why she loves flying. Ursula’s message is an important one to anyone else struggling with this kind of anxiety. She advises Kiki to counteract the negativity by rediscovering her purpose in life and understanding her passions. Like any coming of age story, Kiki’s Delivery Service culminates in the loss of innocence as a part of growing up. Kiki loses her mother’s broom, her flying for a while and, in the Japanese dub, is never able to talk to Jiji again. The symbolism is clear. Kiki cannot unconditionally rely on her parents anymore; she has to consciously learn how to fly and cannot talk to Jiji anymore because she has lost the magic of childhood. RELATED:Hayao Miyazaki Has No Idea What A ‘Streaming Service’ IsWhile these all may seem like negatives, they truly aren’t because Kiki has gained much more on her journey of self-realization. Kiki has gained independence through taming her own broom and she has become a well-rounded person who is more conscious of her gifts. By losing her flying and fighting to get it back, Kiki realizes how much she loves to fly and she understands her skill on a deeper level. Not being able to talk to Jiji (a possible allegory for an imaginary friend) forced her to come out of her shell and to create a new network of friends and surrogate family. As we can see from Kiki’s struggles, growing up is a painful process but with adulthood comes wisdom, authentic connections and, most importantly, independence. This is the beauty of Kiki’s Delivery Service: a bittersweet tale that does a remarkable job of showing a child’s inner life while she transitions to adolescence. Hayao Miyazaki once again proves his mastery with spinning stories about childhood and Kiki’s Delivery Service is one of the best coming of age movies out there.","link":"/posts/61057.html"},{"title":"Windows系统安装部署","text":"本教程将尽可能以最简练的方式向大家展示Windows系统的安装： 确认安装方式 确认安装体系 下载系统 下载驱动 安装系统 确认安装方式一般重装系统有三种方法： U盘/光盘 重装 (推荐，操作错误还能重新尝试) U盘制作启动盘进入PE重装（推荐，制作启动盘后以后将能一盘多用，例如维护，修复系统呀，系统崩溃后还原数据呀等等） U盘烧录ISO镜像文件进行重装（比较推荐，简单，向导式重装，但是以后不能够用于维护系统） 在当前系统下进行本地安装 确认安装体系电脑系统安装体系有两种 体系 对应硬盘格式 特点 $Legacy$ $MBR$ 不能识别超过3TB的硬盘，启动速度较慢，只能有3个主分区 $UEFI$ $GPT$ 较新的引导方法，能解决$Legacy$不能处理的问题，较旧的电脑可能不支持 下载系统下载这里建议从👉NEXT, ITELLYOU下载 请不要下载Ghost系统镜像（如雨林木风、番茄花园、系统之家、装机员系统等）,会夹带私货，或系统不稳定 注册账号或QQ登入 选择系统，由于这篇教程安装Windows，请选择Windows系统 需要BT或ED2K下载器:推荐👉迅雷 系统 版本 包含 推荐指数 Windows11 商业版(business editions) 专业版、企业版、教育版、专业工作站版、专业教育版 ⭐⭐⭐ Windows11 零售版(consumer editions) 家庭版、专业版、教育版、家庭单语言版、专业工作站版、专业教育版 ⭐⭐⭐ Windows10 商业版(business editions) 专业版、企业版、教育版、专业工作站版、专业教育版 ⭐⭐⭐⭐⭐ Windows10 零售版(consumer editions) 家庭版、专业版、教育版、家庭单语言版、专业工作站版、专业教育版 ⭐⭐⭐⭐ Windows10 企业长期服务版(LTSC) LTSC版 ⭐⭐⭐⭐⭐ Windows8.1, Windows8, Windows7, WindowsVista, WindowsXP 请前往👉MSDN(旧站)下载 …… ⭐⭐ 校验系统NEXT, ITELLYOU网站提供MD5校验值，请务必校验系统MD5值 方式1： 👉校验工具 方式2：Win+R打开cmd,输入：1certutil -hashfile &quot;改成你下载的系统镜像名&quot; md5 比如你的文件是Mirror.iso,位置在D:\\,终端中输入1certutil -hashfile &quot;D:\\Mirror.iso&quot; md5 你得到123MD5 hash of D:\\Mirror.iso:494c35ad437ba453fe9ac28193b4232dCertUtil: -hashfile command completed successfully. 其中494c35ad437ba453fe9ac28193b4232d为该镜像的MD5值 下载驱动为防止某些电脑重装系统后出现网卡驱动未安装而无法进行下一步安装，进行系统安装前务必从当前主机的网卡的官网下载对应的网卡驱动 硬件检测工具：👉鲁大师绿色版 如果不放心，可以下载所有需要的驱动：显卡、声卡、主板。 安装系统U盘制作启动盘安装 注意！你的U盘将会被格式化，请提前做好备份 使用👉Rufus软件进行制作 打开软件： 插入你要制作启动盘的设备 选择你下载的镜像 分区类型填写你选择的安装体系对应的硬盘格式(GPT或MBR)目标系统类型将会自动填写文件系统选择NTFS 你的U盘将会被格式化！！！请最后确认是否已备份！！！ 准备好后点击开始","link":"/posts/65307.html"},{"title":"ZROI-23NOIP十连测-Day2题解","text":"T1有两个正整数$a \\le b &lt; 109$,给定$a \\div b$的值(精确到小数点后19位), 要求还原$a,b$ $\\Large{\\textbf{Sol.}}$ 70分和90分是留给写线性和用double的人的 100分先写结论： 把小数写成连分数的形式：$\\dfrac{1}{a_1+\\dfrac{2}{a_2+ \\cdots}}$，暴力枚举每一层检验是否合法 考虑一个分数会被写成什么形式 $\\dfrac{a}{b} = \\dfrac{1}{\\lfloor b/a \\rfloor+ \\dfrac{b \\bmod a}{a}}$ 这样类似gcd的递归下去由于两个分数的差至少是$10^{-18}$而误差只有$10^{-19}$所以不会影响取整 归纳容易证明 T3定义一个数是好的，当且仅当能够找到三个正整数 $a,b,c$ 满足 $n=ab+ac+bc$ 且 满足 $n=xp^2$。 $\\Large{\\textbf{Sol.}}$ $$n = ab+bc+ac \\Longleftrightarrow n+a^2 = (a+b)(a+c)$$ 因为$a+b&gt;a$且$a+c&gt;a$ 因此我们只需要找到某个正整数$a$,使得$n+a^2$可以分解为两个 正整数之积即可 考虑$x+1$是大于$p$的数的情况 因为 $n = xp^2$,显然我们可以让$a=p$ 那么$n+a^2 = (x+1)p^2$ 若$x+1$是合数(可以判掉，但没必要)：存在$s,t \\ge 2$,使得$st=x+1$$\\Longrightarrow sp&gt;p,tp&gt;p$$\\Longrightarrow \\begin{cases}a = p\\ b = (s-1)p\\c = (t-1)p\\end{cases}$ 若$x+1&gt;p$：$(x+1)&gt;p,p^2&gt;p$$\\Longrightarrow \\begin{cases}a = p\\b = x+1-p\\c = p^2-p\\end{cases}$ 接下来再来考虑$x+1$是不大于$p$的数的情况 若$x+1 = p$,那么$n = (p-1)p^2 = p^3-p^2$ 利用瞪眼法瞪出当$a = 6$的时候 $n+a^2 = p^3-p^2+36 = (p+3)(p^2-4p+12)$可以因式分解 所以我们需要使$p+3&gt;6,b = p-3 &gt;0$且$p$是质数,所以$p \\ge 5$因此对于$p \\le 3$即$n \\le 18$的情况爆搜出答案(没有就是没有) 此时$p+3&gt;6, p^2-4p+12=(p-2)^2+8&gt;6$，所以取$\\begin{cases}a = 6\\b = p-3\\c = p^2-4p+6\\end{cases}$ 若$x+1&lt;p$，设$g = x+1$，那么$n = (g-1)p^2$ 此时$\\gcd(g,p)=1$ 不妨设 $p = kg+r(1 \\le r \\le g-1)$ $\\begin{aligned}n &amp; = (g-1)(kg+r)^2 \\ &amp; = (g-1)(k^2g^2+2krg+r^2) \\ &amp; = k^2g^3+2krg^2+r^2g-k^2g^2-2krg-r^2\\end{aligned}$ 将$r^2$移到左边，即让$a=r$$\\Longrightarrow n+r^2 = g(k^2g^2+2krg+r^2-k^2g-2kr)$ $g&gt;r$ $k^2g^2+2krg+r^2-k^2g-2kr = k^2g(g-1)+2kr(g-1)+r^2 &gt; r^2 \\ge r$ 得到一组解为$\\begin{cases}a = r\\b = g-r\\c = k^2g(g-1)+2kr(g-1)+r^2 - r\\end{cases}$即$\\begin{cases}a = p \\bmod (x+1)\\b = x+1-a\\c = \\dfrac{xp^2+a^2}{x+1}-a\\end{cases}$ T4给定一个排列$p$.要求计算$p$的每个前缀的中位数. $\\Large{\\textbf{Sol.}}$ 开一个对顶堆，维护一下即可","link":"/posts/5037.html"},{"title":"int128","text":"Tip: 比赛支持用__int128 Warning! 编译器的gcc是不支持__int128这种数据类型的，比如在codeblocks 16.01/Dev C++是无法编译的，但是提交到大部分OJ上是可以编译且能用的。C/C++标准，IO是不认识__int128这种数据类型的，因此要自己实现IO，其他的运算，与int没有什么不同。 官方上写了GCC提供了两种128位整数类型，分别是__int128_t和__uint128_t，分别用于声明有符号整数变量和无符号整数变量。 输入12345678inline void read(__int128 &amp;X){ X = 0; int w=0; char ch=0; while(!isdigit(ch)) {w|=ch=='-';ch=getchar();} while(isdigit(ch)) X=(X&lt;&lt;3)+(X&lt;&lt;1)+(ch^48),ch=getchar(); if (w) X = -X;} 输出1234567void print(__int128 x){ if (!x) return ; if (x &lt; 0) putchar('-'),x = -x; print(x / 10); putchar(x % 10 + '0');}","link":"/posts/32190.html"},{"title":"ZROISC2023 Workbook","text":"ZR 2023 Summer C Workbook 第一模块 - 数据结构 - Day 1~7Day1 - 2023.07.17 专题：基础础数据结构及其应⽤（倍增、并查集、RMQ、树状数组、线段树） 讲师：徐锐扬 题目：8 道 Day2 - 2023.07.18 专题：线段树进阶扩展（扫描线、动态开点线段树、线段树合并） 讲师：高麟翔 题目：12 道 Day3 - 2023.07.19 专题：基础分块算法与离线算法（莫队、整体⼆分、时间线段树） 讲师：张家瑞 题目：23 道 Day4 - 2023.07.20 专题：平衡树及其应⽤（Splay,Treap）、LCT 讲师：高麟翔 题目：14 道 Day5 - 2023.07.21 专题：树上信息维护（树链剖分、可并堆、启发式合并）、可持久化数据结构、点分治 讲师：高麟翔 题目：16 道 Day6 - 2023.07.22 专题：点分治、点分树、 虚树、长链剖分、线段树分治 讲师：高麟翔 题目：11 道 Day7 - 2023.07.23 模拟赛。 出题：高麟翔 题目：4 道 时长：3.5 小时 第二模块 - 动态规划 - Day 8~12Day8 - 2023.07.24 专题：区间 DP、树形 DP 讲师：李昕然 题目：7 + 7 = 14 道 例题 作业 Day9 - 2023.07.25 专题：状压 DP、数位 DP 讲师：李昕然 题目：7 + 8 = 15 道 例题 作业 Day10 - 2023.07.26 专题： dp优化（四边形不等式、斜率优化、决策单调性、CDQ分治、数据结构） 讲师：李昕然 题目：9 + 4 = 13 道 例题 作业 Day11 - 2023.07.27 专题：矩阵乘法dp、常系数齐次线性递推、动态dp 讲师：李昕然 题目：10 + 3 = 13 道 例题 作业 Day12 - 2023.07.28 欢乐 ACM 赛（CD）。 比赛链接 整理：徐锐扬 题目：11 道 时长：5 小时 第三模块 - 数学、数论 - Day13~19Day13 - 2023.07.29 专题：乘法逆元、同余、exgcd、线性代数基础、BSGS 、原根 讲师：叶子川 题目：13 道 BONUS Day14 - 2023.07.30 专题：筛法（埃⽒筛、线性筛、杜教筛、Powerful Number 筛 、 min25筛）、莫⽐乌斯反演、狄利克雷卷积 讲师：罗恺 题目：17 道 Day15 - 2023.07.31 专题：组合数学（容斥原理、树prufer序、Matrix-Tree定理、LGV引理） 讲师：王泽远 题目：11 道 Day16 - 2023.08.01 专题：概率期望、多项式、⽣成函数 讲师：吕秋实 题目：6 道 Day17 - 2023.08.02 专题：博弈论、SG函数 讲师：吕秋实 题目：8 道 附加模拟赛。 出题：不知道 题目：3 道 时长：3 小时 Day18 - 2023.08.03 专题：构造 讲师：吕秋实 题目：理论上是 10 道 Day19 - 2023.08.04 模拟赛。 出题：吕秋实 题目：4 道 时长：3.5 小时 第四模块 - 字符串 - Day20~24Day20 - 2023.08.05 专题：基础字符串算法（Hash、Trie、最小表示法、KMP、Manacher） 讲师：吕秋实 题目：12 道 Day21 - 2023.08.06 专题：进阶算法（扩展KMP、AC自动机、回文树） 讲师：yny 题目：16 道 Day22 - 2023.08.07 专题：后缀数组与后缀⾃动机（⼴义 SAM） 讲师：yny 题目：5 道 Day23 - 2023.08.08 专题：趣题（杂题）选做 讲师：yny 题目：14 道 附加模拟赛。 出题：不知道 题目：3 道 时长：3 小时 Day24 - 2023.08.09 欢乐 ACM 赛（ABCD）。 比赛链接 整理：hwy 题目：12 道 时长：5 小时 第五模块 - 图论 - Day25~30Day25 - 2023.08.10 专题：基础图论（拓扑排序、最短路、最小⽣成树、强连通、双连通、Tarjan 算法） 讲师：dcx 题目：28 道 Day26 - 2023.08.11 专题：同余 BFS、差分约束、2-SAT、Tarjan LCA、欧拉回路、三四元环、最小树形图 讲师：dcx 题目：18 道 Day27 - 2023.08.12 专题：二分图匹配（匈牙利算法、KM 算法）、网络流算法（EK、Dinic、费用流） 讲师：dcx 题目：23 题 Day28 - 2023.08.13 专题：线性规划与对偶、网络流建模、增流退流、上下界流 讲师：dcx 题目：20 道 Day29 - 2023.08.14 专题：杂题选讲 讲师：叶子川 题目：8 道","link":"/posts/17780.html"},{"title":"三角函数","text":"以下是对三角函数的一些整理 三角函数同角三角函数关系 平方关系：$\\sin^2\\alpha+\\cos^2\\alpha=1$ 商数关系：$\\tan\\alpha = \\dfrac{\\sin\\alpha}{\\cos\\alpha}$ 三角函数线 有向线段：正弦线$EF$正切线$AG$余弦线$OF$ 特别的 当$\\sin{x}&lt;x&lt;\\tan{x},x\\in\\left(0,\\dfrac{\\pi}{2}\\right)$时：$\\Rightarrow S_{\\triangle OEF} &lt; S_{\\triangle\\overset{\\frown}{OAE}} &lt; S_{\\triangle OAG}$$\\Rightarrow EF&lt;x&lt;AG$ 正弦函数$f(x)=\\sin x$定义域：$R$值域： $[-1,1]$周期：$2\\pi$奇偶性：奇函数 余弦函数$f(x)=\\cos x$定义域：$R$值域： $[-1,1]$周期：$2\\pi$奇偶性：偶函数 正切函数$f(x)=\\tan x$定义域：${x|x\\ne \\dfrac{\\pi}{2}+k\\pi,k \\in R}$值域： $R$周期：$\\pi$奇偶性：奇函数 诱导公式第一组 $\\sin(2k\\pi+\\alpha)=\\sin \\alpha$$\\cos(2k\\pi+\\alpha)=\\cos \\alpha$$\\tan(2k\\pi+\\alpha)=\\tan \\alpha$ $\\sin(\\pi+\\alpha)=-\\sin \\alpha$$\\cos(\\pi+\\alpha)=-\\cos \\alpha$$\\tan(\\pi+\\alpha)=\\tan \\alpha$ $\\sin(2k\\pi-\\alpha)=-\\sin \\alpha$$\\cos(2k\\pi-\\alpha)=\\cos \\alpha$$\\tan(2k\\pi-\\alpha)=-\\tan \\alpha$ $\\sin(\\pi-\\alpha)=\\sin \\alpha$$\\cos(\\pi-\\alpha)=-\\cos \\alpha$$\\tan(\\pi-\\alpha)=-\\tan \\alpha$ 第二组： $\\sin(\\dfrac{\\pi}{2}-\\alpha)= \\cos \\alpha$$\\cos(\\dfrac{\\pi}{2}-\\alpha)= \\sin \\alpha$ $\\sin(\\dfrac{\\pi}{2}+\\alpha)= \\cos \\alpha$$\\cos(\\dfrac{\\pi}{2}+\\alpha)= -\\sin \\alpha$ $\\sin(\\dfrac{3\\pi}{2}-\\alpha)= -\\cos \\alpha$$\\cos(\\dfrac{3\\pi}{2}-\\alpha)= -\\sin \\alpha$ $\\sin(\\dfrac{3\\pi}{2}+\\alpha)= -\\cos \\alpha$$\\cos(\\dfrac{3\\pi}{2}+\\alpha)= \\sin \\alpha$ 两角和差正弦：$\\sin(\\alpha\\pm\\beta)=\\sin(\\alpha)\\cos(\\beta)\\pm\\cos(\\alpha)\\sin(\\beta)$余弦：$\\cos(\\alpha\\pm\\beta)=\\cos(\\alpha)\\cos(\\beta)\\mp\\sin(\\alpha)\\sin(\\beta)$正切：$\\tan(\\alpha\\pm\\beta)=\\dfrac{\\tan{\\alpha}\\pm\\tan{\\alpha}}{1\\mp\\tan{\\alpha}\\tan{\\beta}}$ 合一变形将$a\\sin x+b\\cos x$合一变形设 $\\phi$：$$\\Rightarrow\\begin{cases}\\cos{\\phi} = \\dfrac{b}{\\sqrt{a^2+b^2}}\\\\sin{\\phi} = \\dfrac{a}{\\sqrt{a^2+b^2}}\\end{cases}$$$$\\begin{aligned}\\Rightarrow a\\sin x+b\\cos x &amp; = \\sqrt{a^2+b^2}\\left(\\dfrac{a}{\\sqrt{a^2+b^2}}\\sin x+\\dfrac{b}{\\sqrt{a^2+b^2}}\\cos x\\right) \\ &amp; = \\sqrt{a^2+b^2}\\cos(x-\\phi)\\end{aligned}$$ 二倍角公式$\\sin{2\\alpha}=2\\sin{\\alpha}\\cos{\\alpha}$$\\begin{aligned} \\cos{2\\alpha} &amp; =\\cos^2\\alpha-\\sin^2\\alpha\\ &amp; = 2\\cos^2\\alpha-1\\ &amp; = 1-2\\sin^2\\alpha\\end{aligned}$$\\tan 2\\alpha = \\dfrac{2\\tan\\alpha}{1-\\tan^2\\alpha}$ 半角公式$\\sin\\dfrac{\\alpha}{2} = \\pm \\sqrt{\\dfrac{1-\\cos\\alpha}{2}}$$\\cos\\dfrac{\\alpha}{2} = \\pm \\sqrt{\\dfrac{1+\\cos\\alpha}{2}}$$\\begin{aligned}\\tan\\dfrac{\\alpha}{2} &amp; = \\dfrac{\\sin\\alpha}{1+\\cos\\alpha}\\ &amp; = \\dfrac{1-\\cos\\alpha}{\\sin\\alpha}\\ &amp; = \\pm \\sqrt{\\dfrac{1-\\cos\\alpha}{1+\\cos\\alpha}}\\end{aligned}$ 降次公式$\\sin{\\alpha}\\cos{\\alpha} = \\dfrac{1}{2}sin{2\\alpha}$$\\cos^2\\alpha = \\dfrac{1+\\cos{2\\alpha}}{2}$$\\sin^2\\alpha = \\dfrac{1-\\cos{2\\alpha}}{2}$ 万能公式$\\sin\\alpha = \\dfrac{2\\tan\\dfrac{\\alpha}{2}}{1+\\tan^2\\dfrac{\\alpha}{2}}$$\\tan\\alpha = \\dfrac{2\\tan\\dfrac{\\alpha}{2}}{1-\\tan^2\\dfrac{\\alpha}{2}}$$\\cos\\alpha = \\dfrac{1-\\tan^2\\dfrac{\\alpha}{2}}{1+\\tan^2\\dfrac{\\alpha}{2}}$ 三倍角公式$\\sin 3\\alpha = 3\\sin\\alpha-4\\sin^3\\alpha$$\\cos 3\\alpha = -3\\cos\\alpha+4\\cos^3\\alpha$$\\begin{aligned}\\tan 3\\alpha &amp; = \\dfrac{3\\tan\\alpha-\\tan^3\\alpha}{1-3\\tan^2\\alpha}\\ &amp; = \\tan\\alpha\\tan(\\dfrac{\\pi}{3}+\\alpha)\\tan(\\dfrac{\\pi}{3}-\\alpha)\\end{aligned}$ 积与和差积化和差$\\sin\\alpha\\cos\\beta = \\dfrac{1}{2}\\left[\\sin(\\alpha+\\beta)+\\sin(\\alpha-\\beta)\\right]$$\\sin\\alpha\\sin\\beta = -\\dfrac{1}{2}\\left[\\cos(\\alpha+\\beta)-\\cos(\\alpha-\\beta)\\right]$$\\cos\\alpha\\cos\\beta = \\dfrac{1}{2}\\left[\\cos(\\alpha+\\beta)+\\cos(\\alpha-\\beta)\\right]$ 和差化积$\\sin\\alpha+\\sin\\beta = 2\\sin\\dfrac{\\alpha+\\beta}{2}\\cos\\dfrac{\\alpha-\\beta}{2}$$\\sin\\alpha-\\sin\\beta = 2\\cos\\dfrac{\\alpha+\\beta}{2}\\sin\\dfrac{\\alpha-\\beta}{2}$$\\cos\\alpha+\\cos\\beta = 2\\cos\\dfrac{\\alpha+\\beta}{2}\\cos\\dfrac{\\alpha-\\beta}{2}$$\\cos\\alpha-\\cos\\beta = -2\\sin\\dfrac{\\alpha+\\beta}{2}\\sin\\dfrac{\\alpha-\\beta}{2}$ 求三角函数最值？ $f(x) = a\\sin{x}+b\\cos{x}$，通过合一变形 $f(x) = a\\sin^2x+b\\sin{x}\\cos{x}+\\cos^2x$，通过先降次再合一 $f(x) = a\\sin^2x+b\\sin{x}+c$，通过二次合一 解三角形余弦定理$\\boxed{SSA}\\boxed{SAS}\\begin{cases}c^2 = a^2+b^2-2ab\\cos{C}\\b^2 = a^2+c^2-2ac\\cos{B}\\a^2 = b^2+c^2-2bc\\cos{A}\\end{cases}$ $\\boxed{SSS}\\begin{cases}\\cos{C} = \\dfrac{a^2+b^2-c^2}{2ab}\\\\cos{B} = \\dfrac{a^2+c^2-b^2}{2ac}\\\\cos{A} = \\dfrac{b^2+c^2-a^2}{2bc}\\\\end{cases}$ 拓展： 假设$\\angle{C}&gt;\\angle{B}&gt;\\angle{A}$：若$\\angle{C}=90^\\circ\\Longleftrightarrow\\cos{C}=0\\Longleftrightarrow a^2+b^2=c^2$若$\\angle{C}&lt;90^\\circ\\Longleftrightarrow\\cos{C}&gt;0\\Longleftrightarrow a^2+b^2&gt;c^2$若$\\angle{C}&gt;90^\\circ\\Longleftrightarrow\\cos{C}&lt;0\\Longleftrightarrow a^2+b^2&lt;c^2$ 正弦定理$\\boxed{AAS}\\boxed{ASA} \\dfrac{a}{\\sin{A}}=\\dfrac{b}{\\sin{B}}=\\dfrac{c}{\\sin{C}}=D=2R$$\\begin{cases} \\sin{A}=\\dfrac{a}{2R}\\ a = 2R\\sin{A}\\end{cases}$在$\\triangle{ABC}$中，$A&gt;B\\Longleftrightarrow a&gt;b\\Longleftrightarrow \\sin{A}&gt;\\sin{B}$ 已知$\\boxed{SSA}?$ 利用余弦公式$\\Longrightarrow$方程正根 利用正弦定理$\\Longrightarrow\\dfrac{a}{\\sin A}=\\dfrac{b}{\\sin B}$$0&lt;\\sin B&lt; 1\\Longrightarrow 有两解 \\Longrightarrow 保证C \\in (0^\\circ, 180^\\circ)$$\\sin B= 1\\Longrightarrow 一解 B=90^\\circ$$\\sin B&gt; 1\\Longrightarrow 无解$ $\\triangle{ABC}面积$$\\begin{aligned}S_{\\triangle{ABC}} &amp; =\\dfrac{1}{2}bc\\sin{A}\\ &amp; = \\dfrac{1}{2}\\left|\\overrightarrow{AB}\\right|\\left|\\overrightarrow{AC}\\right|\\sqrt{1-\\cos^2A}\\end{aligned}$ $\\triangle{ABC}形状$ $a\\cos B = b\\cos A$ 等腰 $A\\cos B = b\\cos B$ 等腰直角 $\\color{RED}{公式遗漏，待询问}$","link":"/posts/21383.html"},{"title":"乘法逆元","text":"定义若$ax \\equiv 1\\pmod b$,则称x是$a$是关于模$b$的逆元，常记作$a^{-1}$. 性质上式等价于$ax+by=1$,求解逆元即为解方程$ax+by=1$。 $\\Longrightarrow$逆元不一定存在：充要条件为$(a,b)=1$$\\Longrightarrow p$是质数，$p$不整除$a$,则$a$模$p$的逆元存在。 $\\Longrightarrow$在$[0,b)$范围内，$a$关于模$b$的逆元(若存在)是唯一的。 证明：反证法若a有两个逆元$0&lt;x_1&lt;x_2&lt;b$,即$ax_1 = ax_2 = 1 \\pmod b$.那么有$b|a(x_2-x_1)$成立又由于$(a, b) =1$,因此$b|(x_2-x_1)$其中$0&lt;x_2-x_1&lt;b$,产生了矛盾。 求解 利用$\\operatorname{exgcd}$求逆元 12345int inv(int a,int b){ //表示求a在模b意义下的逆元 int x,y; exgcd(a,b,x,y); return x;} 为取正数 12345int inv(int a,int b){ int x,y; exgcd(a,b,x,y); return (x%b+b)%b;} 在1的基础上进行倒推先求$n!$的逆元，然后利用$((n-1)!)^{-1} \\equiv n \\times (n!)^{-1} \\pmod p$,即除以$n$,就可以求$1 \\ldots n$的逆元了 顺推求解假设求$i$的逆元考虑带余除法$p=iq+r$$iq+r \\equiv 0 \\pmod p$两边同乘上$i^{-1}r^{-1}$得到$qr^{-1}+i^{-1} \\equiv 0 \\pmod p$$\\Longrightarrow i^{-1} \\equiv (p-(p/i))(p \\bmod i)^{-1} \\pmod p i^{-1} \\equiv -qr^{-1} \\pmod p$$\\Longrightarrow i^{-1} \\equiv -(p/i)(p \\bmod i)^{-1} \\pmod p$$\\Longrightarrow inv[i]=-(p-p/i)inv[p \\bmod i] \\pmod p$","link":"/posts/24044.html"},{"title":"北大学子经验","text":"学长：董蕾毕业中学：重庆市酉阳第一中学校就读院系：北京大学工学院 学院介绍北京大学的工科教育历史悠久，1910 年 3 月即组织了工学院（当时称工科分科大学）工学院从成立开始就从高起点出发，立足于尖端科技、交叉学科，着眼于未来工程科学和新技术的发展方向，面向国家迫切需要及关系国家中长远经济发展的科学与技术研发。因此，北大工学院的发展以培育核心创造能力为中心，有所为、有所不为，优中求精。同时，学院采用与国际接轨的院长负责制，实行“教授治学，民主治院”。学院重建以来，在学科发展、队伍建设、科学研究、人才培养、合作与发展等方面取得了突出成绩。学院现设有 5 个系，以及湍流与复杂系统国家重点实验室、北京市工程科学与新兴技术高精尖创新中心等多个重要研究机构，它们中不少已经进入世界先进学科的行列。 数学 大量刷题是必要的 首先刷大量的题。新知识学习阶段是在老师的指导下进行系统的学习并完成的相应练习，记为“课内题”，得以巩固。如果能在老师的布置之外自己再完成对应课程的其他题，记为“课外题”，这样基础会更扎实。 要有效率地订正答案 自己对答案的时候尤其需要认真。不能只看答案正确与否，需要将自己的思路和答案的思路比对。若相同，则学习记忆参考答案的步骤，确保自己下次做类似题不会因步骤不全而扣分；若不同，首先理解参考答案的思路，在闭卷的情况下能完整地运用参考答案的思路解题。同时，保证步骤细节完善，然后核查自己的思路有无问题，如果不能确定，就去咨询老师或同学，再比较两种思路，比如哪种更通俗、更快捷、更安全（不易算错、不易写错、不易被扣分），更符合个人的思维习惯等。接下来进行取舍，选择最佳思路，在下次解类似题时偏向该思路，但也要熟悉另外多种思路方式，避免最佳思路行不通时无路可走。 要经常回顾题目并对题目分类 就我而言，做过的题可以分为简单题（掌握知识点就能做对）、易错题、难题（花费很长时间，在知识的基础上需要大量的思考和尝试，计算能力要足够高，还需要一定的技巧）、巧题（有特定、快捷的解题模式）、模糊题（在限定时间内模糊一些步骤，连蒙带猜得出正解）。 刷题后间隔一定时间（3～8天，根据自己的记忆习惯来定）进行再刷。再刷的时候就要看自己对以做题的分类了：简单题：没必要再刷，如果简单题出错就要翻看教材，最好对相关知识安排一次早读；易错题：间隔较长周期多次刷，并且总结错误类型和将再刷的正误记录，若连续正确三次就可以将该题从刷题列表上划去了；难题：我建议每天一道来进行训练，自己评分找快感。当天题当天解决弄懂，能默写出正解，对于前次未做出来的题隔天再做一次。当然隔天有隔天的任务，旧题不能代替；巧题：需要记思维记题型，学会举一反三，但我认为尤其重要的是记住条件，特别思维方式的适用条件，否则容易一味找捷径，花费的时间比常规方法还长，最后还发现脑海中的巧解并不适合该题；模糊题：在对答案后要注意自己模糊之处的正确书写以及得分点，以免模糊过多形成习惯导致解题断片、答案扣分等。 对做过的题进行熟悉总结和分类，形成自己的一个题库。不一定要装定裁剪成册，只需要碰到某种类型的题时，自己知道能在哪里找到曾做过的，知道曾做过的题是怎样做的，共有多少方法可以解决就可以。 要善于把握考试时间 考前对自己催眠，将考试时间缩短半个小时。关于考试，我尝试过这种方法，对于题做不完的同学来说可能有较大用处。比如说规定时间是14:30～16:30，就暗示自己16:00就要交卷了。能有效加快自己的做题速度，增强紧张感。毕竟有种说法叫“急中生智”，这种情况下思维能更灵活。我曾有过好多次这样的经历，倒不是自我催眠，只是记错了交卷时间。这样考试获得的结果都还不错，对于我从习惯性做不完试题到完成试卷有很大的激励意义。 我也是那种做不完题目的人🤣🤣🤣，这种方法对我很有帮助 语文 要增强读书的广度与速度 学会自己延长早读时间，包括单纯的时间和读书速度及效度。读的内容要跨度广，比如诗歌及诗歌赏析、时事素材、文言文词句释义、范文及优美段落、范例题和错题、语法和知识点等。 看书时多摘抄文段，勤背诵 另外阅读有趣且有益的书籍，主要根据个人喜好决定。偏文学方面的可以读散文集，比如史铁生的《扶轮问路》《病隙碎笔》《放下与执着》《我与地坛》等，简媜的《水问》《唯有相爱，可抵岁月漫长》等，李娟的《冬牧场》《遥远的向日葵地》等，梁静的《看见》等大家作品或获奖作品。常看常摘抄对于文笔的修炼有好处，另外文章中的哲思，若是有一定理解了运用在作文中也相当有思想深度。偏理科方面的可以读牛顿的《自然哲学的数学原理》《费恩曼物理学讲义》《上帝掷骰子了吗》《science》杂志等，可以自己试着去找。这些书对概念的理解对开阔解题思路有益，也能给扎堆题海的我们一点轻松愉悦的体验。记得多。费尽心思才行。晨起睁眼背诵一段文章，去食堂的路上念念必背的诗歌，出操的时候拿一张文化常识单子，回宿舍的时候再背背文言文，晚饭时间可以记记范例题及答案。努力做到语法知识点信手拈来，各主题的出色论点绝佳段落张口即出。(内卷？) 多练习，熟悉题型 练得多。练要循序渐进、笔耕不辍、积少成多。各类型（主要是高考题型）的题要“雨露均沾”，可以适当偏爱那些灼手挠心的题。还有练笔，要经常输出才行，我之前的计划是两天写一小段，每周整理。虽然没有最终坚持下去，但是练笔之后那段时间，写作文相当流畅，效果是很好的。另外还要有自己拿得出手的文章。可以就从平时老师布置的作文题或者测试中的作文题，选择自己拿手的、有想法的或者难为的、一窍不通的来写。和老师讨论，看看自己作文的优缺点并作修改，改了再去问问老师，继续修改，直到蜕变成满分作文。打造一篇作文的时间往往不短，要有思维断片的预设准备，若卡壳了就再等等，有想法有思路之后再继续写，大概重要的是耐心和决心。见得多。这个主要是拓宽眼界。包括新题型：阅读设题方式及对应解答思路，相应的文言文、诗歌赏析、默写、语言文字运用，作文写法和各色主题等。见得多可以让你在面对新题时不慌张，形成清晰的答题思路。 多思考，找到适合自己的审题作答模式 思得多。记背的东西多了，就容易漏掉思考；套路模式见多了，也容易忽略思考。要知道所谓的答题格式都是人总结琢磨出来的，而考生应该从格式的拘束中跳脱出来，活学活用。想清楚答案为什么是答案，你怎样做出你的答案，为什么没有体会到出题意图，为什么没有感同身受等。作文也是，当拿到一个主题，应该先充分思考，挖掘自己的想法，而不能首先是翻阅脑袋里的库存，找类似的范文。思考多了，文字会更深刻，你就可以写出一篇新颖别致的好文。 英语众所周知，英语很 白 因此学长给出的方法不多 听力要专注，可以开倍速 在最后复习那段时间，我会隔日去办公室借老师的电脑练习听力，用午休的部分时间做一套听力题。在练的时候，我一般用1.25和1.5的倍速。听力还需要练习严谨的态度，不论简单还是难，都不走神。以免听正常语速的听力时由于轻视走神而导致出错丢分。我在听下次听力时，会把上次没听懂的、做错了的题再听一遍。 要按照模块总结知识点 首先语法要记熟，然后练题检测，反复测，把每道题的知识点考点弄清楚，查漏补缺。哪块薄弱就重点关照，做过的错题也得多看。早读的时候多背背语法，晚自习要挤时间出来复习看过的内容。对于应用作文，逐个分类。比如演讲稿、倡议书、介绍信、建议信、报告类、日记等。往往每个类别有内容元素的不同要求，可以准备一些语段、词句。对于叙写，高级词汇，修辞，主旨句之类的都要随时备着。 续写需要多练习 英语作文也需要多练习，包括两种训练，一是练习思路把握主旨，二是练习速写书写和文笔。前者，可以只看题，谋划谋划情节线，再比对答案；也可以写出大略提纲，关键句，想到的高分词汇等。重点在多练，阅尽叙写，情节自现。后者，要善于寻找发现美句，并善于记录；四级词汇最好每天都不要落下；维克多也很好。","link":"/posts/4909.html"},{"title":"卡特兰数","text":"Catalan 数列 以下问题属于 Catalan 数列： 有 $2n$ 个人排成一行进入剧场。入场费 5 元。其中只有 $n$ 个人有一张 5 元钞票，另外 $n$ 人只有 10 元钞票，剧院无其它钞票，问有多少种方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？ 一位大城市的律师在她住所以北 $n$ 个街区和以东 $n$ 个街区处工作。每天她走 $2n$ 个街区去上班。如果他从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 在圆上选择 $2n$ 个点，将这些点成对连接起来使得所得到的 $n$ 条线段不相交的方法数？ 对角线不相交的情况下，将一个凸多边形区域分成三角形区域的方法数？ 一个栈（无穷大）的进栈序列为 $1,2,3, \\cdots ,n$ 有多少个不同的出栈序列？ $n$ 个结点可构造多少个不同的二叉树？ $n$ 个 $+1$ 和 $n$ 个 $-1$ 构成 $2n$ 项 $a_1,a_2, \\cdots ,a_{2n}$，其部分和满足 $a_1+a_2+ \\cdots +a_k \\geq 0(k=1,2,3, \\cdots ,2n)$ 对与 $n$ 该数列为？ 其对应的序列为： $H_0$ $H_1$ $H_2$ $H_3$ $H_4$ $H_5$ $H_6$ … 1 1 2 5 14 42 132 … (Catalan 数列) 递推式该递推关系的解为： $$H_n = \\frac{\\binom{2n}{n}}{n+1}(n \\geq 2, n \\in \\mathbf{N_{+}})$$ 关于 Catalan 数的常见公式： $$H_n = \\begin{cases} \\sum_{i=1}^{n} H_{i-1} H_{n-i} &amp; n \\geq 2, n \\in \\mathbf{N_{+}}\\ 1 &amp; n = 0, 1\\end{cases}$$ $$H_n = \\frac{H_{n-1} (4n-2)}{n+1}$$ $$H_n = \\binom{2n}{n} - \\binom{2n}{n-1}$$ 例题洛谷 P1044 栈“题目大意：入栈顺序为 $1,2,\\ldots ,n$，求所有可能的出栈顺序的总数。 12345678910111213#include &lt;iostream&gt;using namespace std;int n;long long f[25];int main() { f[0] = 1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) f[i] = f[i - 1] * (4 * i - 2) / (i + 1); // 这里用的是常见公式2 cout &lt;&lt; f[n] &lt;&lt; endl; return 0;} 1234567f = [0] * 25f[0] = 1n = int(input())for i in range(1, n + 1): f[i] = int(f[i - 1] * (4 * i - 2) // (i + 1)) # 这里用的是常见公式2print(f[n]) 封闭形式卡特兰数的递推式为 $$H_n=\\sum_{i=0}^{n-1}H_{i}H_{n-i-1} \\quad (n\\ge 2)$$ 其中 $H_0=1,H_1=1$。设它的普通生成函数为 $H(x)$。 我们发现卡特兰数的递推式与卷积的形式很相似，因此我们用卷积来构造关于 $H(x)$ 的方程： $$\\begin{aligned}H(x)&amp;=\\sum_{n\\ge 0}H_nx^n\\&amp;=1+\\sum_{n\\ge 1}\\sum_{i=0}^{n-1}H_ix^iH_{n-i-1}x^{n-i-1}x\\&amp;=1+x\\sum_{i\\ge 0}H_{i}x^i\\sum_{n\\ge 0}H_{n}x^{n}\\&amp;=1+xH^2(x)\\end{aligned}$$ 解得 $$H(x)=\\frac{1\\pm \\sqrt{1-4x}}{2x}$$ 那么这就产生了一个问题：我们应该取哪一个根呢？我们将其分子有理化： $$H(x)=\\frac{2}{1\\mp \\sqrt{1-4x}}$$ 代入 $x=0$，我们得到的是 $H(x)$ 的常数项，也就是 $H_0$。当 $H(x)=\\dfrac{2}{1+\\sqrt{1-4x}}$ 的时候有 $H(0)=1$，满足要求。而另一个解会出现分母为 $0$ 的情况（不收敛），舍弃。 因此我们得到了卡特兰数生成函数的封闭形式： $$H(x)=\\frac{1- \\sqrt{1-4x}}{2x}$$ 接下来我们要将其展开。但注意到它的分母不是斐波那契数列那样的多项式形式，因此不方便套用等比数列的展开形式。在这里我们需要使用牛顿二项式定理。我们来先展开 $\\sqrt{1-4x}$： $$\\begin{aligned}(1-4x)^{\\frac{1}{2}}&amp;=\\sum_{n\\ge 0}\\binom{\\frac{1}{2}}{n}(-4x)^n\\&amp;=1+\\sum_{n\\ge 1}\\frac{\\left(\\frac{1}{2}\\right)^{\\underline{n}}}{n!}(-4x)^n\\end{aligned} \\tag{1}$$ 注意到 $$\\begin{aligned}\\left(\\frac{1}{2}\\right)^{\\underline{n}}&amp;=\\frac{1}{2}\\frac{-1}{2}\\frac{-3}{2}\\cdots\\frac{-(2n-3)}{2}\\&amp;=\\frac{(-1)^{n-1}(2n-3)!!}{2^n}\\&amp;=\\frac{(-1)^{n-1}(2n-2)!}{2^n(2n-2)!!}\\&amp;=\\frac{(-1)^{n-1}(2n-2)!}{2^{2n-1}(n-1)!}\\end{aligned}$$ 这里使用了双阶乘的化简技巧。那么带回 $(1)$ 得到 $$\\begin{aligned}(1-4x)^{\\frac{1}{2}}&amp;=1+\\sum_{n\\ge 1}\\frac{(-1)^{n-1}(2n-2)!}{2^{2n-1}(n-1)!n!}(-4x)^n\\&amp;=1-\\sum_{n\\ge 1}\\frac{(2n-2)!}{(n-1)!n!}2x^n\\&amp;=1-\\sum_{n\\ge 1}\\binom{2n-1}{n}\\frac{1}{(2n-1)}2x^n\\end{aligned}$$ 带回原式得到 $$\\begin{aligned}H(x)&amp;=\\frac{1- \\sqrt{1-4x}}{2x}\\&amp;=\\frac{1}{2x}\\sum_{n\\ge 1}\\binom{2n-1}{n}\\frac{1}{(2n-1)}2x^n\\&amp;=\\sum_{n\\ge 1}\\binom{2n-1}{n}\\frac{1}{(2n-1)}x^{n-1}\\&amp;=\\sum_{n\\ge 0}\\binom{2n+1}{n+1}\\frac{1}{(2n+1)}x^{n}\\&amp;=\\sum_{n\\ge 0}\\binom{2n}{n}\\frac{1}{n+1}x^{n}\\\\end{aligned}$$ 这样我们就得到了卡特兰数的通项公式。 路径计数问题非降路径是指只能向上或向右走的路径。 从 $(0,0)$ 到 $(m,n)$ 的非降路径数等于 $m$ 个 $x$ 和 $n$ 个 $y$ 的排列数，即 $\\dbinom{n + m}{m}$。 从 $(0,0)$ 到 $(n,n)$ 的除端点外不接触直线 $y=x$ 的非降路径数： 先考虑 $y=x$ 下方的路径，都是从 $(0, 0)$ 出发，经过 $(1, 0)$ 及 $(n, n-1)$ 到 $(n,n)$，可以看做是 $(1,0)$ 到 $(n,n-1)$ 不接触 $y=x$ 的非降路径数。 所有的的非降路径有 $\\dbinom{2n-2}{n-1}$ 条。对于这里面任意一条接触了 $y=x$ 的路径，可以把它最后离开这条线的点到 $(1,0)$ 之间的部分关于 $y=x$ 对称变换，就得到从 $(0,1)$ 到 $(n,n-1)$ 的一条非降路径。反之也成立。从而 $y=x$ 下方的非降路径数是 $\\dbinom{2n-2}{n-1} - \\dbinom{2n-2}{n}$。根据对称性可知所求答案为 $2\\dbinom{2n-2}{n-1} - 2\\dbinom{2n-2}{n}$。 从 $(0,0)$ 到 $(n,n)$ 的除端点外不穿过直线 $y=x$ 的非降路径数： 用类似的方法可以得到：$\\dfrac{2}{n+1}\\dbinom{2n}{n}$","link":"/posts/54838.html"},{"title":"可持久化字典树-01Trie","text":"例题 题目描述给定一个非负整数序列 ${a}$，初始长度为 $N$。 有 $M$ 个操作，有以下两种操作类型： A x：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $N$ 加 $1$。 Q l r x：询问操作，你需要找到一个位置 $p$，满足 $l \\le p \\le r$，使得：$a[p] \\oplus a[p+1] \\oplus … \\oplus a[N] \\oplus x$ 最大，输出最大值。 输入格式第一行包含两个整数 $N, M$，含义如问题描述所示。第二行包含 $N$ 个非负整数，表示初始的序列 $A$。接下来 $M$ 行，每行描述一个操作，格式如题面所述。 输出格式假设询问操作有 $T$ 个，则输出应该有 $T$ 行，每行一个整数表示询问的答案。 样例 #1样例输入 #112345675 52 6 4 3 6A 1 Q 3 5 4 A 4Q 5 7 0 Q 3 6 6 样例输出 #1123456 提示 对于所有测试点，$1\\le N,M \\le 3\\times 10 ^ 5$，$0\\leq a_i\\leq 10 ^ 7$。 AC Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,m,len=25;int a[600005],xor_sum[600005];int root[600005],idx=0;struct node{ int ch[2]; int ver[2]={-1,-1};}tr[600000*20+5];void insert(int pre, int &amp;pos, int r,int val,int ver){ pos=++idx; int c=(val&gt;&gt;r)&amp;1; tr[pos].ch[!c]=tr[pre].ch[!c]; tr[pos].ver[!c]=tr[pre].ver[!c]; tr[pos].ver[c]=ver; r? insert(tr[pre].ch[c],tr[pos].ch[c],r-1,val,ver):void();}int query(int pos,int lim,int r,int val){ int c=(val&gt;&gt;r)&amp;1; return (r? ((tr[pos].ver[!c]&gt;=lim ? query(tr[pos].ch[!c],lim,r-1,val)+(1&lt;&lt;r):query(tr[pos].ch[c],lim,r-1,val))):(tr[pos].ver[!c]&gt;=lim ? 1:0));}int main(){ n=read(),m=read(); insert(0,root[0],len,0,0); for(int i = 1;i&lt;=n;i++){ a[i]=read();xor_sum[i]=xor_sum[i-1]^a[i]; insert(root[i-1],root[i],len,xor_sum[i],i); } for(int i = 1,x,l,r;i&lt;=m;i++){ char opt; cin&gt;&gt;opt; if(opt=='A'){ ++n; a[n]=read();xor_sum[n]=xor_sum[n-1]^a[n]; insert(root[n-1],root[n],len,xor_sum[n],n); }else{ l=read(),r=read(),x=read(); cout&lt;&lt;(query(root[r-1],l-1,len,x^xor_sum[n]))&lt;&lt;endl; } } return 0;} 解释01trie主要解决异或问题 信息存储在边上，表示这一位是$0$还是$1$","link":"/posts/45854.html"},{"title":"可持久化数据结构","text":"可持久化数组 可持久化线段树(主席树) 可持久化字典树(01Trie) 可持久化平衡树","link":"/posts/55889.html"},{"title":"可持久化数组","text":"题目描述如题，你需要维护这样的一个长度为 $N$ 的数组，支持如下几种操作 在某个历史版本上修改某一个位置上的值 访问某个历史版本上的某一位置的值 此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 输入格式输入的第一行包含两个正整数$N,M$，分别表示数组的长度和操作的个数。 第二行包含$N$个整数，依次为初始状态下数组各位的值（依次为$a_i$,$1 \\leq i \\leq N$）。 接下来$M$行每行包含3或4个整数，代表两种操作之一（$i$为基于的历史版本号） 输出格式输出包含若干行，依次为每个操作2的结果。 样例 #1样例输入 #11234567891011125 1059 46 14 87 410 2 10 1 1 140 1 1 570 1 1 884 2 40 2 50 2 44 2 12 2 21 1 5 91 样例输出 #1123456598741878846 提示数据规模： 对于30%的数据：$1 \\leq N, M \\leq {10}^3$ 对于50%的数据：$1 \\leq N, M \\leq {10}^4$ 对于70%的数据：$1 \\leq N, M \\leq {10}^5$ 对于100%的数据：$1 \\leq N, M \\leq {10}^6, 1 \\leq {loc}_i \\leq N, 0 \\leq v_i &lt; i, -{10}^9 \\leq a_i, {value}_i \\leq {10}^9$ 询问生成的版本是指你访问的那个版本的复制 样例说明： 一共11个版本，编号从0-10，依次为： * 0 : 59 46 14 87 41 * 1 : 59 46 14 87 41 * 2 : 14 46 14 87 41 * 3 : 57 46 14 87 41 * 4 : 88 46 14 87 41 * 5 : 88 46 14 87 41 * 6 : 59 46 14 87 41 * 7 : 59 46 14 87 41 * 8 : 88 46 14 87 41 * 9 : 14 46 14 87 41 * 10 : 59 46 14 87 91 AC Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std;inline int read(){int x=0,f=1;char c=getchar();for(;!isdigit(c);c=getchar())if(c=='-')f=-1;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);return x*f;}int n,m,idx,root[1000005];struct node{ int lc; int rc; int val;}tr[1000001*30];void build(int &amp;pos,int l,int r){ pos=++idx; if(l==r){ return tr[pos].val=read(),void(); } int mid = (l+r)&gt;&gt;1; build(tr[pos].lc,l,mid); build(tr[pos].rc,mid+1,r);}void update(int pre,int &amp;pos,int l,int r,int x,int val){ pos=++idx;tr[pos]=tr[pre]; if(l==r){ return tr[pos].val=val,void(); } int mid = (l+r)&gt;&gt;1; if(mid&gt;=x)update(tr[pre].lc,tr[pos].lc,l,mid,x,val); else update(tr[pre].rc,tr[pos].rc,mid+1,r,x,val);}int query(int pos,int l,int r,int x){ if(l==r){ return tr[pos].val; } int mid = (l+r)&gt;&gt;1; if(mid&gt;=x)return query(tr[pos].lc,l,mid,x); else return query(tr[pos].rc,mid+1,r,x);}int main(){ n=read(),m=read(); build(root[0],1,n); for(int i = 1,ver,loc,val,opt;i&lt;=m;i++){ ver=read(),opt=read(),loc=read(); if(opt&amp;1){ val=read(); update(root[ver],root[i],1,n,loc,val); }else{ cout&lt;&lt;query(root[ver],1,n,loc)&lt;&lt;endl; root[i]=root[ver]; } } return 0;} 伪代码12345678910111213141516171819202122232425idx:节点编号mid (左边界+右边界)&gt;&gt;1上传：（当前节点） 合并 左儿子 右儿子 的信息建树：（当前节点，左边界，右边界） 当前节点 &lt;- ++idx if 左界=右界 ： 维护一些值 返回 递归建树（当前节点左儿子） 递归建树（当前节点右儿子） 上传（当前节点）区间查询：（当前节点，左边界，右边界，查询的左边界，查询的右边界） if 查询的左边界&lt;=左边界 &amp;&amp; 右边界&lt;=查询的右边界: 返回当前节点信息 if 查询的左边界&lt;=mid 返回 区间查询（当前节点左儿子） if 查询的右边界&gt;mid 返回 区间查询（当前节点右儿子）更新：（上个版本的当前节点，当前版本的当前节点，左边界，右边界，改变的位置，更改的值） 当前节点 &lt;- ++idx if 左界=右界 ： 当前版本的当前节点的值 &lt;- 更改的值 返回 if 改变的位置 &lt;= mid 更新（当前节点左儿子） else 更新（当前节点右儿子） 上传（当前节点）","link":"/posts/43698.html"},{"title":"可持久化线段树","text":"题目背景 这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。 题目描述如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。 输入格式第一行包含两个整数，分别表示序列的长度 $n$ 和查询的个数 $m$。第二行包含 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个元素 $a_i$。接下来 $m$ 行每行包含三个整数 $ l, r, k$ , 表示查询区间 $[l, r]$ 内的第 $k$ 小值。 输出格式对于每次询问，输出一行一个整数表示答案。 样例 #1样例输入 #112345675 525957 6405 15770 26287 26465 2 2 13 4 14 5 11 2 24 4 1 样例输出 #112345640515770262872595726287 提示样例 1 解释$n=5$，数列长度为 $5$，数列从第一项开始依次为${25957, 6405, 15770, 26287, 26465}$。 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。 数据规模与约定 对于 $20%$ 的数据，满足 $1 \\leq n,m \\leq 10$。 对于 $50%$ 的数据，满足 $1 \\leq n,m \\leq 10^3$。 对于 $80%$ 的数据，满足 $1 \\leq n,m \\leq 10^5$。 对于 $100%$ 的数据，满足 $1 \\leq n,m \\leq 2\\times 10^5$，$|a_i| \\leq 10^9$，$1 \\leq l \\leq r \\leq n$，$1 \\leq k \\leq r - l + 1$。 AC Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;inline int read(){int x=0,f=1;char c=getchar();for(;!isdigit(c);c=getchar())if(c=='-')f=-1;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48);return x*f;}struct node{ int lc; int rc; int val;}tr[40000005];int root[200005],val[200005];int idx=0,n,m,maxn;vector&lt;int&gt;a;void build(int &amp;pos,int l,int r){ pos=++idx; if(l==r) return; int mid = (l+r)&gt;&gt;1; build(tr[pos].lc,l,mid);build(tr[pos].rc,mid+1,r);}void insert(int pre,int &amp;pos,int l,int r,int val){ pos=++idx;tr[pos]=tr[pre];tr[pos].val++; if(l==r)return; int mid = (l+r)&gt;&gt;1; if(mid&gt;=val)insert(tr[pre].lc,tr[pos].lc,l,mid,val); else insert(tr[pre].rc,tr[pos].rc,mid+1,r,val);}int query(int l_pos,int r_pos,int l,int r,int rank){ if(l==r)return l; int mid = (l+r)&gt;&gt;1; int s = tr[tr[r_pos].lc].val-tr[tr[l_pos].lc].val; if(s&gt;=rank) return query(tr[l_pos].lc,tr[r_pos].lc,l,mid,rank); else return query(tr[l_pos].rc,tr[r_pos].rc,mid+1,r,rank-s);}int getid(int val){ return lower_bound(a.begin(),a.end(),val)-a.begin()+1;}int main(){ n=read(),m=read(); for(int i = 1;i&lt;=n;i++){ val[i]=read(); a.push_back(val[i]); } sort(a.begin(),a.end()); a.erase(unique(a.begin(),a.end()),a.end()); maxn=a.size(); build(root[0],1,maxn); for(int i = 1;i&lt;=n;i++){ insert(root[i-1],root[i],1,maxn,getid(val[i])); } for(int i = 1,x,y,z;i&lt;=n;i++){ x=read(),y=read(),z=read(); cout&lt;&lt;a[query(root[x-1],root[y],1,maxn,z)-1]&lt;&lt;endl; } return 0;} 注意亿些细节： 数据规模： 123456struct node{ int lc; int rc; int val; }tr[40000005]; int root[200005],val[200005]; 初始简述需要开$2n-1$个节点。有$n$次插入，每次插入最多增加$\\log n +1$个节点。总共节点数为$n\\log n+3n$,约为$20$倍; 查询 1234567int query(int l_pos,int r_pos,int l,int r,int rank){ if(l==r)return l; int mid = (l+r)&gt;&gt;1; int s = tr[tr[r_pos].lc].val-tr[tr[l_pos].lc].val;//要判断是当前节点左儿子的情况 if(s&gt;=rank) return query(tr[l_pos].lc,tr[r_pos].lc,l,mid,rank); else return query(tr[l_pos].rc,tr[r_pos].rc,mid+1,r,rank-s); } 输出 1234for(int i = 1,x,y,z;i&lt;=n;i++){ x=read(),y=read(),z=read(); cout&lt;&lt;a[query(root[x-1],root[y],1,maxn,z)-1]&lt;&lt;endl;//是x,y所在版本的根导入函数，由于vector a数据从0开始， }","link":"/posts/64052.html"},{"title":"差分约束","text":"前置芝士 👉SPFA单源最短路 定义来自OI-Wiki blue 差分约束系统 是一种特殊的 $n$ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,\\dots,x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j\\leq c_k$，其中 $1 \\leq i, j \\leq n, i \\neq j, 1 \\leq k \\leq m$ 并且 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 $x_1=a_1,x_2=a_2,\\dots,x_n=a_n$，使得所有的约束条件得到满足，否则判断出无解。 思路我们将每个约束条件$x_i-x_j\\leq c_k$变形成$x_i\\leq x_j+c_k$,然后这个形式很像单源最短路中的 $dist[y]\\leq dist[x]+z$ 。因此，我们可以把每个变量 $x_i$ 看做图中的一个结点，对于每个约束条件 $x_i-x_j\\leq c_k$，从结点 $\\color{red}{j}$ 向结点 $\\color{red}{i}$ 连一条长度为 $c_k$ 的有向边。 若图不是联通的,我们可以设 $dist[0]=0$ 并向每一个点连一条权重为 $0$ 的边。 跑单源最短路若图中存在负环，则给定的差分约束系统无解，否则，$x_i=dist[i]$ 为该差分约束系统的一组解。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,m;struct node{ int to; int val;};vector&lt;node&gt;ro[100005];queue&lt;int&gt;Q;int dis[100005],cnt[100005];bool vis[100005];bool spfa(){/* SPFA板子 */ memset(dis,0x3f3f3f3f,sizeof dis); dis[0]=0,vis[0]=true;Q.push(0); while(Q.size()){ int now = Q.front();Q.pop();vis[now] = false; for(node to:ro[now]){ if(dis[to.to]&gt;dis[now]+to.val){ dis[to.to]=dis[now]+to.val; cnt[to.to]=cnt[now]+1; if(cnt[to.to]&gt;=n+1/* 这个地方狠狠地注意了！！！一定那个要看清楚负环的边界，不能设小了 */)return false; if(!vis[to.to])Q.push(to.to),vis[to.to]=true; } } } return true;}int main(){ n=read(),m=read(); for(int i = 1,u,v,w;i&lt;=m;i++){ u=read(),v=read(),w=read(); ro[v].push_back((node){u,w});//加边，注意方向u-&gt;v } for(int i = 1;i&lt;=n;i++){ ro[0].push_back((node){i,0});//若图不连通，加边，建超级源点 } bool NO_NG_CL = spfa(); if(!NO_NG_CL)cout&lt;&lt;&quot;NO\\n&quot;;//判负环（无解） else{ for(int i = 1;i&lt;=n;i++){ cout&lt;&lt;dis[i]&lt;&lt;&quot; &quot;; } } return 0;}","link":"/posts/8856.html"},{"title":"数学做题笔记","text":"$\\LARGE{\\textbf{01.}}$ $\\textbf{[直线]}$设$\\triangle{ABC}$是以$C$为直角的直角三角形，斜边$AB$的长为$60$,$BC$与$AC$边上的中线所在直线的方程分别为$y=x+3$和$y=2x+4$，则$\\triangle{ABC}$的面积是______。 $\\LARGE{\\textbf{Sol.}}$ 由$\\begin{cases}y = x+3 &amp; \\ y = 2x+4\\end{cases}$得$\\triangle{ABC}$的重心是$G(-1,2)$. 设$A(a,a+3)$，$B(b,2b+4)$. $$\\therefore S_{\\triangle{ABC}} = 3S_{\\triangle{GAB}} = \\frac{3}{2}|GA| \\cdot |GB|\\sin{\\angle{AGB}} = \\frac{3}{2}\\sqrt{2}|-1-a|\\sqrt{5}|b+1|\\cdot \\frac{1}{\\sqrt{10}}=\\frac{3}{2}|(a+1)(b+1)|$$ $$\\color{CornflowerBlue}{\\because S_{\\triangle{ABC}} = 3 \\cdot \\frac{1}{2} \\cdot \\begin{vmatrix}a &amp; a+3&amp; 1 \\ -1 &amp; 2 &amp; 1\\b &amp; 2b+4 &amp; 1\\end{vmatrix} = \\frac{\\beta}{2}|(a+1)(b+1)|}$$ 由$|AB|=60,|GF|=\\frac{1}{3}|CF|=10$得$\\begin{cases}(a-b)^2+(a-2b-1)^2=3600 &amp; \\ (-1-\\frac{a+b}{2})^2+(2-\\frac{a+2b+7}{2})^2=100\\end{cases}$即$(a+b+2)^2+(a+2b+3)^2=400$ 令$s=a+1,t=b+1$，则$a=s-1,b=t-1$且$\\begin{cases}(s-t)^2+(s-2t)^2=2s^2-6st+5t^2=3600 &amp; \\ (s+t)^2+(s+2t)^2=2s^2+6st+5t^2=400\\end{cases}$ 得$3st=800$，$\\therefore S_\\triangle{ABC} = 400$","link":"/posts/33984.html"},{"title":"数论比赛笔记","text":"T1$k=1$ 时候$p_i = i$, $p_i \\neq i, p_{p_i} = i$. $f_n$ 表示 $n$ 的答案。 $p_1 = 1$, $f_{n - 1}$ $p_1 = i \\neq 1$. $p_i = 1$. $(n-1)f_{n-2}$. $$f_n = f_{n-1} + (n-1)f_{n-2}.$$ $O(n)$ $k$ 任意$f_n$ 表示答案 从 $1$ 出发，走若干步回到 $1$，步数一定是 $2^k$ 的因数。 枚举这个因数。之后要知道中间路过了哪些点。 T2$\\gcd(n, m) = 1$$b_j$ 可以对应到哪些 $a_i$:$j \\bmod n, (j + m) \\bmod n, (j + 2m) \\bmod n, \\dots$ 恰好可以遍历所有的 $i$ (按一定顺序） 无论从哪个 $j$ 开始，如果这一步匹配到了 $i$，下一步一定会匹配到 $(i + m) \\bmod n$. 把 $a$ 重新排序： $a_1, a_{1 + m}, a_{1 + 2m}, a_{1 + 3m}, \\dots$. $c_k = a_{1 + (k-1)m}$ $c$ 也以 $n$ 为周期。如果 $j$ 第一步匹配到 $c_u$, 之后就会匹配到 $c_{u+1},c_{u+2},\\dots$.也就是若干个周期加上单个周期内的一个区间。 相当问：对每个 $j$, 对应的区间内有多少个 $c_i$ 比 $b_j$ 小。 离散化，扫描，树状数组维护区间和 $\\gcd$ 不一定是 $1$这时候设 $d = \\gcd(n, m)$ 可以发现只有在 $i \\equiv j \\pmod d$ 的时候他们两个才会匹配上。 所以我们按 ${}\\bmod d$ 分组，每组分别做。就可以了。 T3二分答案 之后只需要判断是否存在 k 条白色边的生成树。 只需要求出白色边最多/最少多少条。 性质：假设有一张图，有两个森林 $S, T$，如果 $S$ 的边数少于 $T$ 的边数，那么一定可以从 $T$ 里选出一条边加到 $S$ 里，还是森林。 T4$(1, a^{\\varphi(m)} \\bmod m)$ 记 $g_m(a)$ 表示有多少个 $n$ 使得 … $g_m(a) = g_m(\\gcd(a, m)).$ $a = dx, m = dy$ $a^n \\bmod m = d^nx^n \\bmod dy$$=d\\bigl(d^{n-1}x^n \\bmod y\\bigr)$ $x$ 和 $y$ 是互质的。所以说 $x \\bmod y$ 满足欧拉定理。并且因为互质 如果 $u, v$ 互质，$ux \\equiv uy \\pmod v$ 当且仅当 $x \\equiv y \\pmod v$. 也就是说 $g_m(a) = g_m(d)$. 进一步$g_m(d)$ 怎么计算。 $u_k = \\gcd(d^k, m)$.$u_0 &lt; u_1 &lt; \\dots &lt; u_s = u_{s+1} = u_{s+2} = \\dots$. 断言：$g_m(d) = s$。也就是说 $d^n \\not\\equiv d^{n + \\varphi(m)}$ 当且仅当 $n &lt; s$. 如果 $n &lt; s$. 那么 $\\gcd(d^n, m) \\neq \\gcd(d^{n + \\varphi(m)}, m)$. 那么 $(d, n)$ 肯定是合法的对。 如果 $n \\geqslant s$.我们要说明 $d^n \\equiv d^{n + \\varphi(m)}$. $$\\begin{aligned}d^n &amp;= u_s \\frac{d^n}{u_s} \\d^n \\bmod m &amp;= u_s \\left(\\frac{d^n}{u_s}\\bmod \\frac{m}{u_s}\\right) .\\end{aligned}$$ $d$ 是和 $\\frac{m}{u_s}$ 互质的。所以说后面这个括号里的东西其实都是满足欧拉定理条件的。 因此我们设质因数分解 $$m = \\prod_i p_i^{x_i}, d = \\prod_i p_i^{y_i} \\neq 1.$$ 就可以得到 $$u_k = \\gcd(d^k, m) = \\prod_i p_i^{\\min(x_i. ky_i)}$$ $$g_m(d) = s = \\max\\left(\\bigl\\lceil \\frac{x_i}{y_i} \\bigr\\rceil \\middle| y_i \\neq 0\\right)$$ 使用 DP 计算答案。 对于一个 $m$, 设 $m = p^k l$, $p \\nmid l$. $f_{m,i}$ 表示有多少个 $a$ 使得 $g_m(a) = i$. 考虑：$a = p^v b, p \\nmid b, g_l(b \\bmod l) = j$. 这种情况下 $g_m(a) = s = \\begin{cases}j &amp; v = 0, \\\\max(\\lceil k/v \\rceil, j) &amp; v &gt; 0.\\end{cases}$ 用 $f_{l, j}$ 转移 $f_{m, s}$.转移的系数：给定 $b \\bmod l$ 和 $v$，能选出多少个 $a$ 来。也就是 $\\varphi(p^{k-v})$. $[1, …, p^k l]$ 里面有多少个数 ${}\\bmod (p^v l) = p^v (b \\bmod l)$ 并且和 $v$ 互质. 1234567891011取一个 m 的质因数 pk = 0, l = mwhile l % p == 0: l /= p k++for v &lt;= k for j s = v ? j : max(ceil(k / v), j)); if v &lt; k: f[m][s] += f[l][j] * phi(p^(k-v)); else: f[m][s] += f[l][j] * p^(k-v); 复杂度计算：$q_m$ 表示 $m$ 的质因子次数的最大值。那么复杂度不超过 $O(\\sum q_m^2)$. $O(\\sum_m \\sum x_i^2) = O(\\sum_p \\sum_k (2k+1) \\frac{M}{p^k}) = O(M \\sum_p \\frac{1}{p^2})$ 总复杂度是 $O(m)$. $$\\begin{aligned}&amp;\\sum_{i = 1}^n \\gcd(i, n)\\=&amp;\\sum_{i = 1}^n \\sum_{d \\mid \\gcd(i, d)} \\varphi(d)\\=&amp;\\sum_{d \\mid n} \\varphi(d) \\frac{n}{d}.\\end{aligned}$$ $$ans(p^k) = kp^{k-1}(p-1)+p^k$$ $$2^{2^{2^\\dots}} \\bmod m$$ $$ans(m) = 2^{ans(\\varphi(m)) + \\varphi(m)} \\bmod m.$$","link":"/posts/32218.html"},{"title":"最小表示法","text":"定义 最小表示法是用于解决字符串最小表示问题的方法。 循环同构当字符串 $S$ 中可以选定一个位置 $i$ 满足 $$S[i\\cdots n]+S[1\\cdots i-1]=T$$ 则称 $S$ 与 $T$ 循环同构 最小表示字符串 $S$ 的最小表示为与 $S$ 循环同构的所有字符串中字典序最小的字符串 算法核心考虑对于一对字符串 $A,B$, 它们在原字符串 $S$ 中的起始位置分别为 $i,j$, 且它们的前 $k$ 个字符均相同，即 $$S[i \\cdots i+k-1]=S[j \\cdots j+k-1]$$ 不妨先考虑 $S[i+k]&gt;S[j+k]$ 的情况，我们发现起始位置下标 $l$ 满足 $i\\le l\\le i+k$ 的字符串均不能成为答案。因为对于任意一个字符串 $S_{i+p}$（表示以 $i+p$ 为起始位置的字符串，$p \\in [0, k]$）一定存在字符串 $S_{j+p}$ 比它更优。 所以我们比较时可以跳过下标 $l\\in [i,i+k]$, 直接比较 $S_{i+k+1}$ 这样，我们就完成了对于暴力的优化。 时间复杂度$O(n)$ 过程 初始化指针 $i$ 为 $0$，$j$ 为 $1$；初始化匹配长度 $k$ 为 $0$ 比较第 $k$ 位的大小，根据比较结果跳转相应指针。若跳转后两个指针相同，则随意选一个加一以保证比较的两个字符串不同 重复上述过程，直到比较结束 答案为 $i,j$ 中较小的一个 实现1234567891011121314151617181920int n,a[300005];int main(){ n=read(); for(int i = 0;i&lt; n;i++) a[i]=read(); int i = 0,j = 1,k = 0; while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n){ if(a[(i+k)%n]==a[(j+k)%n])k++; else{ a[(i+k)%n]&gt;a[(j+k)%n]? i=i+k+1:j=j+k+1; if(i==j)i++; k=0; } } i = min(i,j); for(int cnt=1;cnt&lt;=n;cnt++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; i=(i+1)%n; } return 0;}","link":"/posts/15281.html"},{"title":"树链剖分","text":"题目描述如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。 输入格式第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。 接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。 接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。 输出格式输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。 样例 #1样例输入 #1123456789105 5 43 12 45 11 42 43 23 51 24 5 样例输出 #11234544144 提示对于 $30%$ 的数据，$N\\leq 10$，$M\\leq 10$。 对于 $70%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。 对于 $100%$ 的数据，$N\\leq 500000$，$M\\leq 500000$。 样例说明： 该树结构如下： 第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。 第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。 第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。 第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。 第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。 故输出依次为 $4, 4, 1, 4, 4$。 算法分析 模板 此算法需要两次$DFS$ 第一次$DFS$完成找重儿子$son[]$,子树大小$size[]$,深度$depth[]$,父子关系$fa[]$的任务我们不妨令1号结点为树根,进行$DFS$,即可完成 12345678910111213void dfs_1(int u,int f){ fa[u]=f,size[u]=1; depth[u]=depth[f]+1; int t=-1; for(int i = 0;i&lt;ro[u].size();i++){ if(ro[u][i]==f) continue; dfs_1(ro[u][i],u); size[u]+=size[ro[u][i]]; if(size[ro[u][i]]&gt;t){ t=size[ro[u][i]],son[u]=ro[u][i]; } }} 第二次$DFS$,则要处理出每个点其重链所在的链头,以及$DFS$序通过代码及图示可以发现重链剖分的一此性质:通过代码及图示可以发现重链剖分的一些性质: 所有重链互不相交,即每个点只属于一条重链 所有重链长度和等于节点数(链长指链上节点数) 一个点到根节点的路径上经过的边中轻边最多只有log条 前两个性质好理解,那么第三个性质是为什么呢?因为最坏情况就是这个点到根路径上经过的边都是轻边,那么每走一条轻边到达这个点的父节点就代表这个父节点至少还有一个与当前子树同样大的子树,也就是说每走一条轻边走到的点的子树大小就要*2,因此最多只能走$log$次。这也是为什么要选重儿子而不是随便一个儿子的原因。 1234567891011void dfs_2(int u,int f){ top[u]=f; id[u]=++cnt; w[cnt]=b[u]; if(!son[u]) return; dfs_2(son[u],f); for(int i = 0;i&lt;ro[u].size();i++){ if(ro[u][i]==fa[u]||ro[u][i]==son[u])continue; dfs_2(ro[u][i],ro[u][i]); }} 对于求$x,y$的$LCA$,可以每次优先爬点所在重链链头深的点,如果两个点不在同一条重链上,那么直接把链头深的点跳到链头,重复这个过程,直到两个点处在同一条重链上,直接输出深度浅的点就是$LCA$了。因为重链是直接跳到链头,时间复杂度是$O(1)$的,而跳轻边最多就$log$条,因此,求两个点的$LCA$时间复杂度是$O(\\log n)$ 123456int LCA(int x,int y){ while(top[x]!=top[y]){ if(depth[top[x]]&lt;depth[top[y]]) swap(x,y); x=fa[top[x]]; }return depth[x]&lt;depth[y]? x:y;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e6+5;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}vector &lt;int&gt; ro[MAXN];int cnt,fa[MAXN],size[MAXN],depth[MAXN],son[MAXN],top[MAXN],id[MAXN],w[MAXN],b[MAXN];void dfs_1(int u,int f){ fa[u]=f,size[u]=1; depth[u]=depth[f]+1; int t=-1; for(int i = 0;i&lt;ro[u].size();i++){ if(ro[u][i]==f) continue; dfs_1(ro[u][i],u); size[u]+=size[ro[u][i]]; if(size[ro[u][i]]&gt;t){ t=size[ro[u][i]],son[u]=ro[u][i]; } }}void dfs_2(int u,int f){ top[u]=f; id[u]=++cnt; w[cnt]=b[u]; if(!son[u]) return; dfs_2(son[u],f); for(int i = 0;i&lt;ro[u].size();i++){ if(ro[u][i]==fa[u]||ro[u][i]==son[u])continue; dfs_2(ro[u][i],ro[u][i]); }}int LCA(int x,int y){ while(top[x]!=top[y]){ if(depth[top[x]]&lt;depth[top[y]]) swap(x,y); x=fa[top[x]]; }return depth[x]&lt;depth[y]? x:y;}int main(){ int N=read(),M=read(),S=read(),u,v; N--; for(;N--;){ cin&gt;&gt;u&gt;&gt;v; ro[u].push_back(v); ro[v].push_back(u); } dfs_1(S,0); dfs_2(S,S); for(;M--;){ cin&gt;&gt;u&gt;&gt;v; cout&lt;&lt;LCA(u,v)&lt;&lt;endl; } return 0;} .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/posts/40315.html"},{"title":"概率 &amp; 期望","text":"见原博客","link":"/posts/8575.html"},{"title":"欧拉定理&amp;欧拉函数","text":"定义欧拉函数$\\phi$(Euler’s totient function),$\\phi(n)$定义为$[1,n]$中与$n$互质的数的个数。欧拉定理: $a^{2\\phi(n)}\\equiv a^{\\phi(n)}\\pmod n$ 性质 $a^{\\phi(p)} \\equiv 1\\pmod p$要求$a$与$p$互质; 设$\\phi(x)=\\prod_{p_i}^{k_i}$,那么$\\phi(x)=\\prod (1-\\frac{1}{p_i})=\\prod(p_i-1)_{p_i}^{k_1-1}$; $\\phi(\\mathsf{质数}x)=x-1$;$\\phi(\\mathsf{互质}x \\times y)=\\phi(x)\\times \\phi(y)$;$\\phi(\\mathsf{质数 }x\\mathsf{ 是y的因子} \\times y)=x \\times \\phi(y)$; 欧拉函数是积性函数:若$(a,b)=1$,则$\\phi(ab)=\\phi(a)\\phi(b)$ 设$p$为$n$的一个质因子，$k$为$p$的次数，则有$\\phi(n) \\geq k$成立 证明：设$n=p^k \\times t$，那么 $\\phi(n)=\\phi(p^k)\\phi(t) \\geq \\phi(p^k) \\geq k$ 计算 一种基于质因数分解求欧拉函数的算法(求单个$\\phi$)123456789101112int phi(int x){ int ret = x; int t=sqrt(x); for(int i =2;i&lt;=t;i++){ if(x%i==0){ while(x%i==0)x/=i; ret = ret / i * (i - 1); } } if(x&gt;1) ret=ret/x*(x-1); return ret;} 线性筛欧拉函数123456789101112131415161718192021222324252627282930const int N = 1e6 + 10;int n, cnt;//cnt标记素数个数int phi[N];//存每个数的欧拉函数int prim[N];//存放素数bool vis[N];//判断是不是素数int ans;int getphi(int n){ phi[1] = 1; for(int i = 2; i &lt;= n; i++){ if( !vis[i] ){ prim[++cnt] = i; phi[i] = i - 1; } for(int j = 1; j &lt;= cnt; j++){ if(i * prim[j] &gt; n) break; vis[i * prim[j]] = true; if(i % prim[j] == 0){ phi[i * prim[j]] = prim[j] * phi[i];break; } else{ phi[i * prim[j]] = phi[i] * (prim[j] - 1); } } } for(int i = 1; i &lt;= n; i++){ ans += phi[i]; } return ans;} 应用用欧拉定理求逆元：$a \\times a^{\\phi(n)-1} \\equiv 1 \\pmod n$;特别的，若$n$为质数：$a \\times a^{n-2} \\equiv 1 \\pmod n$快速幂即可 123456789int powermod(int a, int b, int n){ int ret = 1; while(b){ if(b &amp; 1) ret=(long long)ret*a%n; a=(long long)a*a%n; b&gt;&gt;=1; } return ret;}","link":"/posts/13596.html"},{"title":"求第K小值&amp;中位数法","text":"题目描述 给定两个整型数组$A,B$，长度分别为$n,m$，且均为单调不下降序列。给定整数$k$，求出第$k$小值。 输入格式第一行三个整数，分别表示$n,m,k$;第二行$n$个整数，表示数组$A_i$;第二行$m$个整数，表示数组$B_i$. 输出格式一个整数表示第$k$小值. 样例1234 6 81 3 6 70 2 4 5 9 11 17 提示$1 \\leq n,m \\leq 10^7,1 \\leq k \\leq m+n, 0 \\leq A_i,B_i&lt;2^{64}-1$ Sol.1 双指针扫描时间复杂度$O(n)$ 不赘述 Sol.2 中位数BFPRT时间复杂度$O(\\log n)$ BFPRT 求有序数组中位数可以通过递归求解计算，时间复杂度$O(\\log n)$ 比如，我们有如下长度为$10$(偶数)的两个有序数组$a,b$： 我们取每个数组中位数进行比较 若$A[mid]&gt;B[mid]$,那么，显然中位数不会出现在标黄色区域 那么我们只需要在蓝色区间内查找中位数 此时我们有如下长度为$5$(奇数)的两个有序数组$a,b$： 若$A[mid]&lt;B[mid]$,那么，显然中位数不会出现在标黄色区域 但是当我们去掉不可能的部分后，剩下的部分长度不等 此时我们可以把$A[mid]$与$B[mid-1]$比较 若$A[mid] \\geq B[mid-1]$那么可以断定$A[mid]$就是中位数 若$A[mid] &lt; B[mid-1]$ ,那么继续递归转到下一次寻找中位数 直到最后每个数组只剩$1$个数，返回其中较小值即可 在本例中，中位数为$7$. 若上述某一步奇偶性或大小表示不同，那么相反操作即可 12345678910111213141516int dfs(int sa,int ea,int sb,int eb){ if(sa==ea)return min(a[sa],b[sb]);//终止条件 int ma=(sa+ea)&gt;&gt;1,mb=(sb+eb)&gt;&gt;1; //数组a,b的中间位置 bool ji=(ea-sa+1)&amp;1; //判断奇偶 if(a[ma]&gt;b[mb]){ if(ji){ if(b[mb]&gt;=a[ma-1]) return b[mb]; else return dfs(sa,ma-1,mb+1,eb); }else return dfs(sa,ma,mb+1,eb); }else{ if(ji){ if(a[ma]&gt;=b[mb-1]) return a[ma]; else return dfs(ma+1,ea,sb,mb-1); }else return dfs(ma+1,ea,sb,mb); }} 利用BFPRT求第K小值如给定如下有序数组$a,b$ 长度分别为$n=6,m=10$ 对于给定的$K$，分三种讨论 $K \\leq \\min(n,m)$ $\\min(n,m) \\leq K \\leq \\max(n,m)$ $\\max(n,m) \\leq K$ 对于第一种，若$K=4$，我们只需要对$a[1 \\to K],b[1 \\to K]$进行求中位数即可 即$2$ 123int solve1(){ return dfs(1,k,1,k);} 对于第二种，若$K=8$ 因为在本例中$n&lt;m$,我们需要对$b[K-n]$特判(若$n&gt;m$则交换$a,b$) 若$b[K-n] \\geq a[n]$,那么$b[K-n]$就是第$K$小值 若$b[K-n] &lt; a[n]$,那么对$a[1 \\to n],b[K-n+1 \\to K]$进行求中位数即可 即$6$ 123456789int solve2(){ if(n&lt;m){ if(b[k-n]&gt;=a[n]) return b[k-n]; else return dfs(1,n,k+1-n,k); }else{ if(a[k-m]&gt;=b[m]) return a[k-m]; else return dfs(k+1-m,k,1,m); }} 对于第三种，若$K=12$ 我们需要对$b[K-n]，a[K-m]$特判 若$b[K-n] \\geq a[n]$,那么$b[K-n]$就是第$K$小值 若$a[K-m] \\geq b[n]$,那么$a[K-m]$就是第$K$小值 若$b[K-n] &lt; a[n] \\And a[K-m] &lt; b[n]$,那么对$a[K-m+1 \\to n],b[K-n+1 \\to m]$进行求中位数即可 即$9$ 12345int solve3(){ if(a[k-m]&gt;=b[m]) return a[k-m]; else if(b[k-n]&gt;=a[n]) return b[k-n]; else return dfs(k+1-m,n,k+1-n,m);} 总体时间复杂度全部在BFPRT求中位数上，复杂度为$O(\\log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#define min(x,y) ((x)&gt;(y)?(y):(x))#define max(x,y) ((x)&lt;(y)?(y):(x))using namespace std;inline long long read(){ long long x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}long long n,m,k,a[10000005],b[10000005];long long dfs(long long sa,long long ea,long long sb,long long eb){ if(sa==ea)return min(a[sa],b[sb]); long long ma=(sa+ea)&gt;&gt;1,mb=(sb+eb)&gt;&gt;1; bool ji=(ea-sa+1)&amp;1; if(a[ma]&gt;b[mb]){ if(ji){ if(b[mb]&gt;=a[ma-1]){ return b[mb]; }else{ return dfs(sa,ma-1,mb+1,eb); } }else{ return dfs(sa,ma,mb+1,eb); } }else{ if(ji){ if(a[ma]&gt;=b[mb-1]){ return a[ma]; }else{ return dfs(ma+1,ea,sb,mb-1); } }else{ return dfs(ma+1,ea,sb,mb); } }}void solve1(){ cout&lt;&lt;dfs(1,k,1,k);}void solve2(){ if(n&lt;m){ if(b[k-n]&gt;=a[n]) cout&lt;&lt;b[k-n]; else cout&lt;&lt;dfs(1,n,k+1-n,k); }else{ if(a[k-m]&gt;=b[m]) cout&lt;&lt;a[k-m]; else cout&lt;&lt;dfs(k+1-m,k,1,m); }}void solve3(){ if(a[k-m]&gt;=b[m]) cout&lt;&lt;a[k-m]; else if(b[k-n]&gt;=a[n]) cout&lt;&lt;b[k-n]; else cout&lt;&lt;dfs(k+1-m,n,k+1-n,m);}int main(){ n=read(),m=read(),k=read(); for(long long i = 1;i&lt;=n;i++) a[i]=read(); for(long long i = 1;i&lt;=m;i++) b[i]=read(); long long minn=min(n,m),maxn=max(n,m); if(k&lt;=minn) solve1(); else if(k&gt;minn &amp;&amp; k&lt;=maxn) solve2(); else solve3();}","link":"/posts/17749.html"},{"title":"点分治","text":"例题题目描述给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。 输入格式第一行两个数 $n,m$。 第 $2$ 到第 $n$ 行，每行三个整数 $u, v, w$，代表树上存在一条连接 $u$ 和 $v$ 边权为 $w$ 的路径。 接下来 $m$ 行，每行一个整数 $k$，代表一次询问。 输出格式对于每次询问输出一行一个字符串代表答案，存在输出 AYE，否则输出 NAY。 样例 #1样例输入 #11232 11 2 22 样例输出 #11AYE 数据规模与约定 对于 $30%$ 的数据，保证 $n\\leq 100$。 对于 $60%$ 的数据，保证 $n\\leq 1000$，$m\\leq 50$ 。 对于 $100%$ 的数据，保证 $1 \\leq n\\leq 10^4$，$1 \\leq m\\leq 100$，$1 \\leq k \\leq 10^7$，$1 \\leq u, v \\leq n$，$1 \\leq w \\leq 10^4$。 算法分析 模板 基本思想点分治，顾名思义就是基于树上的节点进行分治。如果我们在深入一点呢？对于点的拆开其实就是对于树的拆开。所以我认为点分治的本质其实是将一棵树拆分成许多棵子树处理，并不断进行。这应该也是点分治的精髓。既然我们要将一个点进行分治，那么选点肯定最首要的。思考下面一个问题：如果树退化为一个链，我们选取链首作为分治点，理论时间复杂度？而如果选择链的中心，它的理论时间复杂度又是多少？选择链首：$O(n)$选择链心：$O(\\log n)$通过这个例子,我们不难发现：如果选点后左右子树越大，递归层数越多，时间越慢，反之则越快。所以我们的选点标准就出来了，而我们把有这个性质的点叫做：树的重心！ 求解树的重心1234567891011121314void getroot(int now,int fa){ tree[now].size=1,tree[now].mx=0; //初始化当前树 for(auto i : tree[now].to){ //遍历每棵子树 if(i.to==fa || tree[i.to].usd) continue; //特判，防止死循环 getroot(i.to,now); //递归查找根 tree[now].size+=tree[i.to].size; //重新计算子树大小 tree[now].mx=max(tree[now].mx,tree[i.to].size); //找出最大子树 } tree[now].mx=max(tree[now].mx,tree[0].mx-tree[now].size); /*此处 tree[0].mx-tree[now].size 因为父节点也有大小；因此要将父节点算入 */ if(tree[now].mx&lt;tree[root].mx) root=now; //优化选根} 分治中心算法123456789101112void divid(int now){ calc(now); tree[now].usd=true; for(auto i : tree[now].to){ if(!tree[i.to].usd){ root=0; tree[0].mx=tree[i.to].size; getroot(i.to,0),getroot(root,0); divid(root); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;inline int read(){ int x=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48); return x*f;}int n,m,d[26005],hav[10000005],cnt=0;int ans[26005];struct ro{ int to; int val;};struct node{ vector &lt;ro&gt; to; int size; int dis; int mx; bool usd;}tree[50005];int root;void getroot(int now,int fa){ tree[now].size=1,tree[now].mx=0; for(auto i : tree[now].to){ if(i.to==fa || tree[i.to].usd) continue; getroot(i.to,now); tree[now].size+=tree[i.to].size; tree[now].mx=max(tree[now].mx,tree[i.to].size); } tree[now].mx=max(tree[now].mx,tree[0].mx-tree[now].size); if(tree[now].mx&lt;tree[root].mx) root=now;}void getdis(int now,int fa){ d[++cnt]=tree[now].dis; for(auto i : tree[now].to){ if(i.to==fa||tree[i.to].usd) continue; tree[i.to].dis=tree[now].dis+i.val; getdis(i.to,now); }}void calc(int now){ hav[0]=1; vector&lt;int&gt;v; for(auto i : tree[now].to){ if(tree[i.to].usd)continue; cnt=0; tree[i.to].dis=i.val; getdis(i.to,now); for(int j = 1;j&lt;=cnt;j++){ for(int k = 1;k&lt;=m;k++){ if(k&gt;=d[j]) ans[k] |=hav[k-d[j]]; } } for(int j = 1;j&lt;=cnt;j++){ if(d[j]&lt;=1e7){ hav[d[j]] =1; v.push_back(d[j]); } } } for(auto i:v){ hav[i]=0; }}void divid(int now){ calc(now); tree[now].usd=true; for(auto i : tree[now].to){ if(!tree[i.to].usd){ root=0; tree[0].mx=tree[i.to].size; getroot(i.to,0),getroot(root,0); divid(root); } }}int main(){ n=read(); int u,v,w; for(int i = 1;i&lt;n;i++){ u=read(),v=read(),w=read(); tree[u].to.push_back((ro){v,w}); tree[v].to.push_back((ro){u,w}); } m=read(); tree[0].mx=n; getroot(1,0),getroot(root,0); divid(root); long long sum=0; for(int i = 1;i&lt;=m;i++) sum+=ans[i]; cout&lt;&lt;sum; return 0;} .content .tabs ul { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/posts/49220.html"},{"title":"洛谷2022七月月赛","text":"A题目描述15B03 的座位非常拥挤，可以看成一张 $n\\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。 根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 公共点。严格定义两张桌子 $(i, j)$ 和 $(i’, j’)$ 相邻当且仅当 $|i - i’|\\leq 1$ 且 $|j - j’|\\leq 1$。 布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。 小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 欧几里得 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。 平行时空中 15B03 的规模不尽相同：多组测试数据。 数据范围 测试点 #1（15 points）：$n, m$ 均为奇数。 测试点 #2（20 points）：$n = 1$。 测试点 #3（25 points）：$n = 2$。 测试点 #4（30 points）：$n$ 为奇数。依赖测试点 #1，#2。 测试点 #5（10 points）：无特殊限制。依赖测试点 #3，#4。 对于 $100%$ 的数据： $1\\leq T\\leq 57$。 $1\\leq n, m\\leq 1064$。 Sol第一问的答案是 $\\left\\lceil \\dfrac {n + 1} 2 \\right\\rceil\\left\\lceil \\dfrac {m + 1} 2 \\right\\rceil$。选择奇数行和奇数列的所有交点，可以使得每个 $2\\times 2$ 的小正方形 $(2k - 1 / 2k, 2k - 1 / 2k)$ 都存在一个格子被选。当 $n$ 或 $m$ 是奇数时，边界处小正方形不满。这种讨论是平凡的。 这样的构造是上界，因为每个小正方形至多选出一个格子。 对于第二问，我们有如下构造：若横坐标为奇数则横坐标固定，若为偶数则当 $\\leq \\dfrac n 2$ 时选奇数行，否则选偶数行。对于纵坐标同理。这样，四个角均被占用，并且每个位置都取到了它所能贡献的最大值。证明方法是观察到每个 $2\\times 2$ 的小正方形 $(2k - 1 / 2k, 2k - 1 / 2k)$ 当中只能恰好放一个，而恰好放的这一个取到了贡献的最大值，具体证明细节略去。 需要特判 $n = 2$ 或 $m = 2$ 的情况。 根据构造算答案即可，时间复杂度 $\\mathcal{O}(nm)$。 据验题人反应，第二问难度较大。我们给第一问 $80$ 分以达到送分的目的。 参考代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#include &lt;quadmath.h&gt;using namespace std;bool Mbe;bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif int S, T; cin &gt;&gt; S &gt;&gt; T; while(T--) { int n, m; double ans = 0; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; n * m - (n + 1 &gt;&gt; 1) * (m + 1 &gt;&gt; 1) &lt;&lt; &quot; &quot;; if(n &gt; 2 || m &gt; 2) { if(m == 2) swap(n, m); for(int i = 1; i &lt;= n + 1 &gt;&gt; 1; i++) for(int j = 1; j &lt;= m + 1 &gt;&gt; 1; j++) { int x = i * 2 - 1, y = j * 2 - 1; if(n % 2 == 0 &amp;&amp; x &gt; n / 2) x++; if(m % 2 == 0 &amp;&amp; y &gt; m / 2) y++; int dx = max(x - 1, n - x); int dy = max(y - 1, m - y); ans += sqrt(dx * dx + dy * dy); } } printf(&quot;%.10lf\\n&quot;, ans); } return 0;} B题目描述小 A 有 $n$ 个 $2$ 的幂 $a_1, a_2, \\cdots, a_n$。他要在这些数之间插入 $x$ 个异或运算符和 $y$ 个或运算符，组成一个表达式。保证 $x + y = n - 1$。 表达式越大，越有可能炸掉小 T 的博客。小 A 希望 从左往右 计算表达式时它的值最大。他想知道表达式最大可能的取值是多少，用二进制表示。他还希望你构造出这样的表达式，因为他懒得自己构造了。 若存在多组构造方案，输出任意一组。 多组测试数据。 数据范围 测试点 #1（10 points）：所有 $b_i$ 互不相等。 测试点 #2（20 points）：所有 $b_i$ 相等。 测试点 #3（30 points）：$n \\leq 8$。 测试点 #4（25 points）：$n \\leq 10 ^ 3$。依赖测试点 #3。 测试点 #5（15 points）：无特殊限制。依赖测试点 #1，#2，#4。 对于 $100%$ 的数据： $1\\leq T\\leq 20$。 $1 \\leq n \\leq 2.5 \\times 10 ^ 4$。 $0 \\leq x, y &lt; n$，$x + y = n - 1$。 $1\\leq a_i &lt; 2 ^ {2 ^ {2 ^ {2 ^ 2}}}$，即 $0\\leq b_i &lt; 65536$。 Sol核心观察：或比异或更厉害。无论之前结果如何，只要在最后一次出现之前放上或就能让这一位变成 $1$。 对每个出现偶数次的位，在最后分配一个或就能变为 $1$。而出现奇数次的位就算不分配也是 $1$​。 按位从大到小贪心，时间复杂度 $\\mathcal{O}(n + V)$。 构造方案：在选择分配或的位的最后一次出现之前放上或。对于多于的或，从后往前填入所有空隙，容易发现不影响答案。剩余空隙放入异或。 参考代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;bool Mbe;constexpr int N = 2.5e4 + 5;constexpr int W = 1 &lt;&lt; 16;int n, x, y, a[N], op[N];int buc[W], ans[W], lst[W];bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif int S, T; cin &gt;&gt; S &gt;&gt; T; while(T--) { memset(op, 0, sizeof(op)); memset(buc, 0, sizeof(buc)); memset(ans, 0, sizeof(ans)); cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], buc[a[i]]++, lst[a[i]] = i; for(int i = W - 1; ~i; i--) if(buc[i] &amp; 1) ans[i] = 1; else if(y &amp;&amp; buc[i]) ans[i] = op[lst[i]] = 1, y--; for(int i = n; y; i--) if(!op[i]) op[i] = 1, y--; bool flag = 0; for(int i = W - 1; ~i; i--) if(ans[i] || flag) cout &lt;&lt; ans[i], flag = 1; if(!flag) cout &lt;&lt; '0'; cout &lt;&lt; '\\n'; for(int i = 2; i &lt;= n; i++) cout &lt;&lt; (op[i] ? '|' : '^'); cout &lt;&lt; '\\n'; } return 0;} C题目描述小 A 一共有 $n$ 道题目没有补。评估后，他认为第 $i$ 题的难度为 $x_i$。 同时，他对自己的水平有评估值 $w$。他的水平会波动，因此 $w$ 会改变。 小 A 认为补难度和自己水平相近的题目（相差不超过 $b_1$）能带来收益 $inc$；相反，如果相差过大（相差超过 $b_2$）则浪费了时间，导致负收益 $dec$。因此，补第 $i$ 道题的收益为 $$\\begin{cases}inc &amp; |x_i - w| \\leq b_1 \\0 &amp; b_1 &lt; |x_i - w| \\leq b_2 \\dec &amp; |x_i - w| &gt; b_2 \\\\end{cases}$$ 保证 $b_1 \\leq b_2$ 且 $dec &lt; 0 &lt; inc$。 此外，小 A 有一些喜欢和讨厌的题。如果他没有补任何喜欢的题，或补了任何讨厌的题，就会不高兴。 小 A 将选择一段编号连续的题目进行补题。他希望补每道题的收益之和最大，并且补完题目后不会不高兴。请你告诉他这个最大值。 数据范围 Subtask #1（7 points）：$n, q\\leq 100$。 Subtask #2（12 points）：$n, q\\leq 500$。依赖 Subtask #1。 Subtask #3（20 points）：$n, q\\leq 4 \\times 10 ^ 3$。依赖 Subtask #2。 Subtask #4（25 points）：$w, x_i \\leq 100$。 Subtask #5（11 points）：$l = 1$，$h = 0$。 Subtask #6（15 points）：$w, x_i \\leq 10 ^ 5$。依赖 Subtask #4。 Subtask #7（10 points）：无特殊限制。依赖 Subtask #3，#5，#6。 对于 $100%$ 的数据： $1\\leq n, q \\leq 10 ^ 5$。 $0\\leq w, x_i \\leq 10 ^ 9$，$0\\leq b_1 \\leq b_2$ 且 $b_2$ 不大于 $w, x_i$ 上界的一半。 $-10 ^ 4 \\leq dec &lt; 0 &lt; inc \\leq 10 ^ 4$。 $1\\leq l, il_i, ih_j \\leq n$，$0 \\leq h &lt; n$，$l + h\\leq 5$。 保证 $il$，$ih$ 递增，且一组询问每个下标至多出现一次。 Sol 1考虑 $n, q \\leq 500$。 容易发现，讨厌的题将序列割成若干连续段。连续段之间独立，因此单独考虑一个连续段。 对于当前区间 $[l, r]$，枚举其所有子区间，检查是否有喜欢的题落在其中并更新答案。 时间复杂度 $\\mathcal{O}(n ^ 2q)$。 Sol 2考虑 $n, q \\leq 4\\times 10 ^ 3$。 注意到对于每个位置，合法的右端点形成一段区间 $[l, r)$，从 $p$ 右边第一个喜欢的题 $l$ 开始，第一个讨厌的题 $r$ 结束。 将区间求和差分转化为端点最值，每次改变 $w$ 时暴力重新求前缀和，区间最值用线段树或 ST 表维护。 时间复杂度 $\\mathcal{O}(nq \\log n)$。 Sol 3考虑 $x_i, w \\leq 100$。 回答询问考虑直接枚举包含的喜欢的题，则对应的合法区间左右端点均为一段区间（被讨厌的题所限制）。区间查询前缀和最大最小值即可。 可能的 $w$ 仅有 $100$ 种取值。对每种 $w$ 的取值的对应序列建线段树维护之。 时间复杂度 $\\mathcal{O}(nw + q\\log n)$。 Sol 4考虑正解。 当 $w$ 从 $1$ 增大到 $10 ^ 9$ 时，仅有 $\\mathcal{O}(n)$ 次改变某个位置上的贡献的操作。 单点修改相当于对前缀和区间修改，将所有询问离线回答，用线段树维护区间加法区间最值。 时间复杂度 $\\mathcal{O}(n(l\\log n + h))$，空间复杂度线性。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;bool Mbe;constexpr int N = 1e5 + 5;int S, n, q, w, b1, b2, inc, dec;struct event { int type, x, id, dt; bool operator &lt; (const event &amp;rhs) { if(x != rhs.x) return x &lt; rhs.x; return type &lt; rhs.type; }} c[N * 5];int cnt, ans[N];vector&lt;int&gt; l[N], h[N];int laz[N &lt;&lt; 2], mx[N &lt;&lt; 2], mn[N &lt;&lt; 2];void tag(int x, int v) {laz[x] += v, mx[x] += v, mn[x] += v;}void down(int x) {if(laz[x]) tag(x &lt;&lt; 1, laz[x]), tag(x &lt;&lt; 1 | 1, laz[x]), laz[x] = 0;}void push(int x) { mx[x] = max(mx[x &lt;&lt; 1], mx[x &lt;&lt; 1 | 1]); mn[x] = min(mn[x &lt;&lt; 1], mn[x &lt;&lt; 1 | 1]);}void build(int l, int r, int x) { if(l == r) return mx[x] = mn[x] = ::dec * l, void(); int m = l + r &gt;&gt; 1; build(l, m, x &lt;&lt; 1), build(m + 1, r, x &lt;&lt; 1 | 1); push(x);}void modify(int l, int r, int ql, int qr, int x, int v) { if(ql &lt;= l &amp;&amp; r &lt;= qr) return tag(x, v); int m = l + r &gt;&gt; 1; down(x); if(ql &lt;= m) modify(l, m, ql, qr, x &lt;&lt; 1, v); if(m &lt; qr) modify(m + 1, r, ql, qr, x &lt;&lt; 1 | 1, v); push(x);}int query(int l, int r, int ql, int qr, int x, int type) { int ans = type ? -1e9 : 1e9; if(ql &gt; qr) return ans; if(ql &lt;= l &amp;&amp; r &lt;= qr) return type ? mx[x] : mn[x]; int m = l + r &gt;&gt; 1; down(x); if(ql &lt;= m) ans = query(l, m, ql, qr, x &lt;&lt; 1, type); if(m &lt; qr) { int v = query(m + 1, r, ql, qr, x &lt;&lt; 1 | 1, type); ans = type ? max(ans, v) : min(ans, v); } return ans;}bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif cin &gt;&gt; S; cin &gt;&gt; n &gt;&gt; q &gt;&gt; w &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; inc &gt;&gt; ::dec; for(int i = 1, x; i &lt;= n; i++) { cin &gt;&gt; x; c[++cnt] = {1, x - b2, i, -::dec}; c[++cnt] = {1, x - b1, i, inc}; c[++cnt] = {1, x + b1 + 1, i, -inc}; c[++cnt] = {1, x + b2 + 1, i, ::dec}; } for(int i = 1; i &lt;= q; i++) { int op, L, H, il, ih; cin &gt;&gt; op; if(op == 2) {cin &gt;&gt; w; continue;} cin &gt;&gt; L &gt;&gt; H; while(L--) cin &gt;&gt; il, l[i].push_back(il); while(H--) cin &gt;&gt; ih, h[i].push_back(ih); c[++cnt] = {2, w, i}; } sort(c + 1, c + cnt + 1); build(0, n, 1); for(int i = 1; i &lt;= cnt; i++) { event t = c[i]; if(t.type == 2) { int id = t.id, res = -1e9, lst = 0, pt = 0; h[id].push_back(n + 1); for(int it : l[id]) { while(it &gt; h[id][pt]) lst = h[id][pt++]; res = max(res, query(0, n, it, h[id][pt] - 1, 1, 1) - query(0, n, lst, it - 1, 1, 0)); } ans[id] = res; } else modify(0, n, t.id, n, 1, t.dt); } for(int i = 1; i &lt;= q; i++) if(l[i].size()) printf(&quot;%d\\n&quot;, ans[i]); return 0;} D题目描述以下是简化后的扫雷游戏规则： 定义连通为 八连通。 如果打开雷，所有雷全部爆炸，游戏结束。 如果打开空地，若其周围没有雷，则递归打开周围八个空地。 如图，点开任意红色框内方块均形成当前局面。 给定一张 $n\\times m$ 的初始地图。小 A 决定搜出所有可能的局面，并找到最优鼠标点击顺序，从而速通这张地图。 为设置合适的数组大小，小 A 需要知道有多少种不同局面。对 $998244353$ 取模。 如果方块是雷，它有爆炸和未爆炸两种状态；如果方块是空地，它有打开和未打开两种状态。 两个局面不同，当且仅当存在方块状态不同。 保证周围无雷的空地形成不超过 $37$ 个连通块。 数据范围设周围无雷的空地形成 $d$ 个连通块。 Subtask #1（15 points）：$nm\\leq 21$。 Subtask #2（4 points）：地图中只有一个雷。 Subtask #3（5 points）：$d = 0$。 Subtask #4（6 points）：$d = 1$。 Subtask #5（7 points）：$d = 2$。 Subtask #6（8 points）：$d \\leq 17$。依赖 Subtask #1，#2，#3，#4，#5。 Subtask #7（9 points）：$d \\leq 23$。依赖 Subtask #6。 Subtask #8（16 points）：$d\\leq 27$。依赖 Subtask #7。 Subtask #9（17 points）：$d\\leq 33$。依赖 Subtask #8。 Subtask #10（13 points）：无特殊限制。依赖 Subtask #9。 对于 $100%$ 的数据： $1\\leq n, m\\leq 500$。 $0\\leq d\\leq 37$。 不保证 地图中有雷或空地。 Sol 1考虑 $d = 0$。 称「有雷空地」为周围有雷的空地，「无雷空地」为周围无雷的空地。 地图中没有无雷空地，每个空地的状态独立。设共有 $v$ 个有雷空地，根据乘法原理，答案为 $2 ^ {v + c}$，其中 $c$ 表示是否存在雷。 直接枚举空地及其周围空地求出 $v$，时间复杂度为 $\\mathcal{O}(nm)$。 将不计入雷的局面数乘 $2$ 即可得到计入雷的局面数。 为叙述方便，下文中提到的局面均不计入点到雷的局面。 Sol 2考虑 $d = 1$。 若空地周围存在无雷空地，当无雷空地打开时，该空地也同时打开。空地之间的状态并不独立。 设打开无雷空地形成的连通块将打开 $c$ 个有雷空地。当连通块未打开时，$v$ 个有雷空地的状态独立，有 $2 ^ v$ 种局面；当连通块打开时，$c$ 个有雷空地同时被打开，剩余 $v - c$ 个有雷空地的状态独立，有 $2 ^ {v - c}$ 种局面。 存在初始地图中没有雷的情况，此时答案为 $1$；否则答案为 $2\\times (2 ^ v + 2 ^ {v - c})$。 容易 dfs 求出 $c$，时间复杂度为 $\\mathcal{O}(nm)$。 Sol 3考虑 $d = 2$。 将无雷空地形成的两个八连通块标上序号。设打开第 $i$ 个连通块时打开的有雷空地个数为 $c_i$。 讨论连通块的状态： 若连通块 $1, 2$ 都未打开，共有 $2 ^ v$ 种局面。 若连通块 $1$ 打开，连通块 $2$ 未打开，沿用 $d = 1$ 的做法，共有 $2 ^ {v - c_1}$ 种局面。 同理，若连通块 $2$ 打开，连通块 $1$ 未打开，共有 $2 ^ {v - c_2}$ 种局面。 若连通块 $1, 2$ 都打开，共有 $2 ^ {v - c_1 - c_2}$ 种局面。 分析第四种情况：直接按照这种思路写甚至过不了样例，因为两个连通块可能打开相同的有雷空地。如 $3 \\times 3$ 的网格，左上角和右下角均为雷，则左下角和右上角的两个连通块同时打开中心空地。 设打开两个连通块时打开的相同有雷空地个数为 $e$。 在计算连通块 $1, 2$ 影响到的有雷空地个数时，上述结论多统计了 $e$ 个空地。此时应仅有 $c_1 + c_2 - e_{1, 2}$ 个有雷空地被打开，其余 $v - (c_1 + c_2 - e_{1, 2})$ 个有雷空地的状态独立。 答案为 $2\\times (2 ^ v + 2 ^ {v - c_1} + 2 ^ {v - c_2} + 2 ^ {v - c_1 - c_2 + e})$。 dfs 求出 $c_i$ 与 $e$，时间复杂度为 $\\mathcal{O}(nm)$。 Sol 4考虑 $d \\leq 15$。 设 $e_S$ 表示 恰好 同时被连通块集合 $S$ 打开的有雷空地数，可以 dfs 求出。 枚举打开的连通块集合 $S$，则答案为 $2 \\times \\sum\\limits_{S} 2 ^ {S - \\sum_{T\\subseteq S} e_T}$。 直接枚举子集，时间复杂度 $\\mathcal{O}(nm + 3 ^ d)$。 Sol 5考虑 $d \\leq 21$。 用 FMT 优化上式，时间复杂度 $\\mathcal{O}(nm + d2 ^ d)$。 Sol 6考虑 $d\\leq 26$。 枚举子集的复杂度无法做到更优，考虑挖掘性质。 结论：一个有雷空地至多被两个连通块打开。 证明： 若一个有雷空地同向的两个角落的方块均为无雷空地，则这两个无雷空地一定在同一连通块，因为它们中间的方块是无雷空地。 一个有雷空地的上下和左右两个方块不可能均为无雷空地，否则该有雷空地为无雷空地。 根据上述限制，一个有雷空地最多被三个连通块打开，且其周围状态只能为： 123? 0 ?0 * ?? ? 0 其中 * 表示有雷空地，0 表示无雷空地，? 表示不重要的方块。 根据周围三个无雷空地的限制，中间的有雷空地为无雷空地，矛盾。得证。 因此 $e_S$ 仅在 $|S|\\leq 2$ 处有值。在此基础上得以 $2 ^ d$ 求出 $f_S = \\sum\\limits_{T\\subseteq S} e_T$。 对于 $f_S$，设 $p$ 为 $S$ 中编号最小的连通块，则 $f_S = f_{S \\backslash p} + g_{p, S\\backslash p} + e_$。$p$ 可以 lowbit 求得。 综上，时空复杂度 $\\mathcal{O}(nm + 2 ^ d)$。 进一步地，可以将空间复杂度优化至 $\\mathcal{O}(nm + d ^ 2)$。 时间复杂度仍然是 $\\sum\\limits_{i = 0} ^ {d - 1} 2 ^ i \\times (d - i) \\approx \\mathcal{O}(2 ^ d)$。如果不放心，利用主定理求解 $T(n) = 2T(\\frac n 2) + \\log n$，解得 $T(n) = n$。 Sol 7考虑 $d\\leq 33$。 根据 Sol 6 的结论，将连通块抽象成点，令两个节点之间的权值为它们同时打开的空地数。若 $w(u, v) &gt; 0$ 视 $u, v$ 之间连边。 每次枚举度数最大的节点的两种状态，考虑它对剩余节点的影响，并删掉该点。形成的连通块之间独立，分别暴搜。可以通过本题，但不会分析复杂度的算法不适合当正解。 我们给出优于 $2 ^ d$ 的 确定性 做法： 整张地图是二维平面，所以建出的图 $G$ 是平面图。根据四色定理，$G$ 的最大独立集 $I_{\\max}$ 不小于 $\\left\\lceil \\dfrac d 4\\right\\rceil$。最大独立集可以在 $2 ^ {\\frac d 2}$ 或 $3 ^ {\\frac d 3}$ 的时间内求得，以下做法摘自 pb 的《浅谈信息学竞赛中的独立集问题》学习笔记。 设 $f_S$ 表示点集 $S$ 上的最大独立集，令 $u$ 为 $S$ 中编号最大的节点，有 $f_S = \\max(f_{S\\backslash u}, f_{S\\backslash u \\backslash N(u)} + 1)$。因为前 $\\dfrac d 2$ 层只有 $2 ^ {\\frac d 2}$ 种递归的可能，后 $\\dfrac d 2$ 层 $S$ 中最大节点不超过 $\\dfrac d 2$，所以总共只有 $2 ^ {\\frac d 2}$ 种状态，对这些状态记忆化即可做到 $\\mathcal{O}(2 ^ {\\frac d 2})$。 对 $V\\backslash I_{\\max}$ 做 Sol 6，$I_{\\max}$ 内所有点的状态独立，可以 $\\mathcal{O}(|I|)$ 考虑。 时间复杂度 $\\mathcal{O}(2 ^ {d - I}I)$，空间复杂度 $\\mathcal{O}(nm + d ^ 2)$。 Sol 8考虑正解。 $I$ 中的点一旦独立，即可直接考虑贡献，不需要等到确定 $V\\backslash I$ 所有节点的状态后再计算。因此，令 $I$ 的一个排列 $P = {p_1, p_2, \\cdots, p_k}$ 的代价 $f(P)$ 为 $\\sum\\limits_{i = 1} ^ k2 ^ {|\\cup_{j = 1} ^ iN(p_j)|}$，表示 $I$ 内所有节点以 $P$ 的顺序独立的时间代价：$p_i$ 独立时，$p_1\\sim p_i$ 均独立，需要删去 $\\cup_{j = 1} ^ {i} N(j)$ 内所有节点。 当 $I$ 较小时，枚举其所有排列并求出代价，否则随机足够多的排列使代价尽可能小。 得到最优排列 $P_b$ 后，求出对应删点顺序，并在对应时刻计算 $I$ 内某些节点的代价。 对于 $d = 37$ 而言，$I_{\\max}$ 的最小值为 $10$，此时可以全排列求最小代价。在 $I_{\\max}$ 卡到最小值的图中几乎不可能使得 $\\min f(P)$ 大于 $2\\times 2 ^ {d - I}$（出题人尝试构建这样的图，均无法保证 $I_{\\max} = 10$）。若 $I$ 更大，则 $2 ^ {d - I}$ 变小，随机排列足够优秀。 复杂度可近似看做 $\\mathcal{O}(2 ^ {d - I})$。 本题出题人即笔者。一开始的想法是从 windows 的经典游戏中获取灵感，出了两道月赛 D 难度的题目。一道关于蜘蛛纸牌，已经放在了 SWTR-07，另一道是本题。 本题考察了选手对乘法原理，容斥原理，状压 DP 和随机乱搞的运用能力，以及将问题从实际情境中抽离却不脱离实际情境的能力。本题将 $d$ 优化掉并获得更优时间复杂度的关键结论隐藏在背景当中。 最初正解的复杂度为 $d2 ^ d$，提交审核时，粉兔指出本题有无脑 FMT 做法，大幅拉低本题水准，故撤下。出题人抓住关键性质，不断思考后得到 $2 ^ d$ 做法。同时，出题人认为验题人 chenxia25 给出的 $d ^ 2$ 空间做法具有一定启发性，故二次加强了本题。 进一步地，验题人 asmend 给出复杂度玄学的暴搜做法，出题人实现后发现效率惊人。不仅因为题目的实际意义限制了造出强的数据非常困难，而且 $G$ 是平面图。 对于完全图而言暴搜不可行，但 $G$ 甚至不存在 $K_5$ 和 $K_{3, 3}$，所以暴搜本身复杂度可能就是正确的，加上一点随机化难以卡掉。 出题人请教 EI 后，他指出可以通过删去最大独立集以外的所有顶点实现较多节点的独立。结合平面图四色定理（最大独立集不小于点集的四分之一）与 $2 ^ {\\frac n 2}$ 求解一般图最大独立集，出题人得到本题正解的基本思路。 出题人尝试卡掉暴力无果，实现 Sol 7 后发现速度太慢，无法通过 $d = 37$ 且 $I$ 卡到最小值的数据。尝试优化后得到最终正解。 出题人实现的基于随机化的最优秀暴力需要 2.1s，而 Sol 8 在出题人造出的最劣数据下仅需要 1.6s。因为难以估计 Sol 8 的复杂度上界，所以出题人将时间限制设为 3s。 也许这是第一次四色定理和 $2 ^ {\\frac n 2}$ 最大独立集被应用在正经 OI 题当中。因为这一点，出题人认为本题是一道非常新颖有趣的问题，可惜暴力搜索可以通过。 单论本题正解，其难度堪比 Div.1 C 或 D。出题人将其放在 Div.2 D / Div.1 B 的位置，因为暴力搜索被定位为 intended solution。按照其难度判断，本题放在 2D / 1B 比较合适。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;using namespace std;mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());using ll = long long;bool Mbe;constexpr int N = 500 + 5;constexpr int D = 37 + 5;constexpr int mod = 998244353;constexpr int dx[8] = {-1, 0, 0, 1, -1, -1, 1, 1};constexpr int dy[8] = {0, -1, 1, 0, -1, 1, -1, 1};int S, n, m, cmine, pw2[N * N];int cur, mine, open[D], e[D][D];namespace MAP { int label[N][N]; bool hmine[N][N], vis[N][N]; char mp[N][N]; void dfs_map(int i, int j) { vis[i][j] = 1; for(int dir = 0; dir &lt; 8; dir++) { int x = i + dx[dir], y = j + dy[dir]; if(mp[x][y] != '.') continue; if(hmine[x][y] &amp;&amp; label[x][y] != cur) { if(label[x][y] != -1) e[label[x][y]][cur]++; label[x][y] = cur, open[cur]++; } if(!vis[x][y] &amp;&amp; !hmine[x][y]) dfs_map(x, y); } } void solve() { for(int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, mp[i] + 1); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(mp[i][j] == '.') { for(int dir = 0; dir &lt; 8; dir++) hmine[i][j] |= mp[i + dx[dir]][j + dy[dir]] == '*'; cmine += hmine[i][j]; } else mine = 1; memset(label, -1, sizeof(label)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(mp[i][j] == '.' &amp;&amp; !hmine[i][j] &amp;&amp; !vis[i][j]) dfs_map(i, j), cur++; for(int i = 0; i &lt; cur; i++) for(int j = 0; j &lt; i; j++) e[i][j] = e[j][i]; for(int i = 0; i &lt; cur; i++) for(int j = 0; j &lt; cur; j++) open[i] -= e[i][j]; for(int i = 0; i &lt; cur; i++) cmine -= open[i]; for(int i = 0; i &lt; cur; i++) for(int j = i; j &lt; cur; j++) cmine -= e[i][j]; }}ll ar[D], I;namespace MIS { int f[1 &lt;&lt; 19]; ll get(ll x, ll y) {return __builtin_popcountll(x) &gt; __builtin_popcountll(y) ? x : y;} ll dfs_I(ll S) { if(!S) return 0; int bit = 63 - __builtin_clzll(S); ll x = S ^ (1ll &lt;&lt; bit), y = x ^ (x &amp; ar[bit]); if(S &gt;= (1 &lt;&lt; 19)) return get(dfs_I(x), dfs_I(y) ^ (1ll &lt;&lt; bit)); else { if(f[S] != -1) return f[S]; return f[S] = get(dfs_I(x), dfs_I(y) ^ (1ll &lt;&lt; bit)); } } void solve() { for(int i = 0; i &lt; cur; i++) for(int j = 0; j &lt; cur; j++) if(e[i][j]) ar[i] |= 1ll &lt;&lt; j; memset(f, -1, sizeof(f)); I = dfs_I((1ll &lt;&lt; cur) - 1); }}int limit, mark[D];namespace LAB { int p[D], q[D], best[D], te[D][D], to[D]; void solve() { limit = cur - __builtin_popcountll(I); int cnt = 0, minc = 1 &lt;&lt; 30; for(int i = 0; i &lt; cur; i++) if(I &gt;&gt; i &amp; 1) q[cnt++] = i; int T = 1e6; while(T--) { shuffle(q, q + cnt, rnd); int cost = 0; long long msk = 0; for(int i = 0; i &lt; cnt; i++) { msk |= ar[q[i]]; cost += 1ll &lt;&lt; __builtin_popcountll(msk); } if(cost &lt; minc) { minc = cost; for(int i = 0; i &lt; cnt; i++) best[i] = q[i]; } } int index = 0; long long msk = 0; for(int i = 0; i &lt; cnt; i++) { for(int j = 0; j &lt; cur; j++) if((msk &gt;&gt; j &amp; 1 ^ 1) &amp;&amp; (ar[best[i]] &gt;&gt; j &amp; 1)) p[index] = j, mark[++index] = i; msk |= ar[best[i]]; } for(int i = 0; i &lt; cur; i++) if((msk | I) &gt;&gt; i &amp; 1 ^ 1) p[index] = i, mark[++index] = cnt; for(int i = 1; i &lt;= cnt; i++) p[index++] = best[cnt - i]; for(int i = 0; i &lt; cur; i++) for(int j = 0; j &lt; cur; j++) te[i][j] = e[p[i]][p[j]]; for(int i = 0; i &lt; cur; i++) for(int j = 0; j &lt; cur; j++) e[i][j] = te[i][j]; for(int i = 0; i &lt; cur; i++) to[i] = open[p[i]]; for(int i = 0; i &lt; cur; i++) open[i] = to[i]; }}int dfs_ans(int p) { if(p == limit) { int res = 1; for(int i = p; i &lt; cur - mark[p]; i++) res = 1ll * res * (pw2[open[i]] + 1) % mod; return res; } int res = dfs_ans(p + 1); for(int i = p + 1; i &lt; cur - mark[p + 1]; i++) open[i] += e[p][i]; res = (res + 1ll * pw2[open[p]] * dfs_ans(p + 1)) % mod; for(int i = p + 1; i &lt; cur - mark[p + 1]; i++) open[i] -= e[p][i]; if(mark[p + 1] != mark[p]) for(int x = mark[p] + 1; x &lt;= mark[p + 1]; x++) res = 1ll * res * (pw2[open[cur - x]] + 1) % mod; return res;}bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif cin &gt;&gt; S &gt;&gt; n &gt;&gt; m; for(int i = pw2[0] = 1; i &lt;= n * m; i++) pw2[i] = pw2[i - 1] * 2 % mod; MAP::solve(); MIS::solve(); LAB::solve(); cout &lt;&lt; (mine ? 2ll : 1ll) * dfs_ans(0) * pw2[cmine] % mod &lt;&lt; endl; return 0;} E题目描述给定一张 $n$ 个点，$m$ 条边的无向图。每条边标有 D 或 d。 定义无序点对 $(x, y)$ 是「铁的」，当且仅当 $x \\neq y$ 且 $x, y$ 之间存在同时出现 D 和 d 的简单路径。 小 A 深知自由组合定律 DdTt 的重要性，所以他让你对这样的点对计数。 注意： 简单路径定义为不经过重复 节点 的路径。 保证图无自环，连通，可能有重边。 数据范围 Subtask #1（6 points）：$n \\leq 8$，$m \\leq 21$。 Subtask #2（16 points）：$n\\leq 15$，$m\\leq 822$。依赖 Subtask #1。 Subtask #3（17 points）：$m = n - 1$。 Subtask #4（18 points）：$m = n$。 Subtask #5（19 points）：$n\\leq 1064$，$m\\leq 10 ^ 4$。依赖 Subtask #2。 Subtask #6（24 points）：无特殊限制。依赖 Subtask #3，#4，#5。 对于 $100%$ 的数据： $2\\leq n \\leq 4\\times 10 ^ 5$，$n - 1\\leq m\\leq 10 ^ 6$。 $1\\leq x, y\\leq n$。 $c\\in {\\texttt{D}, \\texttt{d}}$。 保证图无自环，连通，可能有重边。 Sol补集转化变成不存在同时出现 D（1）和 d（0）的简单路径。 如果点对之间不存在出现 $01$ 的路径，只有以下三种情况： 只有 $0$ 路径。 只有 $1$ 路径。 同时有 $0$ 路径和 $1$ 路径。 接下来的推导需多次应用如下基本事实： 性质 1：对于点数 $\\geq 3$ 的点双，任给两点 $x\\neq y$，存在经过 $x, y$ 的简单环。 点双基本性质。若 $x, y$ 不直接相连，由 门杰定理 $k = 2$ 的特殊情形可证。若 $x, y$ 直接相连，若删去 $(x, y)$ 后 $x, y$ 不连通，不妨设 $x$ 所在连通块大小 $\\geq 2$，则 $x$ 为原图割点，矛盾，因此删去 $(x, y)$ 后 $x, y$ 连通，从而得到经过 $x, y$ 的简单环。证毕。 Part 1对于只有 $0$ 路径的情况，考虑点双 $B$，容易猜测若存在 $1$ 边则经过 $B$ 的点对不合法。 性质 2：对于点数 $\\geq 3$ 的点双，任给一点 $x$ 与一边 $e$，存在经过 $x, e$ 的简单环。 证明：将 $e = (u, v)$ 拆成 $(u, w)$ 和 $(w, v)$ 不影响 $B$ 点双连通性。据性质 1，存在经过 $x, w$ 的简单环。因 $w$ 仅与 $u, v$ 相连，故 $(u, w), (w, v)$ 在环上，将其替换为 $(u, v)$ 可得经过 $x, e$ 的简单环。证毕。 不影响点双连通性的证明：删去 $u$ 或 $v$，因 $w$ 与 $v$ 或 $u$ 连通且 $B$ 删去 $u$ 或 $v$ 后连通可知 $u, v$ 不是割点；删去 $u, v, w$ 以外的点时，将 $(u, w)$ 和 $(w, v)$ 视为 $(u, v)$，$B$ 连通；删去 $w$ 相当于删去 $(u, v)$，若图不连通则 $(u, v)$ 在 $B$ 上为割边，当点数 $\\geq 3$ 时 $u$ 或 $v$ 在 $B$ 上为割点，矛盾，故 $B$ 连通。 性质 3：对于点数 $\\geq 3$ 的点双，点双内任给两点 $x\\neq y$ 与一边 $e$，存在 $x \\to e \\to y$ 的简单路径。 证明：由性质 2，存在经过 $x, e$ 的简单环 $C$，若 $y\\in C$ 显然成立，否则令 $P$ 为任意 $y\\to x$ 路径，考虑 $P$ 与 $C$ 的第一个交点 $z$，存在使得 $z \\neq x$ 的 $P$，否则 $x$ 为割点：删去 $x$ 后 $y$ 无法到达 $C$ 剩余节点。令 $Q = y \\to z$ 接上 $z$ 通过环上有 $e$ 的一侧到 $x$ 的路径，则 $Q$ 为 $x \\to e\\to y$ 的简单路径。证毕。 令 $e$ 为 $1$ 边，对点双内任意两点 $x\\neq y$ 应用性质 3，结合 $|B| = 2$ 的平凡情况，可得 结论 1：若点双内存在 $1$ 边，则经过该点双的点对不合法。 因此，删去有 $1$ 边的点双内部所有边，剩余连通块大小选 $2$ 之和即为所求。 对于只有 $1$ 路径的情况同理。 Part 2同时有 $0$ 路径和 $1$ 路径的点对是本题重点，下称「合法点对」。 结论 2：若两点之间存在割点，则不合法。 证明：设 $x, y$ 间存在割点 $z$。考虑 $x\\to z$ 和 $z\\to y$ 的所有路径，它们仅在 $z$ 处相交，否则与 $z$ 为割点矛盾。若同时存在 $0$ 路径 $P_0$ 和 $1$ 路径 $P_1$，将 $P_0$ 在 $x\\to z$ 的部分和 $P_1$ 在 $z\\to y$ 的部分相接得到 $01$ 路径，不合法。证毕。 可以推出合法点对属于相同点双，考虑点双 $B = (V, E)$，感性猜测 $B$ 内部最多有一对合法对，接下来证明这一点。 考虑合法点对 $x, y$。令 $x\\to y$ 所有 $0$ 路径覆盖点集 $V_0$，所有 $1$ 路径覆盖点集 $V_1$。 结论 3.1：除 $x, y$ 以外，$V_0$ 与 $V_1$ 无交。 证明：若有交，则可通过 $P_0$ 与 $P_1$ 第一个交点调整得到 $01$ 路径。证毕。 结论 3.2：$V_0$ 与 $V_1$ 之间无边。 证明：若有边 $u\\to v$ 满足 $u\\in V_0, v\\in V_1$，则 $x\\to u \\to v \\to y$ 为 $01$ 路径。证毕。 性质 4：对于点数 $\\geq 3$ 的点双，任给不同三点 $x, y, z$，存在经过 $x, y, z$ 且以 $x, y$ 为端点的简单路径。 证明：由性质 1，存在经过 $x, z$ 的简单环 $C$，若 $y\\in C$ 显然成立，否则令 $P$ 为任意 $y\\to x$ 路径，考虑 $P$ 与 $C$ 的第一个交点 $u$，存在使得 $u \\neq x$ 的 $P$，否则 $x$ 为割点：删去 $x$ 后 $y$ 无法到达 $C$ 剩余节点。令 $Q = y \\to u$ 接上 $u$ 通过环上有 $z$ 的一侧到 $x$ 的路径，则 $Q$ 为经过 $x, y, z$ 且以 $x, y$ 为端点的简单路径。 证毕。 结论 3.3：$V_0 \\cup V_1 = V$。 证明：对任意 $z\\neq x, y$ 应用性质 4，证毕。 考虑 $z\\in V_0$，$z’\\in V_0$ 且 $(x, y) \\neq (z, z’)$。 结论 4：存在 $x, y$ 分别到 $z, z’$ 或 $z’, z$ 的两条仅经过 $V_0$ 的不交路径。 证明：若 $z$ 或 $z’$ 与 $x$ 或 $y$ 相等，显然。否则考虑仅经过 $V_0$ 的 $x\\to z \\to y$ 的任意 有序 路径 $P$，$x\\to z’ \\to y$ 的任意 有序 路径 $P’$，令它们的交点为 $Q$。若 $z\\in Q$ 或 $z’\\in Q$，可得同时经过 $x, y, z, z’$ 的路径且 $x, y$ 分别在两端，显然。否则将 $Q$ 按照在 $P$ 中的出现顺序标号 $q_1, q_2, \\cdots, q_k$，注意 $x, y\\in Q$。令 $z’$ 两侧与 $z’$ 距离最近的两个交点分别为 $q_i$ 与 $q_j$，则令$$P’’ = x\\xrightarrow{P} q_{\\min(i, j)} \\xrightarrow{P’} z’ \\xrightarrow{P’} q_{\\max(i, j)} \\xrightarrow{P} y$$这样，$P$ 与 $P’’$ 的所有交点按顺序出现，即令 $P$ 与 $P’’$ 的交点为 $Q’$，将 $Q’$ 按照在 $P$ 中的出现顺序标号为 $q_1’, q_2’, \\cdots, q_k’$，则 $P’’$ 上 $Q’$ 出现顺序也为 $q_1’, q_2’, \\cdots, q_k’$。设 $z$ 两侧与 $z$ 距离最近的两个交点分别为 $q_c$ 与 $q_{c + 1}$，$z’$ 为 $q_d$ 与 $q_{d + 1}$。当 $c\\leq d$ 时，令 $P_z = x\\xrightarrow {P} q_c \\xrightarrow{P} z$，$P_{z’} = z’\\xrightarrow{P’} q_{d + 1} \\xrightarrow{P’} y$，合法。当 $c &gt; d$ 时只需反过来构造即可。证毕。 因此，对于任意 $z, z’ \\in V_0 \\land (x, y) \\neq (z, z’) \\land z\\neq z’$，存在 $x, y$ 分别到 $z, z’$ 或 $z’, z$ 的两条仅经过 $V_0$ 的不交路径。将这两条路径通过 $x, y$ 之间的全 $1$ 路径连起来，得 $z, z’$ 之间不合法。 同理，对于任意 $z, z’ \\in V_1 \\land (x, y) \\neq (z, z’) \\land z\\neq z’$，$z, z’$ 之间不合法。 而 $z\\in V_0$，$z’\\in V_1$ 且 $(x, y) \\neq (z, z’)$ 之间显然不合法。 综上，$S$ 内部最多有一对合法对。 考虑充要条件，其等价于点双内恰好存在两个点满足同时有 $01$ 出边。 充分性：考虑令唯二的两个点分别为 $x, y$。根据性质 4，考虑任意 $x\\to u\\to y$，路径必然纯色，否则考虑切换颜色的点，该点同时存在 $01$ 出边。因 $x, y$ 同时有 $0, 1$ 出边，故存在全 $0$ 路径和全 $1$ 路径。 必要性：当 $x, y$ 合法时，根据结论 3.2 可知仅有 $x, y$ 同时有 $01$ 出边。 问题在 $\\mathcal{O}(n + m)$ 的时间内解决。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;bool Mbe;constexpr int N = 1e6 + 5;struct solver { int cnt, hd[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1]; void add(int u, int v) { nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v; nxt[++cnt] = hd[v], hd[v] = cnt, to[cnt] = u; } int sz, vis[N]; void dfs(int id) { vis[id] = 1, sz++; for(int i = hd[id]; i; i = nxt[i]) if(!vis[to[i]]) dfs(to[i]); } long long solve(int n) { long long ans = 0; for(int i = 1; i &lt;= n; i++) if(!vis[i]) { sz = 0, dfs(i); ans += 1ll * sz * (sz - 1) / 2; } return ans; }} D, d;char c[N];int S, n, m, node, u[N], v[N];int dn, dfn[N], low[N], top, stc[N];vector&lt;int&gt; e[N], g[N];void tarjan(int id) { dfn[id] = low[id] = ++dn, stc[++top] = id; for(int it : e[id]) { if(!dfn[it]) { tarjan(it), low[id] = min(low[id], low[it]); if(low[it] &gt;= dfn[id]) { g[++node].push_back(id); g[id].push_back(node); for(int x = 0; x != it; ) { g[node].push_back(x = stc[top--]); g[x].push_back(node); } } } else low[id] = min(low[id], dfn[it]); }}int have[N], fa[N];long long ans;gp_hash_table&lt;int, int&gt; mp[N];void dfs(int id, int ff) { fa[id] = ff; for(int it : g[id]) if(it != ff) dfs(it, id);}bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0); ios::sync_with_stdio(0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif cin &gt;&gt; S &gt;&gt; n &gt;&gt; m, node = n; ans = 1ll * n * (n - 1) / 2; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; c[i]; e[u[i]].push_back(v[i]), e[v[i]].push_back(u[i]); } tarjan(1), dfs(node, 0); auto get = [&amp;](int id, int it) { if(fa[id] == fa[it]) return fa[id]; if(fa[fa[id]] == it) return fa[id]; return fa[it]; }; for(int i = 1; i &lt;= m; i++) { int bcc = get(u[i], v[i]), msk = 1 &lt;&lt; (c[i] == 'D'); mp[bcc][u[i]] |= msk, mp[bcc][v[i]] |= msk; have[bcc] |= msk; } for(int i = 1; i &lt;= m; i++) { int bcc = get(u[i], v[i]); if((have[bcc] &amp; 1) ^ 1) D.add(u[i], v[i]); if((have[bcc] &amp; 2) ^ 2) d.add(u[i], v[i]); } ans -= D.solve(n) + d.solve(n); for(int i = n + 1; i &lt;= node; i++) { int cnt = 0; for(auto it : mp[i]) cnt += it.second == 3; ans -= cnt == 2; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} F题目描述如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层娃的幂塔方程，但他不是。 他想让你求解：$$x ^ x\\equiv D \\pmod n$$ 保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。 你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。 多组测试数据。 数据范围 Subtask #1（5 points）：$n\\leq 20$。 Subtask #2（8 points）：$n\\leq 400$。依赖 Subtask #1。 Subtask #3（11 points）：$n$ 是质数，$T\\leq 10 ^ 4$。 Subtask #4（15 points）：$\\mu(n) \\neq 0$，$T\\leq 100$。 Subtask #5（9 points）：$\\mu(n) \\neq 0$，$T\\leq 10 ^ 4$。依赖 Subtask #4。 Subtask #6（13 points）：$n = p ^ k(p \\in \\mathrm{prime})$，$T\\leq 100$。 Subtask #7（7 points）：$n = p ^ k(p \\in \\mathrm{prime})$，$T\\leq 10 ^ 4$。依赖 Subtask #3，#6。 Subtask #8（6 points）：$m\\leq 1064$。依赖 Subtask #2。 Subtask #9（16 points）：$n\\leq 10 ^ 9$，$T\\leq 10 ^ 4$。 Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。 对于 $100%$ 的数据： $1\\leq T\\leq 4\\times 10 ^ 4$。 $2\\leq n \\leq 10 ^ {18}$。 $1\\leq D &lt; n$，$D\\perp n$。 $2\\leq p_1 &lt; p_2 &lt; \\cdots &lt; p_k \\leq 10 ^ 5$。 Sol 0验题人 chenxia25 给出了一个假做法：将 $n$ 分解质因数，对于每个 $p ^ k$ 可以单独求解。然后 excrt 合并。 问题在于 $p ^ k$ 很大，且 $p ^ k \\times \\varphi(p ^ k)$ 可能不互质，但对于单独求解的 $p ^ k$ 得到的解互质（因为有多解），导致同余方程合并时无解。 Sol 1考虑 $n = p$。 令 $x_1$ 为 $x \\equiv D \\pmod p$ 和 $x \\equiv 1 \\pmod {p - 1}$ 的解，容易发现 $x_1$ 存在。 Sol 2考虑 $n = p ^ k$。 考虑 增量法构造。 设 $x_i ^ {x_i} \\equiv D \\pmod {p ^ i}$。考虑如何 $x_i$ 推到 $x_{i + 1}$。 容易发现令 $x_i \\gets x_i + Ip ^ i(p - 1)$ 仍然可行，因此设 $x_{i + 1} = x_i + Ip ^ i(p - 1)$。 考虑求出 $I$。因为 $x_{i + 1} ^ {x _{i + 1}} \\equiv D \\pmod {p ^ {i + 1}}$，所以 $(x_i + Ip ^ i(p - 1)) ^ {x_i + Ip ^ i(p - 1)} \\equiv D \\pmod {p ^ {i + 1}}$。 因为 $D$ 和 $p ^ i$ 互质，所以 $x_i$ 必然和 $p ^ i$ 互质，所以 $x_i + Ip ^ i(p - 1)$ 和 $p ^ i$ 互质，故和 $p ^ {i + 1}$ 互质。欧拉定理可以用。 因为 $\\varphi(p ^ {i + 1}) = p ^ i(p - 1)$，所以 $Ip ^ i(p - 1)\\equiv 0\\pmod {\\varphi(p ^ {i + 1})}$，因此 $(x_i + Ip ^ i(p - 1)) ^ {x_i} \\equiv D \\pmod {p ^ {i + 1}}$。 这是一个 n 次剩余的形式。但是 $p ^ {i + 1}$ 太大，无法使用 BSGS 求解。 注意到 $Ip ^ i(p - 1)$ 的大于 $1$ 次方 $\\bmod\\ p ^ {i + 1}$ 等于 $0$，考虑 二项式展开。$$(x_i + Ip ^ i(p - 1)) ^ {x_i} \\equiv x_i ^ {x_i} + \\dbinom{x_i} 1 x_i ^ {x_i - 1} \\cdot Ip ^ i(p - 1) \\equiv D \\pmod {p ^ {i + 1}}$$令 $v = x_i ^ {x_i}$，则 $vIp ^ i(p - 1)\\equiv D - v\\pmod {p ^ {i + 1}}$，即 $I\\equiv \\dfrac{D - v}{v p ^ i (p - 1)} \\pmod {p ^ {i + 1}}$。 因为 $v \\equiv D \\pmod {p ^ i}$，所以 $D - v$ 是 $p ^ i$ 的倍数。设 $t = \\dfrac {D - v}{p ^ i}$，则 $I \\equiv \\dfrac t {v(p - 1)} \\pmod p$，显然 $v(p - 1) \\perp p$，因此 $v(p - 1)$ 在模 $p$ 意义下的逆元存在，据此可求出 $I$。 注意到 $I &lt; p$，因此 $I p ^ i (p - 1) &lt; p ^ {i + 1}(p - 1)$，构造出的解远小于 $2 ^ {125}$ 这一上界，算法可行。 时间复杂度约为 $\\mathcal{O}(T\\log m\\log n)$。 Sol 3考虑 $n$ 是 square free number。 考虑 增量法构造。 设 $n$ 的质因子分别为 $p_1, p_2, \\cdots, p_k$，令 $P_i = \\prod\\limits_{j = 1} ^ i p_j$，$Q_i = \\prod\\limits_{j = 1} ^ i (p_j - 1) $。 设 $x_i \\equiv D \\pmod {P_i}$，考虑如何从 $x_i$ 推到 $x_{i + 1}$。 如法炮制，发现令 $x_i \\gets x_i + IP_iQ_i$ 仍然可行，因此设 $x_{i + 1} = x_i + IP_iQ_i$。但是再走二项式展开的老路就行不通了，因为 $P_iQ_i \\not \\equiv 0 \\pmod {\\varphi(P_{i + 1})}$。 怎么办呢？注意到若需保证 $x_{i + 1} ^ {x_{i + 1}} \\equiv D \\pmod {P_{i + 1}}$，因为必然有 $(x_i + IP_iQ_i) ^ {x_i + IP_iQ_i} \\equiv D\\pmod {P_i}$ 且 $P_i \\perp p_{i + 1}$，根据中国剩余定理，只需保证 $(x_i + IP_iQ_i) ^ {x_i + IP_iQ_i} \\equiv D\\pmod {p_{i + 1}}$。发现还是很不好做，因为 $I$ 同时在底数和指数上，而且 $P_iQ_i \\not \\equiv 0 \\pmod {p_{i + 1} - 1}$。 考虑化去指数上的 $I$。 尝试改变定义，令 $x_{i + 1} = x_i + IP_iQ_{i + 1}$，因为 $Q_{i + 1} \\perp p_{i + 1}$，这为接下来寻找逆元奠定基础（如果令 $x_{i + 1} = x_i + IP_{i + 1}Q_{i + 1}$，实际上相当于给 $x_i$ 加上 $x_{i + 1}$ 的循环节 $\\mathrm{lcm}(P_i, \\varphi(P_i))$ 的倍数 $P_{i + 1}Q_{i + 1}$ 的倍数，显然不可行，因为当且仅当 $x_i$ 已经符合要求时我们能找到合法的 $x_{i + 1}$）且 $Q_{i + 1} \\equiv 0 \\pmod {p_{i + 1} - 1}$。 这样一来，上式化简为 $(x_i + IP_iQ_{i + 1}) ^ {x_i} \\equiv D\\pmod {p_{i + 1}}$。求解该 n 次剩余，令 $g$ 为 $p_{i + 1}$ 的任意原根，$g ^ u \\equiv D\\pmod {p_{i + 1}}$，则 $I \\equiv \\dfrac {g ^ {\\frac u {x_i}} - x_i}{P_i Q_{i + 1}} \\pmod {p_{i + 1}}$。 此时出现了一个严重的问题。分子的 $\\dfrac u {x_i}$ 在模 $p_{i +1} - 1$ 意义下求解，但 $x_i$ 和 $p_{i + 1} - 1$ 可能不互质。 尝试修补这个问题。即尝试令 $x_i \\perp p_{i + 1} - 1$。 接下来是一步巧妙转化：令 $x’i \\gets x_i + JP_iQ_i$，使得 $x_i + JP_iQ_i \\perp p{i + 1} - 1$。 但是又出现了问题，即 $P_iQ_i$ 可能和 $p_{i + 1} - 1$ 不互质。 给出引理：若 $a\\perp d$，则对于任意 $n\\geq 2$，存在 $J\\in [0, n - 1]$ 使得 $a + Jd \\perp n$。 证明：将 $n$ 分解质因数成 $\\prod q_i ^ {c_i}$ 的形式。容易证明 $a \\perp q_i ^ {c_i}$ 或 $a + d \\perp q_i ^ {c_i}$。若非，说明 $a$ 和 $d$ 同时含有质因子 $q_i$，与假设矛盾。又因为若 $a + Jd \\perp q_i ^ {c_i}$，显然 $a + (J + kq_i ^ {c_i})d \\perp q_i ^ {c_i}$，即 $J$ 在 $q_i ^ {c_i}$ 模意义下。根据中国剩余定理，得证。 我们发现这是一个递归形式的问题，即若 归纳假设 $x_i \\perp P_iQ_i$，则能找到这样的 $J$ 使得 $x_i + JP_iQ_i \\perp p_{i + 1} - 1$，且上述引理给出了一个求解 $J$ 的方法，即对 $p_i - 1$ 分解质因数并 CRT 合并。而 若条件满足，则结论满足，推出下一轮的条件仍满足：$x’i \\perp p{i + 1} - 1 \\Rightarrow x’i \\perp P_iQ{i + 1} \\Rightarrow x’i + IP_iQ{i + 1} \\perp P_iQ_{i + 1} \\Rightarrow x_{i + 1}\\perp P_iQ_{i + 1}$，又因为 $D\\perp P_{i + 1}$，所以 $x_{i + 1} \\perp P_{i + 1}Q_{i + 1}$。 同时，当在构造第一步时，Sol 2 满足归纳的初始条件，因为 $x_1 \\equiv D \\pmod {p_i}$ 且 $x_1 \\equiv 1 \\pmod {p_1 - 1}$，显然 $x_1\\perp P_1Q_1$。 梳理一下上面的思路，发现添加限制 $x_i \\perp P_iQ_i$ 之后，为了满足该性质所需进行的操作的正确性被该性质所保证，而一开始性质满足，故正确性得以保证。这是归纳法非常巧妙的应用。 这样，我们解决了 $\\dfrac u {x_i}$ 可能无解的问题。 $P_iQ_{i + 1}$ 与 $p_{i + 1}$ 互质，其在模 $p_{i + 1}$ 意义下存在逆元。我们得以算出 $I \\equiv \\dfrac {g ^ {\\frac u {x’i}} - x’i}{P_i Q{i + 1}} \\pmod {p{i + 1}}$，从 $x_i$ 扩展至 $x_{i + 1}$。 时间复杂度约为 $\\mathcal{O}(m ^ {\\frac 5 4} + T\\omega(n)(\\log n + \\sqrt m))$：预处理 $m$ 以内每个质数（约 $\\frac m {\\ln m}$ 个）的原根（单次复杂度 $m ^ {\\frac 1 4} \\log m$）。BSGS 求解离散对数方程时模数非常小，不需要 map 或哈希表，用数组记录即可。 由于 $I, J$ 均为 $p_{i + 1}$ 级别，因此对应的 $\\sum IP_iQ_{i + 1}$ 和 $\\sum JP_iQ_i$ 的一个粗略上界为 $\\omega(n) n ^ 2$，略小于 $2 ^ {125}$ 的限制，符合要求。若担心超出上界，可以令 $x_i$ 对 $P_iQ_i$ 取模。 Sol 4结合 Sol 2 和 Sol 3，从小到大考虑所有质因子。若相邻两个质因子相同，则使用 Sol 2，将对应的 $p ^ i (p - 1)$ 换成 $P_iQ_i$；否则使用 Sol 3 即可。 接下来是一些细节讨论： 在 Sol 2 使用欧拉定理时，需要 $IP_iQ_i \\equiv 0 \\pmod {\\varphi(P_{i + 1})}$。考虑 $P_iQ_i$ 包含 $k$ 个质因子 $p_i$，则 $\\varphi(P_{i + 1})$ 也包含 $k$ 个质因子（根据欧拉定理的计算式可得）。同时，$\\varphi(P_{i + 1})$ 所有形如 $p_j - 1$ 的乘积项被 $Q_i$ 消去，因此上式仍然成立。 在 Sol 2 二项式展开时，需要 $IP_iQ_i$ 的大于 $1$ 次幂是 $P_{i + 1}$ 的倍数。显然成立，因为 $p_i = p_{i + 1}$。 在 Sol 2 求解 $I$ 时，需要 $\\dfrac {D - v}{vP_iQ_i}$ 在模 $P_{i + 1}$ 意义下存在。由于分子，分母和模数均为 $P_i$ 的倍数，因此同除后分母 $vQ_i$ 和 $p_{i + 1}$ 互质，这是因为 $v$ 显然和 $p_i$ 互质，且 $p_{i + 1} = p_i$。 在 Sol 3 中的归纳假设需要在 Sol 2 中满足，因为我们会交替使用 Sol 2 和 Sol 3。因为 Sol 2 的初始条件成立，所以 $x_i \\perp P_iQ_i$。因为 $P_{i + 1}Q_{i + 1}$ 相较于 $P_iQ_i$ 没有增加更多质因子，所以显然 $x_{i + 1}\\perp P_{i + 1}Q_{i + 1}$。 综上，时间复杂度 $\\mathcal{O}(m ^ {\\frac 5 4} + T((\\omega(n) + \\log m)\\log n + \\omega(n) \\sqrt m))$，常数较大。 可以获得 100 分的好成绩。 接下来是一些补充： 在求解 $J$ 时，可以每次给 $x_i$ 加上 $P_iQ_i$ 直到符合要求而非 CRT 求解。因为每次加上 $P_iQ_i$ 可以看做从 $0\\sim p_{i + 1} - 1$ 中随机选一个数，期望随机 $\\dfrac {p_{i + 1} - 1} {\\varphi(p_{i + 1} - 1)} - 1$ 次（初始状态算一次）即可得到与 $p_{i + 1} - 1$ 互质的 $x_i + JP_iQ_i$。 笔者认为本题是一道不可多得的数论好题。尽管其形式简单，但却涉及到了 exgcd 求逆元，CRT 合并同余方程，BSGS 求解离散对数和 n 次剩余问题。归纳法用得恰到好处。整个算法优美而简洁，思维难度极高。没有冗余步骤，只是纯粹的数论。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;bool Mbe;using ll = long long;using i128 = __int128;inline ll read() { ll x = 0; char s = getchar(); while(!isdigit(s)) s = getchar(); while(isdigit(s)) x = x * 10 + s - '0', s = getchar(); return x;}inline void print(i128 x) { if(x &gt;= 10) print(x / 10); putchar(x % 10 + '0');}constexpr int N = 1e5 + 5;constexpr int W = 64;namespace math { ll ksm(ll a, i128 b, ll p) { ll s = 1; while(b) { if(b &amp; 1) s = (i128) s * a % p; a = (i128) a * a % p, b &gt;&gt;= 1; } return s; } i128 gcd(i128 x, i128 y) {return !y ? x : gcd(y, x % y);} void exgcd(int a, int b, int &amp;x, int &amp;y) { if(!b) return x = 1, y = 0, void(); exgcd(b, a % b, y, x), y -= a / b * x; } int inv(int x, int p) { exgcd(x, p, x, *new int); return (x % p + p) % p; } int val[N]; int BSGS(int a, int b, int p) { int A = 1, B = sqrt(p) + 1; for(int i = 0; i &lt; B; i++) { val[1ll * A * b % p] = i; A = 1ll * A * a % p; } for(int i = 1, AA = A; i &lt;= B; i++) { if(val[AA] != -1) { int ans = i * B - val[AA]; for(int i = 0, A = 1; i &lt; B; i++) { val[1ll * A * b % p] = -1; A = 1ll * A * a % p; } return ans; } AA = 1ll * AA * A % p; } return -1; }}int pc, vis[N], pr[N], g[N];void sieve() { for(int i = 2; i &lt; N; i++) { if(!vis[i]) pr[++pc] = i; for(int j = 1; j &lt;= pc &amp;&amp; i * pr[j] &lt; N; j++) { vis[i * pr[j]] = 1; if(i % pr[j] == 0) break; } if(vis[i]) continue; static int pf[N]; int cnt = 0, tmp = i - 1; for(int j = 2; j * j &lt;= tmp; j++) if(tmp % j == 0) { pf[++cnt] = j; while(tmp % j == 0) tmp /= j; } if(tmp &gt; 1) pf[++cnt] = tmp; for(int j = 1; j &lt; i &amp;&amp; !g[i]; j++) { bool ok = 1; for(int k = 1; k &lt;= cnt; k++) ok &amp;= math::ksm(j, (i - 1) / pf[k], i) != 1; if(ok) g[i] = j; } }}i128 ans;ll n, D, P[W], Q[W];int cnt, p[W];void init() { P[0] = Q[0] = 1, cnt = 0; ll tmp = n; while(tmp &gt; 1) { int pf = read(); while(tmp % pf == 0) { p[++cnt] = pf, tmp /= pf; P[cnt] = P[cnt - 1] * pf; Q[cnt] = Q[cnt - 1] * (pf - 1); } } ll M = 1ll * p[1] * (p[1] - 1); ans = (D % p[1] * (p[1] - 1) * (p[1] - 1) + p[1]) % M;}#define mod p[i + 1]void same(int i) { ll v = math::ksm(ans % P[i + 1], ans, P[i + 1]); i128 I = (D - v + P[i + 1]) % P[i + 1] / P[i]; I = I * math::inv(Q[i] % mod * (v % mod) % mod, mod) % mod; ans += I * P[i] * Q[i];}void diff(int i) { i128 prod = (i128) P[i] * Q[i]; while(math::gcd(ans, mod - 1) != 1) ans += prod; prod *= mod - 1; ll u = math::BSGS(g[mod], D % mod, mod); i128 I = math::ksm(g[mod], u * math::inv(ans % (mod - 1), mod - 1), mod); I = (I + mod - ans % mod) * math::inv(prod % mod, mod) % mod; ans += I * prod;}void solve() { n = read(), D = read(), init(); for(int i = 1; i &lt; cnt; i++) { p[i] == p[i + 1] ? same(i) : diff(i); ans %= (i128) P[i + 1] * Q[i + 1]; } print(ans), putchar('\\n');}bool Med;int main() { fprintf(stderr, &quot;%.3lf\\n&quot;, (&amp;Mbe - &amp;Med) / 1048576.0);#ifdef ALEX_WEI freopen(&quot;0.in&quot;, &quot;r&quot;, stdin); freopen(&quot;0.out&quot;, &quot;w&quot;, stdout);#endif sieve(); memset(math::val, -1, sizeof(math::val)); int S, T; cin &gt;&gt; S &gt;&gt; T; while(T--) solve(); return cerr &lt;&lt; clock() &lt;&lt; endl, 0;}","link":"/posts/55226.html"},{"title":"狄利克雷卷积","text":"引入1：积性函数 定义数论函数为定义域是正整数，而值域是复数的函数。 定义积性函数为满足如果$a$, $b$ 互质则$f(ab) = f(a)f(b)$ 的数论函数。 定义完全积性函数为对于任意$a$, $b$ 都有$f(ab) = f(a)f(b)$ 的数论函数。 对于一个积性函数，对任意 $n= \\prod a_i^{k_i} $ ，只要知道$f(a_i^{k_i})$就能确定$n$. 对于完全积性函数，我们只要知道所有的$f(p_i)$ 就够了。 单位函数：$\\varepsilon(n)=[n=1]$。（完全积性） 恒等函数：$\\operatorname{id}k(n)=n^k$，$\\operatorname{id}{1}(n)$ 通常简记作 $\\operatorname{id}(n)$。（完全积性） 常数函数：$1(n)=1$。（完全积性） 除数函数：$\\sigma_{k}(n)=\\sum_{d\\mid n}d^{k}$。$\\sigma_{0}(n)$ 通常简记作 $d(n)$ 或 $\\tau(n)$，$\\sigma_{1}(n)$ 通常简记作 $\\sigma(n)$。 欧拉函数：$\\varphi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]$ 莫比乌斯函数：$\\mu(n)=\\begin{cases}1&amp;n=1\\0&amp;\\exists d&gt;1,d^{2}\\mid n\\(-1)^{\\omega(n)}&amp;\\text{otherwise}\\end{cases}$，其中 $\\omega(n)$ 表示 $n$ 的本质不同质因子个数，它是一个加性函数。 以上内容来自OI-Wiki 狄利克雷卷积定义两个数论函数$f(n),g(n)$的卷积$h(n)$为：$h(n)=\\sum_{d|n}f(d)g(\\frac{n}{d})$(这其实就是狄利克雷卷积),记作$h=f * g$则有： $\\varepsilon * f = f$ $1 * 1 = d$ $1 * id = \\sigma$ $1 * \\varphi = id$ $1 * \\mu =\\varepsilon$ 性质交换律： $fg=gf$。 结合律：$(fg)h=f(gh)$。 分配律：$(f+g)h=fh+g*h$。 等式的性质： $f=g$ 的充要条件是 $fh=gh$，其中数论函数 $h(x)$ 要满足 $h(1)\\ne 0$。 应用：莫比乌斯反演","link":"/posts/50488.html"},{"title":"生涯规划","text":"引：为什么应该做生涯规划 结合当代社会发展，我们生活在一个充满竞争与挑战的社会，提前做好自身的规划既对我们更好地适应社会打下基础，也可以对社会，对自身有较为清醒的认识，这样我们才能更好适应社会，为社会做出更大的贡献，更好的实现自身的人生价值。 古语有云：志不定，天下无可成之事。制定职业生涯规划对于每个人，尤其是在校高中学生是非常 重要的。只有当我们制定了明确的规划书，我们才会有奋斗的目标和方向，才能时刻检验自己的所作所为是否正确，才能为自己谋得精彩人生！ 一：自我分析暑假期间我对自己做了细致、理性的剖析，我对自己的性格、当前的生活状况、以及我的兴趣、特长和理想有了一个比较深刻的了解。 性格方面我认为自己是个有正义感、讲原则、有创造力、富有想象力、充满信念的人。我待他人以热情，乐于助人，我对自己的未来有坚定的目标，不满于现状，并希望能脚踏实地完成理想。但同时，我也有需要改进的地方，可能是因为个人经历的原因，我对批评比较敏感，比较在意他人的评价，因此做每件事都指望十全十美，而往往患得患失，其实我应该认识到我们不可能把每件事都做到完美，只要过程努力了，我们可以看淡结果而问心无愧了。 当前的生活状态正处于文化课学业与竞赛学业交叉，我认为我的生活是比较充实、忙碌的。我认为文化课方面仍需努力巩固加强，竞赛方面我希望能出一个好成绩，不留遗憾。但在社会方面，我的生活是比较单调的，我应该积极参加各种社会活动，公益活动。 我的兴趣、特长、理想我对钢琴情有独钟，对航模有热情，擅长`编写程序,想要将来成为科研方面的程序员，找到一份稳定的工作。 二：学长指导暑假期间我们邀请到了刚毕业的高三学长朱泓熹，他现在就读于杭州电子科技大学。通过采访,我对将来应该制定一个怎样的规划有了更深刻的感悟 对于高中三年的学习有什么感想？A：学习需要充足的精力与良好的心态，充足的精力体现着学习方面的持久以及做题方面的专注，而良好的心态体现在学习方面的积极与良好的人际关系。 如何应对新的学习环境与繁重的学科？A：关于新的学习环境，首先要与周围的同学有基础的交流，与同学优势互补。我们也可以与任课老师与班主任请教。熟悉学校的建筑，以及它们都有什么功能。适应高中的作息时间。十门学科，对于初升高的学生来说比较困难，首先，要搞清楚每一门学科都有什么特点，文科重积累，理科重思维。其次要掌握学习各门学科的方法 如何分配各科的学习时间?A：开始，每一门学科都认真学习，到高一上期中考搞清楚自己擅长的科目，与自己以后心仪的专业。 学习与生活上的挫折如何解决？A：调整自己的心态，多问问题，保证充足的睡眠。如果在考试后发现失误，不要对答案。 如何制定目标?A:制定多层次的目标。比如，从时间上看，在第一学期，确定7选3，第二到第四学期，关注学考，最后，高考成绩要如何，要去什么学校学什么专业。也可以从个人能力的维度来制定。 高中与初中的异同？A：高中在校时间更长，学习压力更重。高中是一个更大的平台，社团活动和团委学生会这种学生组织也很多。高中与初中的学习方法是相同的。 如何保持自律？A：制定目标，完成目标。也可以借助他人管理。 三年做过的最后悔的事?回到三年之前，会有什么改变？A：参加班长和团委竞选花费了我很多学习时间。但是，这使我有了工作经验，如果回到三年之前，我也会这么做。 ​ 在与学长的访谈中，我们知道了充足的精力、良好的心态、明确的目标与好的学习方法是高中学习的关键。高中学习困难，压力大，但及时调整，自律学习，可以战胜困难。高中生活给了我们一个更大的平台，参加社团活动，可以获得日后生活与工作的经验，但是，这也会占用很多的学习时间，我们要权衡两者之间的利弊，合理安排学习生活。 三：生涯规划 职业分析我的目标职业是一名程序员，根据我网上搜罗来的资料发现本行业具有如下特点 职业门槛高：程序员需要具有较强的逻辑思维能力、学习能力和动手实践能力，不少计算机专业的毕业生在从事程序员岗位的时候也面临一定的困难； 职业压力大：体现在三个方面，其一是工作内容多；其二是技术迭代速度快；其三是岗位竞争压力大；三重压力会造成不努力竞争的程序员将被很快淘汰； 薪资待遇高：程序员岗位的薪资待遇还是比较高的，而且近些年来程序员岗位的薪资待遇也在不断提升。在产业互联网阶段，程序员岗位的薪资待遇依然有较大的上升空间，以研究生为代表的创新型人才将有更加突出的表现； 年龄选择低龄化：更多科技大公司对新人年龄要求较高，他们更倾向于年轻人，认为他们更有创新的能力，因而有称程序员吃“青春饭”，当年过40要考虑自己将何去何从； 综合来说程序员是一个很有挑战性的职业，但我仍愿意为之奋斗。 家庭分析我生活在一个小康家庭，父母都是通过自身的努力建立起家庭富足，我父亲是建筑师，我母亲是教师，都对我的教育比较重视，希望我学业有成，他们也对我有信心，相信我能做出正确的选择，挑选适合的职业。 社会分析当前的社会是互联网时代，并且由于高薪待遇，社会上是比较看重程序员这一职业的。但是由于网络黑客、信息泄露的不良信息频繁出现，程序员在大众眼中褒贬不一。因此将来成为一个程序员，我们不仅要为自己的人生奋斗，也更要为网络安全，打造清洁的网络环境做出贡献。 未来三年行动计划 坚定自己的理想，不能墙头茅草两边倒，志坚方可行长远 通过信息竞赛认真学好专业知识和其他基础学科，坚信基础的东西一定是最重要的，锻炼自己的各科能力，同时检验自己的知识技能； 注意提高自身的基本素质，通过参加各种社团等组织，培养自己的社会责任感、乐观外向的性格，努力改进自己新各方面的不足 参加有意义的学科竞赛，以此来锻炼自己的竞争能力，多了解社会现状，了解行业走向，确保当自己有能力进行竞争时有足够的认识，准备充分。 由于高中更重要的还是高考，对很多人来说，大学本科“第一学历”可能决定我们的一生，因此我应该脚踏实地全方面学习，以求高考考到一个理想的大学。 在高中生活的每一天都应做好计划，每天应该做什么，什么时间做完，要达到怎样的学习效果达到什么目的，怎样进行总结，都应该要有一个明确的认识，并且可以再细化到每天要被多少英语单词，刷多少题，把时间精确到分秒，每一天都过得充实，日积月累才能厚积薄发。 四：总结希望接下来的生活，有努力，有付出，有收获，有快乐。来日方长，延伸的路始终都在自己脚下，哪怕身在万丈深渊，努力就能走向高处。我们依然坚定的奔跑，用一条条小径写下拼搏的曾经，愿三年后的未来，我能旗开得胜，玉汝于成，志得意满，不留遗憾！","link":"/posts/8547.html"},{"title":"莫比乌斯反演","text":"引入 莫比乌斯反演是数论中的重要内容。对于一些函数 $f(n)$，如果很难直接求出它的值，而容易求出其倍数和或约数和 $g(n)$，那么可以通过莫比乌斯反演简化运算，求得 $f(n)$ 的值。 定义$\\mu$ 为莫比乌斯函数，定义为 $$\\mu(n)=\\begin{cases}1&amp;n=1\\0&amp;n\\text{ 含有平方因子}\\(-1)^k&amp;k\\text{ 为 }n\\text{ 的本质不同质因子个数}\\\\end{cases}$$ 详细解释一下： 令 $n=\\prod_{i=1}^kp_i^{c_i}$，其中 $p_i$ 为质因子，$c_i\\ge 1$。上述定义表示： $n=1$ 时，$\\mu(n)=1$； 对于 $n\\not= 1$ 时： 当存在 $i\\in [1,k]$，使得 $c_i &gt; 1$ 时，$\\mu(n)=0$，也就是说只要某个质因子出现的次数超过一次，$\\mu(n)$ 就等于 $0$； 当任意 $i\\in[1,k]$，都有 $c_i=1$ 时，$\\mu(n)=(-1)^k$，也就是说每个质因子都仅仅只出现过一次时，即 $n=\\prod_{i=1}^kp_i$，${p_i}_{i=1}^k$ 中个元素唯一时，$\\mu(n)$ 等于 $-1$ 的 $k$ 次幂，此处 $k$ 指的便是仅仅只出现过一次的质因子的总个数。 性质莫比乌斯函数不仅是积性函数，还有如下性质： $$\\sum_{d\\mid n}\\mu(d)=\\begin{cases}1&amp;n=1\\0&amp;n\\neq 1\\\\end{cases}$$ 即 $\\sum_{d\\mid n}\\mu(d)=\\varepsilon(n)$，$\\mu * 1 =\\varepsilon$ 重要的转换方式:如果有$\\color{red}{f(n)=\\sum_{d\\mid n}g(d)}$,则有$\\color{blue}{g(n)=\\sum_{d|n}f(d)\\mu(\\frac{n}{d})}$.如果有$\\color{red}{f(n)=\\sum_{n\\mid d}g(d)}$,则有$\\color{blue}{g(n)=\\sum_{n|d}f(d)\\mu(\\frac{d}{n})}$. 证明设 $\\displaystyle n=\\prod_{i=1}^k{p_i}^{c_i},n’=\\prod_{i=1}^k p_i$ 那么 $\\displaystyle\\sum_{d\\mid n}\\mu(d)=\\sum_{d\\mid n’}\\mu(d)=\\sum_{i=0}^k \\dbinom{k}{i}\\cdot(-1)^i=(1+(-1))^k$ 根据二项式定理，易知该式子的值在 $k=0$ 即 $n=1$ 时值为 $1$ 否则为 $0$，这也同时证明了 $\\displaystyle\\sum_{d\\mid n}\\mu(d)=[n=1]=\\varepsilon(n)$ 以及 $\\mu\\ast 1=\\varepsilon$ 所以在狄利克雷卷积中，莫比乌斯函数是常数函数 $1$ 的逆元。 补充结论反演结论：$\\displaystyle [\\gcd(i,j)=1]=\\sum_{d\\mid\\gcd(i,j)}\\mu(d)$ 直接推导：如果看懂了上一个结论，这个结论稍加思考便可以推出：如果 $\\gcd(i,j)=1$ 的话，那么代表着我们按上个结论中枚举的那个 $n$ 是 $1$，也就是式子的值是 $1$，反之，有一个与 $[\\gcd(i,j)=1]$ 相同的值：$0$ 利用 $\\varepsilon$ 函数：根据上一结论，$[\\gcd(i,j)=1]=\\varepsilon(\\gcd(i,j))$，将 $\\varepsilon$ 展开即可。 线性筛由于 $\\mu$ 函数为积性函数，因此可以线性筛莫比乌斯函数（线性筛基本可以求所有的积性函数，尽管方法不尽相同）。 1234567891011121314151617181920int pri[50005],mu[50005],tot;bool vis[50005];void get_mu(int n){ mu[1]=1;//注意初始化 for(int i = 2;i&lt;=n;i++){ if(!vis[i]){ pri[++tot]=i; mu[i]=-1;//是质数 } for(int j = 1;i*pri[j]&lt;=n&amp;&amp;j&lt;=tot;j++){ int m=i*pri[j]; vis[m]=1; if(i%pri[j]==0){ mu[m]=0;//有平方因子 break; } mu[m]=-mu[i]; } }}","link":"/posts/61065.html"},{"title":"红楼梦章节概要","text":"转载自https://zhuanlan.zhihu.com/p/497809489,侵删。 第一回 甄士隐梦幻识通灵 贾雨村风尘怀闺秀僧道谈论绛珠仙草为神瑛侍者还泪之事。僧道度脱甄士隐女儿英莲未能如愿。甄士隐与贾雨村结识。英莲丢失；士隐出家，士隐解“好了歌”。 第二回 贾夫人仙逝扬州城 冷子兴演说荣国府士隐丫头娇杏被雨村看中。雨村发迹后先娶娇杏为二房，不久扶正。雨村因贪酷被革职，给巡盐御史林如海独生女儿林黛玉教书识字。冷子兴和贾雨村谈论贾府危机；谈论宝玉聪明淘气，常说“女儿是水做的骨肉，男子是泥做的骨肉，我见了女儿便清爽，见了男子便觉浊臭逼人”，谈论邪正二气及大仁大恶之人。 第三回 贾雨村夤缘复旧职 林黛玉抛父进京都黛玉母逝；贾母要接外孙女黛玉；林如海写信给贾政为雨村谋求复职。黛玉进贾府，不肯多说一句话，多行一步路，怕被人耻笑。贾母疼爱林黛玉；“凤辣子”出场；王夫人要黛玉不要招惹宝玉；宝黛相会，一见如故。 第四回 薄命女偏逢薄命郎 葫芦僧判断葫芦案雨村补授应天府，薛蟠与冯渊争买玉莲，冯渊被打死。雨村欲拿薛蟠，当日葫芦庙小沙弥、•如今雨村门子阻其发签，说薛家乃“护官符”上之“雪”（薛）。雨村听门子之计，徇情枉法。薛家“百万之富”，薛母乃王子腾之妹，与贾政夫人王氏一母所生。薛蟠要自家另住，薛姨妈要和王夫人“厮守几日”。进贾府后住梨香院。 第五回 游幻境指迷十二钗 饮仙醪曲演红楼梦贾母怜爱黛玉如宝玉；宝钗来后，人多倾向之，黛玉不忿；宝玉视其如一，略偏于黛玉；二人因亲密后生口角。贾母等去宁府赏梅。秦氏（乃贾母“重孙媳妇中第一个得意之人”）领宝玉去她房中安睡。梦中观看“金陵十二钗”正册、副册及“又副册”。 第六回 贾宝玉初试云雨情 刘姥姥一进荣国府周瑞家的给刘姥姥介绍凤姐：“年纪虽小，行事却比世人都大，出挑的美人一样的模样儿，少说些有一万个心眼子，再要斗口齿，十个男人斗不过她一个，就只待下人未免太严些个”。刘姥姥先见平儿，误以为凤姐。凤姐初会刘姥姥，态度不热不冷。凤姐和贾蓉说借玻璃炕屏的事。 第七回 送宫花贾琏戏熙凤 宴宁府宝玉会秦钟周瑞家的找王夫人回话，薛王二人长篇在套地谈家务人情．薛姨妈托她到王夫人处给迎、探、惜和凤姐送宫花，她女儿求她为女婿冷子兴说情（因卖古董和人打官司）；给黛玉送宫制假花，黛玉用话刺周瑞家的。凤姐言珍大嫂子叫她明日过去逛逛，王夫人答应叫去。秦氏向宝玉介绍她弟秦钟，凤姐要见，贾蓉带来见凤姐。秦宝二人互相倾慕，宝玉要秦钟来贾府私塾读书。焦大当着凤姐和宁府诸人面骂街。 第八回 比通灵金莺微露意 探宝钗黛玉半含酸凤姐与宝玉说服了贾母叫秦钟来家塾上学。宝玉到梨香院看宝钗，薛姨妈热情接待。宝钗急于看通灵宝玉，莺儿说玉上的八个字与宝钗锁上八个字正好一对儿，宝玉因要了锁看。宝玉要吃冷香丸，宝钗不给。黛玉来了，见宝玉、宝钗在一起，心下不悦。雪雁给黛玉送手炉，黛玉趁机奚落宝、钗。 第九回 恋风流情友入家塾 起嫌疑顽童闹学堂宝玉要上学，袭人劝他念书，不然就潦倒一辈子了。贾政训斥李贵，叮咛让宝玉不要念诗经古文，讲明背熟《四书》 ,宝玉提出不和秦钟论叔侄，而称兄弟。秦钟、香怜交友，金荣取笑，秦、香向贾瑞告状。贾瑞偏袒金荣。贾蔷激茗烟闹事，李贵息事，金荣赔礼。 第十回 金寡妇贪利权受辱 张太医论病细穷源金荣对秦钟仗着宝玉和他好目中无人不满。金寡妇数说金荣退了学占不了薛大哥的便宜。但又把此事告诉了小姑子璜大奶奶，璜大奶奶要告尤氏评理，金寡妇不让，怕娃上不了学，没钱请先生，还要在金荣身上添许多嚼用。璜大奶奶到了宁府，尤氏告诉她：秦氏经期两个月未来，下半天懒待动，话懒待说，眼神也发眩。冯紫英给贾珍荐幼时从学的先生张友士医生给秦氏看病。 第十一回 庆寿辰宁府排家宴 见熙凤贾瑞起淫心九月菊花盛开。贾敬寿辰，贾母“不赏脸”未来，凤姐为之解释。凤姐和宝玉瞧秦氏，秦氏说凤姐“疼我”。宝玉想起在此睡觉梦游太虚幻境事。凤姐劝解秦氏，说了许多衷肠语。贾瑞给凤姐请安。平儿说三百两银子的利银旺儿媳妇送来了；平儿骂贾瑞癞蛤蟆想天鹅肉吃，没人伦的混账东西。 第十二回 王熙凤毒设相思局 贾天祥正照风月鉴贾瑞来找凤姐。按约定晚上钻入穿堂。腊月天寒，白冻一晚而归。代儒惩罚贾瑞跪在院内读文章，打了三四十大板，不许吃饭。第二次又在凤姐房后小过道里那座空房子，被贾蓉、贾蔷捉弄。贾瑞不听跛道人之言，正照风月宝鉴，一命鸣呼。 第十三回 秦可卿死封龙禁尉 王熙凤协理宁国府秦氏给凤姐托梦。凤姐听秦氏死吓了一身冷汗；宝玉心中似戳了一刀。 “贾珍哭的泪人一般”，奢华办丧事，秦氏丫环瑞珠触柱而亡。小丫环宝珠甘为义女。尤氏犯旧疾不出。宝玉向贾珍荐凤姐理家。贾珍拄个拐请凤姐理家。凤姐抓住宁府五件风俗，要治一治。 第十四回 林如海捐馆扬州城 贾宝玉路谒北静王宁国府中都总管来，说凤姐“是个有名的烈贷，脸酸心硬，一时恼了，不认人的”。凤姐威重令行，十分得意。宝玉秦钟去凤姐处坐。随贾琏送黛玉的昭儿从苏州回来，言林如海九月初三日已殁，凤姐说宝玉“你林妹妹可在咱们家住长了”。宁府送殡，北静王水溶会见宝玉。 第十五回 王熙凤弄权铁槛寺 秦鲸卿得趣馒头庵北静王看“宝玉”赞宝玉，赠以前日圣上亲赐兴＋月＋鸟令＋鸟香念珠一串。凤姐、宝玉、秦钟盱中途在农人家打尖。宝玉观二丫头纺绩。来至换槛寺，凤姐到馒头庵（水月庵）要两间房作下处。宝玉，秦钟与智能玩笑；凤姐弄权图银害命。自称“从来不信阴司地府报应，凭是什么事，我说行就行”。问老尼要三千两银子。智能向秦钟提出“出了这牢坑，离了这些人”的要求。凤姐为落人情，图三千银，又住一宿。 第十六回 贾元春才选凤藻宫 秦鲸卿夭逝黄泉路贾政生辰，元妃入宫。 贾蔷要下姑苏聘请教习，采买女孩子，置办乐器行头，贾琏有犹豫之意，贾蓉示意凤姐为之说好话，贾琏方允。凤姐趁机叫赵嬷嬷两个儿子一起去。 贾府忙着盖造省亲别墅。 宝玉看望将死之秦钟，秦钟劝他“以后还该立志功名，以荣耀显达为是”，并自悔“以前你我见识自为高过世人，我今日才知自误了”。 第十七至十八回 大观园试才题对额 荣国府归省庆元宵宝玉痛悼秦钟。贾政自谦自幼于花鸟山水题咏上就平平，如今于怡情悦性文章上更生疏；因闻塾师赞宝玉有对对联的歪才情，便带他进园拟匾。妙玉带发修行，不愿来贾府，王夫人让下个帖子请他。正月十五上元之日元春归省。在轿内见园内外如此豪华，因默默叹息奢华过费。元春自幼为祖母教养；与弟宝玉情同母子，元妃命换“天仙宝境”为“省亲别墅”。见贾母“满眼垂泪”，一手搀贾母，一手搀王夫人，三人有话说不出，“只管呜咽对泣”。元妃让众姊妹题诗，元妃极赞薛、林之作。 第十九回 情切切良宵花解语 意绵绵静日玉生香宝玉将元妃所赐之糖蒸酪留给喜吃此物之袭人。李嬷嬷赌气吃酥酪。袭人推说爱吃栗子，使宝玉把酥酪丢开，宝玉给袭人剥栗子。袭人以赎身之说试探宝玉，流露出对此“吃穿和主子一样，又不朝打暮骂”的地方的留恋。宝玉脸上带着胭脂膏子去看黛玉。黛玉说自己有俗香，无罗汉真人给的香。又说奇香、暖香、冷香的话。宝玉胡诌耗子精盗香芋的故事给黛玉听，使其不致睡出病来。宝钗来了，讥笑宝玉忘了芭蕉诗，急的满头汗。 第二十回 王熙凤正言弹妒意 林黛玉俏语谑娇音宝钗讽刺宝玉元宵不知“绿蜡”之典。李嬷嬷骂袭人“哄宝玉”“妆狐媚”“配小子”，袭人气哭。宝玉守袭人，劝袭人，给袭人喂药。宝玉给麝月篦头，睛雯讽刺，宝玉说她“磨牙”。湘云至，黛玉因宝玉恋着宝钗而使气回房。宝玉对黛玉讲“亲不间疏，先不僭后”的道理。 第二十一回 贤袭人娇嗔箴宝玉 俏平儿软语救贾琏袭人对宝玉不满诉诸宝钗，宝钗赏其识见志量。贾琏趁巧姐出痘和多姑娘儿鬼混，被平儿抓住把柄，瞒过凤姐；贾琏叫平儿不要怕凤姐。 第二十二回 听曲文宝玉悟禅机 制灯迷贾政悲谶语贾母要给宝钗做生日，凤姐和贾琏商量要比林黛玉高出一等。凤姐说贾母喜爱的龄官象一个人，宝钗笑而不说，宝玉不敢说，湘云说象黛玉。湘云、黛玉和宝玉为此事闹矛盾，宝玉心想目下两人尚未应酬妥协，将来犹欲何为。袭人劝宝玉“大家随和”，宝玉说自己是“赤条条来去无牵挂”。笔占一偈，又填一《寄生草》，心中自得。宝钗说她是引起宝玉说疯话的罪魁。元妃送出灯迷让猜，宝钗一猜就着，却故作难猜之状。贾母见元春喜悦，也命制作灯谜大家猜。贾母说“荔枝”（离枝）让贾政猜。贾政看了众从姊妹不祥之谜，伤悲感慨。 第二十三回 西厢记妙词通戏语 牡丹亭艳曲警芳心元妃下谕叫宝钗等去园中住。贾政传来宝玉，当着王夫人的面，把往日嫌恶心减了八九；虽对所起“袭人”名字不满，但又不让改。宝玉偷看《会真记》，抖花瓣于水中，遇见葬花之黛玉。宝玉用《西厢记》中词句相戏，黛玉竖眉瞪眼，带怒含嗔，说宝玉“欺负”她。黛玉在梨香院听《牡丹亭》，感慨缠绵，点头自叹，心动神摇，如醉如痴，眼中落泪。 第二十四回 醉金刚轻财尚义侠 痴女儿遗帕惹相思贾芸从贾琏处打听得凤姐把和尚的事给了贾芹便向母舅卜世仁要冰片麝香，准备给凤姐行贿，卜世仁拒绝了。颇有义侠之气的醉金刚倪二不要文约不要利钱借十五两三钱多银子给贾芸。贾芸买冰麝奉承凤姐。贾芸看宝玉未遇，遇见小红。贾芸二次遇到凤 姐，凤姐嫌他“拣远路儿走”，不先求她，求了贾琏；但又说不是贾琏主情，她不管贾芸的事。宝玉叫俏丽干净的小红递茶。小红因此被秋纹、碧痕骂了一顿；回家做梦，梦见贾芸拾了她的手帕。 第二十五回 魇魔法姊弟逢五鬼 红楼梦通灵遇双真宝玉干娘马道婆骗得贾母每日五斤油供奉菩萨，保宝玉无灾。赵姨娘给马道 婆说这一分家私要不都叫凤姐搬送到娘家去，“我也不是个人”。并叫马道婆设法绝了宝、凤，“这家私不怕不是我环儿的”。给马写五百两欠契一张，马给了纸铰的十个鬼和两个纸人。凤姐给黛玉等送暹罗国进贡的茶叶。取笑说黛玉给她家作媳妇，黛玉骂她贫嘴贱舌讨人嫌。凤姐、黛玉正眼不看赵姨娘。宝玉、凤姐一齐发疯。糊涂发烧。贾赦为宝、凤寻僧觅道，贾政劝而不住。赵姨娘叫贾母给宝玉办后事，被贾母连贾政一起骂了一顿。和尚道士持诵“宝玉”，宝玉病愈，黛玉念佛，宝钗说如来佛管林姑娘姻缘，黛玉骂钗与凤一样是贫嘴烂舌。 第二十六回 峰腰桥设言传心事 潇湘馆春宁发幽情红玉、佳蕙有走心无留心，宝玉却象几百年的熬煎。宝玉传贾芸说些没要紧话。贾芸通过坠儿掉换了小红罗帕。宝玉来到“凤尾森森，龙吟细细”的潇湘馆。宝玉用《西厢记》中词曲相戏黛玉，黛玉变了脸，说宝玉拿她取笑。薛蟠以贾政名义骗宝玉出来吃他生日的藕、瓜、鲟鱼、熏暹猪。事后宝钗说宝玉吃了她家的新鲜东西了。黛玉来看宝玉，晴雯不给开门，又听钗、玉说笑，黛玉不禁伤心落泪。 第二十七回 滴翠亭杨妃戏彩蝶 埋香冢飞燕泣残红黛玉看到定钗从宝玉房中出来，心中不忿回家依栏闷坐，二更方睡。四月二十六日芒种节，闺阁兴祭饯花神，众女孩在园中玩耍，宝钗欲寻黛玉，看见主进了潇湘馆，一怕宝玉不便，二怕黛玉猜忌，便要回来，路遇蝴蝶，赶至滴翠亭，细听小红和坠儿正说那贾芸拾帕之事。黛玉不理宝玉；探春在宝玉面骂赵姨娘，主动提出要给宝玉作鞋，被拒绝。黛玉葬花，宝玉痴倒。 第二十八回 蒋玉菡情赠茜香罗 薛宝钗羞笼红麝串宝玉与黛玉葬花诗发生共鸣，恸倒山坡。宝玉说黛玉把外四路的宝姐姐、凤姐姐主在心坎儿上，倒把他不理。宝玉、黛玉已清除误会。宝玉到冯紫有与薛蟠等饮酒行令。宝玉和蒋玉菡互赠礼物。袭人告诉宝玉端午节的礼元妃赐了，宝、钗一样，黛玉心疑。宝玉却还想着宝钗的膀子要长在黛玉身上就好了。 第二十九回 享福人福深还祷福 痴情女情重愈斟情黛玉用手帕打了呆看宝钗的宝玉眼睛。凤姐叫宝钗到清虚观打醮看戏去，宝钗嫌热不去。贾母要同凤姐去。叫宝钗去，宝钗只好答应。王夫人笑说贾母“还是这么高兴”。凤姐打上道士，贾母不叫唬着小道士。贾母婉言谢绝。张道士趁看“宝玉”之机奉承了许多宝贝，包括金麒麟。宝玉要散穷人，张道士拦阻。冯紫英等来送礼，贾母后悔地说：“又不是什么正经斋事，我们不过闲逛逛……”虽看了一天戏，下午便回来了，次日便懒怠去。第二天贾母、宝、黛再未去。宝、黛为张道士提亲事闹别扭。宝玉砸玉。黛玉“剪穗”。薛蟠生日，宝、黛、贾母等未去。宝玉对月长吁，黛玉临风洒泪。贾母从中为难，说：“老冤家遇见小冤家”，“不是冤家不聚头”，自己埋怨着也哭了。 第三十回 宝钗借扇机带双敲 龄官划蔷痴及局外宝玉给黛玉道歉，说就是自己死了，魂也要来一百遭。宝玉说黛玉死了他做和尚。黛玉用指戳宝玉额颅，又给宝玉绡帕叫擦泪，宝玉要拉黛玉去往老太太跟前。凤姐跳了进来拉黛玉去见贾母，说两人都扣了环了。宝玉比宝钗为杨妃，宝钗借靛儿来找扇子，发泄对宝、黛不满。宝钗又借李逵负荆讽刺宝、黛。盛暑，宝玉和金钏儿戏笑，王夫人打金钏儿一个嘴巴子。王夫人让金钏儿的母亲领之而去。宝玉看到蔷薇架下龄官划蔷字，产生同情恻隐这心；片云致雨，自己已湿，尚思女孩。宝玉淋雨回家踢了袭人一脚，袭人晚上吐血。 第三十一回 撕扇子作千金一笑 因麒麟伏白首双星宝玉服侍袭人，向王太医问药。端阳节王夫人治席请薛家母女赏午。众人不欢而散。宝玉因此而回房中长吁短叹，并因心情不好借情雯跌折扇子股子还顶嘴而要撵他。袭人等跪求方免。晴雯讽刺袭人正经还没混上个姑娘就称起“我们”了。宝玉要情雯撕扇子，麝月出来干涉，宝玉说“千金难买一笑”。钗、黛谈说湘云往日的调皮作为。王夫人说湘云有了婆家，湘云给袭人等带来戒指。翠缕和湘云论阴阳，最后归结到麒麟也有阴阳，人亦有阴阳。两人在蔷薇架下拾到宝玉遗掉的金麒麟。 第三十二回 诉肺腑心迷活宝玉 含耻辱情烈死金钏湘云在袭人面前褒钗贬黛；袭人求湘云为宝玉做鞋，说林姑娘身材不好不能作。宝玉不愿会雨村，湘云劝他谈讲仕途经济，宝玉对她下逐客令，说黛玉不说这些混帐活。黛玉怕宝玉因麒麟生出风流佳事，听到宝玉赞她，不禁喜惊悲叹。宝玉要黛玉放心，说黛玉皆因不放心才弄了一身病，但放心，病便会好。宝玉误以袭人为黛玉倾诉肺腑。金钏儿投井死，袭人同病相怜而流泪，宝钗却去安慰王夫人，说金钏儿自己落井而死。 第三十三回 手足耽耽小动唇舌 不肖种种大承笞挞宝玉为金钏儿死而五内摧伤。受了父亲一顿教训，因为金钏儿感伤。竟不曾听见，惹贾政。忠顺府长史官来索琪官。贾环又进谗言，贾政面如金纸。贾政以流荡优伶，表赠私物，在家淫辱母婢，荒疏学业而笞挞。 第三十四回 情中情因情感妹妹 错里错以错劝哥哥袭人说但凡听他的话也不至如此若打出残疾，叫人怎么样。宝钗手托丸药来看。亦云：“早听人一句话也不至今日；老太太，太太心疼，我们看着心里也疼”。宝玉心中为之大畅。黛玉来看。宝玉安慰黛玉说自己是装出来给人看的。黛玉无声而泣。劝说“你从此可都改了吧！”王夫人叫袭人，袭人汇报宝玉情况，王夫人给了两瓶进上的香露。宝玉打发袭人去宝钗处借书，叫晴雯送旧帕两块给黛玉，黛玉神魄驰荡，自感可喜、可悲、可笑、可惧、可愧，题诗三首于其上。 第三十五回 白玉钏亲尝莲叶羹 黄金莺巧结梅花络宝玉要吃小荷叶儿莲蓬汤。凤姐叫做十来碗大家吃，贾母说她拿官中钱做人情，她自告奋勇做东道，银子在她帐上领。贾母对薛姨妈夸口说她有本事叫凤姐弄来东西大家吃。凤姐说贾母若不嫌肉酸，不然连她也吃。宝玉说袭人站乏了，拉她坐下。袭人叫宝玉请莺儿打络子。凤姐叫莺儿和玉钏给宝玉送汤。玉钏儿叫婆子端汤，自己空手走。宝玉叫玉钏儿尝汤。宝钗提名给“宝玉”打络子；袭人得了王夫人两碗赏菜感到意外；宝玉不在乎；宝钗深明其意。 第三十六回 绣鸳鸯梦兆绛芸轩 识分定情悟梨香院贾母吩咐贾政的亲随小厮头儿，以后贾政若唤宝玉以她的名义加以拒绝。宝玉甘为诸丫环充役，骂宝钗入了“国贼禄鬼”之流；除“四书”外，别书皆毁，深敬黛玉。薛姨妈赞袭人，王夫人说袭人比宝玉强十倍。但不同意马上收做屋里人，“再过二三年再说”。宝钗来到怡红院。袭人正做鸳鸯戏莲花样的兜肚，袭人出去，宝钗坐在袭人的位子代做鸳鸯戏莲花兜肚。宝玉于梦中喊骂“和尚道士的话如何信得？什么是金玉姻缘，我偏说是木石姻缘”，宝钗听后“怔了”。凤姐叫袭人向王夫人叩头。宝玉喜不自禁。袭人说从此后她便是王夫人的人了。宝玉受龄官冷落，深悟人生情缘，各有分定。 第三十七回 秋爽斋偶结海棠社 蘅鞠苑夜拟菊花题探春向宝玉倡议创建诗社。适值贾芸送来海棠花两盆，遂起名“海棠社”。 探春给黛玉起名“潇湘妃子”，宝钗给宝玉起号“无事忙”、“富贵闲人”。湘云补和诗，自愿当东道。宝钗邀湘云安歇，给湘云出主意请老太太吃螃蟹赏桂花，并教湘云纺绩针黹为本。二人夜拟菊花题十二个。 第三十八回 林潇湘魁夺菊花诗 薛蘅芜讽和螃蟹永贾母带王夫人、凤姐及薛姨妈等进园。王夫人说贾母爱在那一处就在那一处。贾母夸宝钗细致，凡事想的妥当。众人作菊花诗。李纨评潇湘妃子为魁，宝玉喜的拍手叫“极是，极公道”宝玉带头作咏螃蟹诗，宝钗小题寓大意。“只是讽刺世人太毒了些”。 第三十九回 村姥姥是信口开合 情哥哥偏寻根究底袭人问平儿这月月钱为什么没放，平儿告诉她，凤姐早支了在外放债。刘姥姥讲女孩子雪地抽柴草，老太太因马棚失火不让说了；宝玉还在追问女孩儿冻出病来怎办。刘姥姥又说神佛给人儿孙的帮事，吸引住了贾母、王夫人。宝玉却记着女儿抽柴之事。派茗烟四处找女孩之庙。 第四十回 史太君两宴大观园 金鸳鸯三宣牙牌令贾母王夫人商议给史湘云还席。李纨准备游园东西，刘姥姥上大观楼缀锦阁观看了一番。贾母拣大红菊花簪于头上，凤姐给刘姥姥插了一头菊花。刘姥姥夸大观园竟比画儿还强十倍，贾母叫惜春画大观园。刘姥姥夸惜春能干。贾母领刘姥姥先来潇湘馆，刘姥姥误认为是公子书房。来到蘅芜苑，贾母夸宝钗太老实，要为宝钗收拾房子，叫鸳鸯取东西来放。在藕香榭吃酒行令。刘姥姥欲退席回家而不得。黛玉行令时无意说“牡丹亭”、“西湘记”中两句词曲。 第四十一回 栊翠庵茶品梅花雪 怡红院劫遇母蝗虫贾母带刘姥姥到栊翠庵。妙玉用成窑五彩小盖钟招待贾母喝老君眉茶，刘姥姥喝了嫌淡。妙玉又私下招待宝、黛、钗喝茶。宝玉把妙玉不要的成窑茶杯要给刘姥姥。贾母被小竹椅抬去歇息，王夫人在刚才贾母坐的榻上歪睡。鸳鸯带刘姥姥游玩供众人取笑。姥姥醉卧怡红院，袭人领他出来。贾母觉得懒懒的，回房歇息。 第四十二回 蘅芜君兰方解疑癖 潇湘子雅谑补余香王太医给贾母诊脉看病。鸳鸯叫刘姥姥看贾母送的一包袱东西。宝玉送了妙玉不要的成窑钟子，更使她受宠若惊。鸳鸯送衣服。宝钗“教导”黛玉不要被杂书移了性情，“就不可救了”。说得黛玉心下暗伏，“只有答应‘是’的一字，”惜春告假一年画大观园。黛玉叫刘姥姥“母蝗虫”。宝钗夸黛玉取笑儿淡而有味。 第四十三回 闲取乐偶攒金庆寿 不了情暂撮土为香贾母提出为凤姐做生日。方法是凑份子。邢夫人也被叫来了。贾母带头二十两。凤姐对邢、王夫人各出二六两不服，叫分别替两位姐儿出了。又要周、赵姨娘也出份子。尤氏替周、赵抱打不平。共凑一百五十两。凤姐叫尤氏看老太太眼色行事。尤氏说凤姐收着些好，太满了就泼出来了。宝玉在凤姐生日时以给北静王死妾探丧为名给金钏儿烧纸，茗烟跟着。借素日厌恶的水仙庵一用。回家后贾母用“叫你老子打你”相威吓。 第四十四回 变生不测凤姐泼醋 喜出望外平儿理妆凤姐扬手打给贾琏放哨的小丫头脸，小丫头一栽，这边脸上又一下，登时小丫头两腮紫胀起来。另一放哨丫头被一扬手打了个趔趄。贾琏和鲍二家议论要扶正平儿，骂凤姐是夜叉星。凤姨打骂平儿。宝钗劝平儿。袭人劝平儿。宝玉给平儿道歉，要平儿换衣服，帮平儿理妆。宝玉思平儿供应俗琏威凤，其命之薄比黛玉更甚，不禁为之落泪。贾母坐阵，叫贾琏为凤姐赔不是，又叫琏、凤给平儿赔不是。贾琏说凤姐“太要足了强也不是好事”。鲍二媳妇上吊，凤姐趁愿，贾琏给银二百，又亏王子腾帮忙，方了此事。 第四十五回 金兰契互剖金兰语 风雨夕闷制风雨词宝钗周到地应付各方面关系，黛玉则因病常接待不周。宝钗来看黛玉，叫她看病，黛玉说“死生有命，富贵在天”，非人力可强。宝钗劝黛玉每天早起喝燕窝粥。主感激宝钗，承认自己错了，误到如今。又说自己长了今年十五岁，竟没一个人象宝钗前日那样教导她，承认“我竟自误了”。秋霖脉脉，服晴不定，黛玉拟《春江花月夜》而作“秋窗风雨夕”。宝玉披蓑戴笠来看，黛玉说宝玉“渔翁”，后又说自己“渔婆”，感谢宝玉一天来几次看她，下雨还来。黛玉送宝玉披璃绣球灯回去。宝钗又差婆子送来一大包上等燕窝，还有一包洁粉梅片雪花洋糖。黛玉感念宝钗，又心疑宝玉。 第四十六回 尴尬人难免尴尬事 鸳鸯女誓绝鸳鸯偶邢夫人叫过凤姐，求她为贾赦求娶鸳鸯，凤姐假贾母之口拒绝了。邢夫人只知承顺贾赦以自保，一应大小事务，俱由贾赦摆布。凤姐见邢夫人先赞鸳鸯扎花的针线好，又浑身打量鸳鸯；拉鸳鸯手为之道喜；说明原故，要拉鸳鸯回老太太；又到凤姐处。鸳鸯则一直不说话，对平儿表示说即使作大老婆她也不干。贾赦叫贾琏去南京找鸳鸯父金彩，贾琏未去被骂了一顿。贾赦亲唤鸳鸯之兄金文翔吩咐，金文翔领鸳鸯回家，鸳鸯咬定牙不愿意，到贾母面前剪发明誓。 第四十七回 呆霸王调情遭苦打 冷郎君惧祸走他乡贾母训邢夫人“三从四德”，“贤慧太过”，说明鸳鸯对自己、王夫人、凤姐的重要性。贾母叫薛姨妈、王夫人、凤姐、鸳鸯打牌斗乐，凤姐输钱说笑逗贾母喜欢。贾琏替贾赦来请邢夫人，被贾母教训了一顿。邢夫人训贾琏不孝。贾赦忍气花银买了嫣红做妾。自此告病，不敢再见贾母。柳湘莲诱薛蟠至郊外揍了一顿。贾珍派贾蓉至北门外桥下二里路苇塘处找到薛蟠。薛姨妈要告诉王夫人寻拿湘莲，被宝钗劝阻了。 第四十八回 滥情人情误思游艺 慕雅女雅集苦呤诗薛蟠要和老伙计张德辉南去贩纸札香扇。薛蟠说母亲，母亲不允，薛赌气睡。宝钗同意让哥去，薛氏以用钱买乖而应允。香菱和宝钗搬来同住。香菱要宝钗教他作诗，宝钗和叫香菱从老太太起各处拜望拜望。平儿向宝钗要棒疮药，说贾赦为石呆子二十把古扇之事把贾琏打了一顿，脸上两处伤。黛玉自愿给香菱作老师教其写诗。黛玉讲作诗第一立意要紧，“不以词害意”。和香菱一块讲究讨论，指导香菱作诗。 第四十九回 琉璃世界白雪红梅 脂粉香娃割腥啖膻众姐妹商议在芦雪庵赏雪作诗。宝玉第二天起来，出站见雪色皎洁，在栊翠庵赏玩梅花。湘云和宝玉向贾母要了一块鹿肉。众人吃鹿肉，平儿丢了一个镯子。 第五十回 芦雪庵争联即景诗 暖香坞雅制春灯谜凤姐起头联句：“一夜北风紧”。众人罚宝玉去栊翠庵妙玉处乞梅。罚宝玉作乞梅诗。贾母也来了。吃糟鹌鹑，叫大家作灯谜正月里玩。贾母欲求宝琴与宝玉为配，薛姨妈说已许与梅翰林家了，凤姐装作要说媒。李纨用四书作谜，黛玉猜着了。宝钗嫌这些谜老太太不喜欢，要求编些雅俗共赏的浅近物儿。湘云作“点绛唇”，宝玉猜是猴儿。宝钗、黛玉各编了一个，宝琴作了十首“怀古诗”各隐一物。 第五十一回 薛小妹新编怀古诗 胡庸医乱用虎狼药宝钗说后两首怀古诗（蒲东寺，梅花观）史鉴无考，要求另作，黛玉、李纨反对，作罢。袭人因母病要回家，凤姐亲自出马收拾打扮，吩咐怡红院的人“别由着宝玉胡闹”。麝月叫晴雯干活，晴雯说要暖和暖和，晴雯要唬麝月玩，不想自己受了凉。胡庸医药中有枳实、麻黄等虎狼药，宝玉说该死，叫茗烟去请王太医。说的病也是外感内滞，但方上无枳实、麻黄，倒有当归、陈皮、白芍等。药之分量也减了些。情雯不叫在屋里熬药，宝玉说屋里正缺药香。凤姐建议天冷了姑娘们在园里吃饭，王夫人、贾母皆赞同。 第五十二回 俏平作情掩虾须镯 勇晴雯病补雀金裘平作对麝月悄说坠儿偷虾须镯的事；宝玉告诉了晴雯，给晴雯请来了王太医看病，给晴雯闻鼻烟。叫麝月从凤姐那里要来西洋膏药“依弗哪”贴太阳穴上。贾母给宝玉一件哦罗斯的“雀金呢”的（敝＋毛）衣。宝玉经过贾政书房门，怕下马，要绕角门走。晴雯叫宋嬷嬷领走偷镯的坠儿，和麝月把坠儿娘训了一顿。晴雯带病为宝玉补孔雀裘。 第五十三回 宁国府除夕祭宗祠 荣国府元宵开夜宴贾珍问尤氏皇上恩赏银子郑来不曾。丫头尤氏押岁锞子二百二十个，碎银一百五十多。乌庄头送东西来，说年成不好，打饥荒。贾蓉说元妃每年赏金一千两银子。省亲一次花钱无数。贾蓉说荣府穷了。凤姐和鸳鸯商议偷贾母东西卖 第五十四回 史太君破除腐旧套 王熙凤效戏彩斑衣袭人母亡，主子赐银四十两，袭人感激不尽。宝玉给黛玉斟酒，黛玉未喝，宝玉自饮，凤姐讽刺宝玉喝冷酒。贾母批才子佳人书《凤求鸾》，凤姐斟酒掰谎，自言效戏彩斑衣，喝贾母半杯剩酒。贾母讲小媳妇喝猴儿尿的笑话；凤姐说“聋子放鞭炮－－散了”。 众人放炮，贾母搂黛玉，王夫人搂宝玉，薛氏搂湘云，凤姐自己没有疼。 第五十五回 辱亲女愚妾争闲气 欺幼主刁奴蓄险心赵国基死，探春照旧例给银二十两，赵姨娘来哭闹，说她袭人也不如了（袭人母亲丧给银四十两）。探春主奴分明未让步。探春又对平儿说凤姐拿太太的钱落人情。又免了环、兰家学里的一项银子。 凤姐称赞：好个三姑娘！驳那些挑正嫌庶的“轻狂人”，又说自己骑上老虎了，百事照老祖宗规矩办。 第五十六回 敏探春兴利除宿弊 贤宝钗小惠全大体宝钗用朱子言论指导理家，探春却不然。宝钗言小事用学问一提便高出一层，不拿学问提着，便流入市俗。宝钗夸平儿远愁近虑，不卑不亢。探春因庶出而难过。探春兴例除弊要平儿请示凤姐后方行。甄家进京祝贺，派人送礼请安。甄家四个婆子给老太太讲说他家宝玉之事，贾母叫出贾宝玉，四人为之吃惊。宝玉开始以为四个承悦贾母；湘云开玩笑叫他放心闹，打狠了到南京找那一个宝玉去。贾宝玉做梦梦见甄宝玉。醒后方知道是镜中影儿。 第五十七回 慧紫鹃情辞试忙玉 慈姨妈爱语慰痴颦王夫人领宝玉会见甄宝玉。紫鹃“远”宝玉，宝玉发呆。紫鹃故意说黛玉明年春天或秋天要回苏州。宝玉回怡红院后发呆，李嬷嬷来瞧说不中用了。袭人来寻紫鹃，说明情景，黛玉声大咳，让紫鹃去解释。宝玉见紫鹃方嗳呀出声。宝钗去瞧黛玉，其母已先到。薛氏讲月下老人管姻缘。宝钗要黛玉嫁薛蟠。薛姨妈要把黛玉说给宝玉。 第五十八回 杏子阴假凤泣虚凰 茜纱窗真情揆痴理清明宝玉拄杖饭后闲转，湘云指着夹泥船说“快把这船打出去，他们是接林妹妹的”，宝玉仰望杏子想到“绿叶成荫子满枝”，邢岫烟再过几年也“绿叶成荫子满枝”了。见雀落枝头乱啼，又发感叹。见藕官为同伴烧纸，婆子要拉她见奶奶，宝玉为之遮掩。 宝玉看黛玉，两人都瘦了，黛玉想起往事，不觉流下泪来。芳官和其干妈闹仗，宝玉为芳官辩护。芳官说明藕官烧纸是因与药官同演夫妻，药官死后，又与蕊官演夫妻，温柔体贴，但还怀念药官，帮烧纸。 第五十九回 柳叶渚边嗔莺咤燕 绛云轩里召将飞符湘云犯杏癍癣，宝钗命莺儿去黛玉那里要硝，蕊官随之去看藕官。莺儿用柳条编一篮，送与黛玉。黛玉要和薛姨妈一起去宝钗房里吃饭，“大家热闹些”。莺儿又在柳堤坐下编篮，春燕来了，说宝玉说女儿未出嫁是无价之宝；出了嫁，变为死珠，于老就是鱼眼睛，举例说他妈和姨妈就越老越爱钱，春燕叫莺儿不要折柳条折花，她妈和姨妈分管这里，比得了永远的基业还谨慎。春燕娘来了，本为芳官之事上气，又恨春燕不遂心，便打春燕。春燕跑到宝玉房里，麝月命小丫头叫平儿来管春燕娘。平儿命撵出去叫林大娘在角门外打四十板，婆子流泪哀求方免。 第六十回 茉莉粉替去蔷薇硝 玫瑰露引来茯苓霜蕊官托春燕给芳官带去蔷薇硝擦脸。芳官把茉莉粉给贾环以代蔷薇硝。赵姨娘趁此进园大闹，夏婆子从中加油添醋。柳家想叫女儿去宝玉房中当差，托芳官给宝玉说，芳官要玫瑰露给柳五儿吃。并答应让五儿在宝玉房里当差。赵姨娘内侄倒欲娶柳五儿，柳家父母同意五儿不愿，父母未敢应允，钱槐气愧，偏与柳家相与。柳家欲回，其哥嫂送给柳五儿茯苓霜。 第六十一回 投鼠忌器宝玉瞒赃 判冤决狱平儿行权迎春房里的丫头莲花儿为司棋要炖的嫩鸡蛋，柳家的不给，莲花儿告诉给司棋，司棋领人捣乱厨房。柳五儿奖茯苓霜分些赠芳官；回来被林之孝家的抓拿，凤姐叫把柳家的打四十板，永不许进二门，把五儿打四十板，交给庄子，或卖，或配人。宝玉替彩云瞒赃，平儿向偷太太玫瑰给环儿的彩云说明情况，凤姐还要追究，处罚柳家的，平儿劝她得放手时须放手，凤姐方罢。 第六十二回 憨湘云醉眠芍药 呆香菱情解石榴裙探春提议凑份子给平儿过生日，众人射覆、行令、划拳。没贾母、王夫人约束，玩个热闹。湘云醉倒在青石板上，芍药满身，宝、黛于花下说话，黛玉赞探春，宝玉也赞探春，黛玉为贾府后手不接忧虑，宝玉却说再后手不接也少不了他和黛玉两人的。香菱、芳官等斗草，两人玩到地上，香菱裙子弄脏了水湿，其裙为宝琴所赠；宝玉教袭人给她换一件，香菱临走不叫把裙子事说与薛蟠。 第六十三回 寿怡红群芳开夜宴 死金丹独艳理亲丧林之孝家的查夜，催促快睡，宝玉答应了。林之孝家走后，丫头们请来了 姑娘们，大家宴聚玩耍，时已二更，薛姨妈派人接黛玉。姑娘们走后，宝玉与丫头又玩到四更。第二日早，袭人向平儿夸昨晚“热闹非常”。妙玉下帖祝寿，署名槛外人，岫烟说宝玉应署“槛内人”。贾敬死，尤氏理丧，尤老娘母女三人到宁府着家，贾蓉戏二姨。 第六十四回 幽淑女悲题五美吟 浪荡子情遗九龙宝玉从宁府回来，至黛玉处，劝黛玉不要作践了身子，急而生悲，滚下泪来，黛玉也无言对泣。宝玉发现“五美吟”诗要看，黛玉不给看，宝钗恰在这时来了，宝钗赞黛玉的“五美吟”命意新奇，别开生面。贾琏向贾蓉夸二姐比凤姐好。贾蓉要说二姐给贾琏做二房。贾蓉向尤老娘说二姨给贾琏，二姐未语，三姐先骂。尤氏劝阻，贾珍同意。尤老娘因经济上的依赖关系，也答应了。贾珍包办尤姐与张华退了婚。 第六十五回 贾二舍偷娶尤二娘 尤三姐思嫁柳二郎贾琏以奶奶呼二姐，将凤姐一笔勾销。将积年梯己给了二姐，只等凤姐一死，便接进去。兴儿向二姐介绍凤姐。 第六十六回 情小妹耻情归地府 冷二郎一冷入空门兴儿对二姐说宝玉外清内浊，三姐赞宝玉糊涂。尤三姐向二姐、贾琏表示要嫁柳湘莲；贾琏去平安州出差，路遇结为生死兄弟的薛蟠和柳湘莲，柳湘莲以祖传鸳鸯剑给三姐作为定礼。 宝玉向湘莲赞三姐，湘莲说宁府只有两个石头狮子干净，负贾琏索要宝剑。三姐用剑自刎。湘莲后悔不迭，出家为道。 第六十七回 见土仪颦卿思故里 闻秘事凤姐讯家童薛姨妈向宝钗说明三姐自刎，惋惜湘莲随道士出家。宝钗不以为意，叫薛氏备席请随薛蟠南去的伙计。宝钗将薛蟠从南方带来的土物分送各人，“只有黛玉的比别人不同，且又加厚一倍”。黛玉见了家乡土物反自伤心，感叹无父母兄弟，客寄亲戚家中。袭人去看凤姐，路遇老祝妈给果树赶马蜂，祝妈要给果子尝，袭人正色拒绝了。凤姐审问旺儿和兴儿。 第六十八回 苦尤娘赚入大观园 酸凤姐大闹宁国府凤姐向二姐表白自己多少贤慧，要求二姐搬进去住。二姐竟认凤姐为知己，一同进了大观园。凤姐花银子叫张华告贾琏，张华往都察院告了旺儿、贾蓉。凤姐拉着贾蓉来撕掳尤氏。尤氏母子答应补上五百两打点之银，求凤姐在老太太跟前周全方便；贾蓉又出主意叫二姐再嫁张华；尤氏又拉凤姐讨主意如何撒谎才好；最后齐夸凤姐宽洪大量，足智多谋，答应事妥后娘儿们过去拜谢。尤氏又命丫环伏侍凤姐梳妆洗脸，摆设酒饭，亲自递酒拣菜。 第六十九回 弄小巧用借剑杀人 觉大限吞生金自逝凤姐使人挑唆帮张华告状要原妻，张父人财两得，要去贾府领人。凤姐告知贾母，贾母叫把二姐为之分辩，贾母要凤姐料理。凤姐通过蓉、珍父子叫张华不要领人，张家父子得了约百金，回原籍去了。贾琏出差回来，贾赦说他中用，赏银百两，赏丫头秋桐为妾。贾母听秋桐说二姐是“贱骨头”。二姐受暗气而生病。三姐托梦杀凤姐，二姐不为。胡君荣用药坠胎，凤姐挑唆秋桐气二姐，平儿与二姐哭诉，二姐吞金而逝，平儿出银二百理丧。贾母听凤姐之言，说痨病死的要一烧一撒。 第七十回 林黛玉重建桃花社 史湘云偶填柳絮词宝玉因冷遁了柳湘莲，剑刎了尤小妹，金逝了尤二姐，气病了柳五儿，闲愁胡恨，一重不了又添一重，情色若痴，语言常乱。宝琴故意说黛玉写的“桃花诗”是他作的。宝玉说宝琴虽有此才，宝钗决不会让他作此伤悼之诗。比不得林妹妹几经离丧，作此哀音。众人改海棠社为桃花社，推黛玉为社主。湘云填柳絮词，黛玉邀众填柳絮词。探春写半首，宝玉续了半首。众人看了黛玉的唐多令后认为太作悲了。宝钗说宝琴的过于丧败。宝钗诗中有“送我上青云”之句。众人放风筝，黛玉欲放走晦气。 第七十一回 嫌隙人有心生嫌隙 鸳鸯女无意遇鸳鸯八月初三日贾母八旬之庆，贾母只叫史、薛、琴、林、探会见南安太妃。 尤氏肚饿，先到凤姐房中，凤姐不在，未吃饭，平儿给点心未吃，又到园里，见园正门、角门未关，传管家婆子，两个分菜果的婆子听见是东府里奶奶，便不大在心上，不去传。周瑞家的素日因与这向个人不睦，告诉凤姐，传人捆起两个婆子，交马圈看守。邢夫人当众问凤姐为两个被捆的婆子求情，尤氏说凤姐多事，王夫人命放了婆子，凤姐灰心落泪。鸳鸯于湖山石后遇见司棋与其姑舅幽会。司棋求其超生，鸳鸯保证不外传。 第七十二回 王熙凤恃强羞说病 来旺妇倚势霸成亲司棋因姑舅兄弟私弟私逃而病倒，鸳鸯望候司棋，发誓不告外人，司棋感谢不尽。鸳鸯望候凤姐，说凤姐患的是“血山崩”。贾琏请求鸳鸯暂把老太太查不阗的金银家伙偷着运出一箱子，暂押千数两银子支腾过去。林之孝来说雨村降了，贾琏说远着他好。林之孝说旺儿的小子吃酒赌钱，无所不至；凤姐已给彩霞母亲说准了把彩霞配给旺儿小子，贾琏不同意，凤姐说贾琏“我们王家的人连我还不中你的意，何况奴才呢？” 彩霞怕旺儿媳妇倚仗凤姐之势一时作成，去求赵姨娘，赵又去求贾政，贾政说他已瞅准了两个丫头，一给宝玉，一给环儿。 第七十三回 痴丫头误拾绣春囊 懦小姐不问累金凤邢夫人见傻大姐拾到绣春囊，塞在袖内，十分罕异，揣摩此物从何而至，且不形于色。邢夫人训斥迎春不说其乳母，赌博被捉，外人共知。邢夫人骂琏、凤赫赫扬扬，不瞻顾他的妹妹迎春；凤姐要来侍候，邢夫人拒绝了。绣桔批评迎春不问累金凤被乳母偷去赌博之事。迎春乳母儿媳王住儿媳妇求迎春讨情被拒绝。探春责备住儿媳妇，叫来平儿责备凤姐。迎春看“太上感应篇”。 第七十四回 惑奸谗抄检大观园 矢孤介杜绝宁国府王夫人认为绣春囊是凤姐所遗，凤姐跪着哭辩。王夫人只好说自己气急了，拿话激凤姐建议派周瑞媳妇、旺儿媳妇等以查赌为名，把年纪大的、咬牙难缠的拿个错儿撵出去配人，并暗私访相事，王善保家的告睛雯黑状，王夫人唤来睛雯，晴雯知道有人暗算自己。王善保家的建议晚上来个猛不防的抄检大观园。 第七十五回 开夜宴异兆发悲音 赏中秋新词得佳谶贾母听说甄家被抄而不自在。贾母吃饭，听了鸳鸯话，把贾赦送来的两碗菜退了回去。贾母让给凤姐、宝黛、兰小子送汤送菜。尤氏发现赌博，贾珍、邢夫人胞弟邢德全、薛蟠亦在内。邢大舅论钱势，发泄对邢夫人之不满。贾珍于会芳园丛绿堂赏月作乐。三更时墙那边祠堂附近有长叹之声。贾珍疑惧。八月十五日。贾母夸贾珍送的月饼好，西瓜不怎样。贾母扶着宝玉进园赏月，众人簇拥贾母上山到凸碧山庄。贾母感叹人少。击鼓传花：贾政说怕老婆的笑话；宝玉不说笑话，作诗受赏；贾赦说父母偏心的笑话。贾赦赞赏贾政，论及后事前程。 第七十六回 凸碧堂品笛感凄清 凹晶馆联诗悲寂寞宝钗姊妹家去圆月，李纨、凤姐病着，贾母感叹人少冷清．贾赦歪脚，贾母叫邢夫人回去，尤氏因公公孝服未满未回，蓉妻相送邢夫人回家。贾母吃酒闻笛。看贾赦的婆子说贾赦不要紧，贾母对贾赦父母偏心的笑话耿耿于怀，王夫人从中解释。笛声又起，比先凄凉，笛音悲怨，贾母随泪。黛玉因贾母叹人少，而少景感怀，湘云劝她，并责怪宝钗自食其言。二人到凹晶馆。黛玉作“冷月葬花魂”，湘云说她“诗固新奇，只是太颓丧了些。”不该作此“过于清奇诡谲之语。”妙玉亦说“太悲凉了。” 第七十七回 俏丫环抱屈夭风流 美优伶斩情归水月王夫人问周瑞家搜检之事，周瑞家和凤姐已商量妥了，如实相回，王夫人叫周瑞家的逐司棋，迎春似有不舍之意，宝玉阻拦不住，骂嫁了汉子的女人“混帐”，“比男人更可杀”。王夫人新自清查怡红院及别处，睛雯、四儿、芳官被撵。宝玉见王夫人所揭皆平日之语，倒床痛哭。宝玉稳住众人，去看晴雯。从睛雯家回来，哄袭人说到薛姨妈家去了。睡至五更梦见睛雯死了。王夫人差人替贾政传宝玉，有人请贾政寻秋赏桂作诗。贾政十分喜悦，赞宝玉诗做得好。芳、藕、蕊官要出家，王夫人先不答应，听智通、园心一番骗词，又同意了。 第七十八回 老学士闲征（女＋危）？词 痴公子杜撰芙蓉诔芳官等去后，王夫人去贾母处省晨，见贾母喜欢，回明晴雯之事，贾母说诸丫头模样爽利言谈针线不及晴雯。王夫人说晴雯不大沉重，美妾也要性情和顺举止沉重的才行，故选中袭人。宝玉回来，说这次去会客作诗不但未丢丑，还得了许多东西。宝玉从小丫头口中得晴雯已死。宝玉见园中去了司棋等五个，又去了宝钗一处……大观园不久要散，悲痛不已，只想与黛玉、袭人可能会同死同归。宝玉作《芙蓉女儿诔》祭睛雯。 第七十九回 薛文龙悔娶河东狮 贾迎春误嫁中山狼黛玉赞祭文可与曹娥碑并传，宝玉请黛玉改削。宝玉改“红绡帐里，公子多情；黄土垄中，女儿薄命”为“茜纱窗下，我本无缘；黄土垄中，卿何薄命”，黛玉听了，忡然变色，心中虽有无限的狐疑乱拟，外面却不露出。贾赦把迎春许与孙绍祖，贾政相劝不听，贾母亦不多管。宝玉因世界上又少了五个清净女儿（陪嫁丫头四个）而感慨作诗。香菱告诉宝玉薛蟠要娶桂花夏家的夏金桂，宝玉冷笑，为香菱耽心虑后，香菱反不悦而别。宝玉因抄检大观园以来种种羞辱惊悲凄之所致，兼以风寒外感，故酿成一疾，卧床不起。香菱盼金桂过门，夏女外具花柳之姿，内秉风雷之性。夏金桂见婆婆良善，制服了薛蟠。 第八十回 美香菱屈受贪夫棒 王道士胡诌妒妇方夏金桂改“香菱”为“秋菱”。金桂抻用宝蟾和薛蟠撵去香菱，香菱随宝钗，并酿成干血之症。金桂又作践宝蟾。薛蟠悔恨不该娶了这搅家星。宝玉奉贾母之命往天齐庙还愿烧香。宝玉把李贵等打发出去了，只留茗烟。向王道士打问有贴女人的妒病的方子没有。王道士胡诌疗妒汤。迎春向王夫人诉说孙始祖不堪，王夫人归之天命。迎春哭道：“我不信我的命就这么不好！从小儿没了娘，幸而在婶子这边过几年心净日子，如今偏又是这么个结果！”晚歇旧馆紫菱洲，后惧孙绍祖之恶而被接走。 第八十一回 占旺相四美钓游鱼 奉严词两番入家塾贾政不叫宝玉作诗联对，叫念文章，－－亲自送宝玉到私塾，给代儒叮咛。 第八十二回 老学究讲义警顽心 病潇湘痴魂惊恶梦贾母说宝玉“野马上了笼头”；贾政叫宝玉学做人的道理。黛玉鼓励宝玉在功名上下功夫，宝玉对此诧异。代儒叫宝玉讲“后生可畏”和“好色过于好德”袭人为晴雯“兔死狐悲”。怀疑宝玉要娶黛玉。黛玉做梦父亲来接；黛玉痰中带血，探春、湘云来看。 第八十三回 省宫闱贾元妃染恙 闹闺阃薛宝钗吞声黛玉听一老婆骂外孙女，惊叫“这里住不得了。”探春湘云劝黛玉。黛玉做梦宝玉为她掏心，袭人说宝玉昨夜嚷叫心疼。凤姐说“人怕出名猪怕壮”；凤姐把自己银子送黛玉使。贾政为元妃健康操心。贾母等进宫向元春问病。金桂和定蟾闹事，薛氏母女劝说不住。 第八十四回 试文字宝玉始提亲 探惊风贾环重结怨贾母给宝玉提亲，不管贫富只求性格儿、模样儿，还说贾政过去不如宝玉。邢王二夫人没什么矛盾。贾政又和王夫人说及宝玉功课之事。贾政检查宝玉作文。贾母劝薛姨妈不要把家事放在心上，又宝钗温厚和平。宝玉急着看书，连忙告辞。贾母褒钗抑黛。贾政问巧姐儿的病，关心宝玉的婚姻对象；贾母、邢、王夫人看巧姐的病。凤姐撮合宝玉和宝钗。贾环代表赵姨妈看巧姐，要看牛黄，闹倒了药锦子。赵姨妈责骂贾环。 第八十五回 贾存周报升郎中任 薛文起复惹放流刑宝玉说他的真玉晚上放光，邢、王夫人抿着嘴儿笑。贾母又忙问向薛家求亲之事。王夫人说薛家“十分愿意”，因薛蟠不在家无人商量。袭人找黛玉问宝玉娶亲的事，黛玉看书不答，袭人辞出。贾芸又找宝玉，袭人不理。宝玉撕贴儿骂芸，说要早睡，“明日我还起早念书呢”。贾政升郎中，宝玉放假在家乐，凤姐拿宝、黛开玩笑；贾母要给黛玉做生日。薛蟠打死人，薛家忙乱。 第八十六回 受私贿老官翻案牍 寄闲情淑女解琴书薛蟠因不满拿眼瞟蒋玉菡和跑堂的，用碗砸死跑堂的。薛姨妈托王夫人转求贾政帮忙。薛家使钱，死罪开活。黛玉给宝玉讲抚琴要遇知音；王夫人给宝、黛各送一盆兰花来。黛玉想到“草木当春，花鲜叶茂，想我年纪尚小，便象三秋蒲柳。若是果能随愿，或者渐渐的好来，不然，只恐似那花柳残春，怎禁得风摧雨送。” 第八十七回 感秋深抚琴悲往事 坐禅寂走火入邪魔宝钗以黛玉为知心，以冷节遗芳自喻，黛玉看了宝钗书信竟认为是“惺惺惜惺惺”。湘云说：“大凡地和人总是名自有缘分的”，“总有一个定数”。黛玉归房，看看已是林鸟归西，夕阳西坠。感叹寄人篱下。黛玉当着雪雁的面看宝玉旧帕及自己题诗。惜春同妙玉下棋，宝玉未听出是妙玉的声音。妙玉与宝玉听黛玉抚琴，琴弦断，妙玉说黛玉“恐不能持久。”妙玉认为君弦太高，太过；妙玉走魔入火。 第八十八回 博庭欢宝玉赞孤儿 正家法贾珍鞭悍仆贾母八十一大寿时，鸳鸯叫惜春写经。李纨与贾母打双陆。宝玉给贾母送 蝈蝈解闷。师傅让对对子，贾环对不了，宝玉帮他对，他买蝈蝈谢宝玉；贾兰对好了，宝玉夸贾兰。贾环、贾兰给贾表安来了。贾珍、贾琏怒打闹仗的周瑞、何三和鲍二。贾芸和小红在凤姐外相见戏笑。贾芸给凤姐送东西，凤姐不收；贾芸把凤姐不要的东西给小红两件。 第八十九回 人亡物在公子填词 蛇影杯弓颦卿绝粒黄河决口，淹了州县，贾政不回，宝玉功课松了。宝玉为晴雯烧香写祝词。到潇湘馆看黛玉挂的嫦娥《斗寒图》。黛玉听紫鹃、雪雁说宝玉完了亲，便糟蹋自己，绝粒待毙。贾母、王夫人只疑她有病，不知其心事。 第九十回 失绵衣贫女耐嗷嘈 送果品小郎惊叵测侍书到潇湘馆与雪雁说宝玉亲事未定，老太太要“亲上作亲”，黛玉听了，以为非自己而谁？阴极阳生，病情转好。王夫人和贾母来看黛玉。邢王二夫人、凤姐在贾母房中说闲话；贾母主张娶钗嫁黛，瞒着黛玉娶宝钗。王夫人怕黛玉知道“倒不成了事了”。宝蟾、金桂调戏薛蝌。 第九十一回 纵淫心宝蟾工设计 布疑阵宝玉妄谈禅薛家犯事，贾政和王夫人商量早娶宝钗的事。黛玉问宝玉与宝钗的关系问题，宝玉说“任凭弱水三千，我只取一瓢饮”。 第九十二回 评女传巧姐慕贤良 玩母珠贾政参聚散秋纹叫宝玉，怕他不来，故意说老爷叫他。老太太要办消寒会，宝玉高兴地想着宝姐姐也过来。宝玉给巧姐讲起了《列女传》。宝玉见柳五儿越发娇娜妩媚，所以才要她。凤姐吩咐旺儿给司棋母亲撕掳官司。冯紫英推销两万银子的母珠，贾政不敢买，凤姐以秦氏自居，为贾府后事着想。贾赦来贾政处叙寒温，还说“我们家里比不得从前了，这会儿也不过是个空门面”。 第九十三回 甄家仆投靠贾家门 水月庵掀翻风月案南安王府来了一班小戏子，叫贾政去吃酒，贾赦过来问：“明儿二老爷去不去？”临安伯来人请看戏，贾政叫贾赦带上宝玉去。贾政问包勇甄宝玉的情况；包勇说甄宝玉“改邪归正”，能帮老爷料理家务。贾政亲自过问水月庵风月案。贾琏替贾芹瞒丑。 第九十四回 宴海棠贾母赏花妖 失宝玉通灵知奇祸怡红院枯了一年的海棠突然于十一月开了（应在三月开），贾母、邢、王夫 人均来看，议论。皆以为好兆，唯探春疑非好兆。黛玉说二哥哥读书，舅舅喜欢，树才开花，贾母、王夫人夸黛玉比的有理，有意思。贾赦要砍，贾政不管，贾母不叫混说。还叫宝、环、兰做诗，叫办酒席赏花。平儿代凤姐贺喜，私下叮咛袭人别说混说，以防不测。宝玉陪贾母出去赏花换衣服未戴玉，回来不见了，全家忙乱。 第九十五回 因讹成实元妃薨逝 以假混真宝玉疯颠岫烟叫妙玉扶乩，众人不懂乩。贾琏告诉王夫人王子腾升内阁大学士。贾政哭告元妃痰气壅塞，四肢厥冷。贾母等进宫，元妃折，四十三岁。 黛玉为宝玉失玉而喜，以为宝玉配偶必然是自己。薛姨妈征求宝钗对婚事的意见。平儿指示悬赏寻玉。有人送假玉来，被认出退回。 第九十六回 瞒消息凤姐设奇谋 泄机关颦儿迷本性王子腾进京途中死。王夫人悲女哭弟，为子耽忧。贾政被能放了江西粮道 。老太太要给宝玉冲喜。贾政耽忧没了宝玉，年老无嗣。贾母说宝玉和宝丫头合该好来。凤姐献“掉包儿计”。黛玉从傻大姐那里得知宝玉娶亲消息，去问宝玉，两人傻笑，独自回屋。 第九十七回 林黛玉焚稿断痴情 薛宝钗出闺成大礼黛玉吐血，贾母、王夫人去看，黛玉说老太太白疼了她了，老太太说黛玉若有心病，她也没心肠了，白疼了黛玉了。薛蝌向薛蟠征求宝钗出嫁的意见，薛蟠很知礼地同意按母亲的意见办。黛玉焚诗稿。紫鹃找贾母未见。李纨说黛玉只有青女、素娥可比。宝玉成亲，贾政远行。 第九十八回 苦绛珠魂归离恨天 病神瑛泪洒相思地宝玉欲死，宝钗说明黛玉已死，宝玉昏死。醒来觉得金石姻缘已定，自己也心宽了好些。宝玉渐将爱黛玉之心移至宝钗身上。黛玉临死前叫紫鹃求他们送她回去，她身子是净的；口怨宝玉。贾母把黛玉死告宝钗。宝钗落了泪，贾母哭黛玉，王夫人也哭了一场；宝钗也痛哭；宝玉还恐宝钗多心。 第九十九回 守官箴恶奴同破例 阅邸报老舅自担惊贾母、薛姨妈正想黛玉，凤姐却来说宝玉、宝钗的笑话。贾政在江西粮道衙门一心要做清官，李十儿劝他要做贪官。他不肯，但信任李十儿。 第一百回 破好事香菱结深恨 悲远嫁宝玉感离情宝钗说薛蟠自作自受，“香菱那件就了不得，……白打死了一个公子。”作者在此为宝钗补“过”。 探春远嫁，宝玉哭倒，袭、钗规劝。 第一O一回 大观园月夜感幽魂 散花寺神签惊异兆凤姐去秋爽斋路上遇见恶狗相随，秦氏相问。宝玉和宝钗夫妻恩爱缠绵，惹得夫妻不和的凤姐伤心。凤姐因为遇鬼而信神。凤姐求签，得“王熙凤衣锦还乡”之句，众人皆认为好签。宝钗说是“还有原故”。 第一O二回 宁国府骨肉病灾 大观园符水驱妖孽探春将纲常大体的话说得宝玉有了醒悟之意。尤氏在园中见鬼，贾珍叫贾蓉向毛半仙求卦，毛半仙说先忧后喜。贾珍等相继病倒。园中不敢住人，为禽兽所栖。贾赦请法师驱邪逐妖。贾政被参革职，回京当员外郎。着降三级。 第一O三回 施毒计金桂自焚身 昧真禅雨村空遇旧王夫人说贾政在外作官，家里陪钱；下人在外办事，家中沾光。为贾政回京而喜。金桂想药死香菱反药死自己。雨村遇甄士隐。 第一O四回 醉金刚小鳅生大浪 痴公子余痛触前情贾政问黛玉，王夫人禁不住哭了。宝玉说宝钗不是他愿意的人，“都是老太太她们捉弄的。” 第一O五回 锦衣军查抄宁国府 骢马使弹劾平安州宁府被抄，贾赦贾珍被捆走，两府大乱。世职被革。 第一O六回 王熙凤致祸抱羞惭 贾太君祷天消祸患贾母照应邢、尤等太太奶奶。贾母祷神宽免儿孙，愿以死承罪。贾政查人，喝骂奴才没良心。 第一O七回 散余资贾母明大义 复世职政老沐天恩主上宣旨，皆宽处理。革去两个世职，贾赦往台站效力，贾珍往海疆。贾母散余资。贾政感叹老太太“真真是理家的人，都是我们这些不长进的闹坏了”。凤姐感激贾母看视。贾政袭了贾赦丢掉的世职。雨村投井下石，包勇醉骂雨村。 第一O八回 强欢笑蘅芜庆生辰 死缠绵潇湘闻鬼哭贾政将包勇罚看荒园。王夫人将家事（内事）交凤姐办理。贾母对湘云说宝钗有福气，黛玉小性儿又多心，所以不长寿。贾母受湘云怂恿拿一百银子给宝钗做生日。贾母叫请邢夫人，为顾及凤姐说的“齐全”。宝玉中途退席去看尤氏，经潇湘馆闻鬼哭。 第一O九回 候芳魂五儿承错受 还孽债迎女返真元宝玉欲梦黛玉而不得。贾母积食受凉，胸口纳闷，头晕目眩。迎春死，贾母痛哭。史湘云丈夫得了暴病。 第一一O回 史太君寿终归地府 王凤姐力拙失人心鸳鸯求凤姐把老太太丧事办得风光些。凤姐给贾母办丧事，钱少力拙，上下结怨。 第一一一回 鸳鸯女殉主登太虚 狗彘奴欺夭招伙盗鸳鸯在秦氏启发下寻死，宝玉先哭后笑，袭人以为又要疯了，宝钗却说他有他的意思，宝玉喜宝钗知他之心，“别人那里知道”。邢夫人不要贾琏为鸳鸯行礼。宝钗哭祭鸳鸯。周瑞干儿子何三和赌友商量行窃。妙玉和惜春正下棋，贼盗来家，包勇打死周瑞干儿子何三。 第一一二回 活冤孽妙尼遭大劫 死雠仇赵妾赴冥曹妙玉为贼所抢。惜春下定出家决心。赵姨娘中邪病倒。 第一一三回 忏宿冤凤姐托村妪 释旧憾情婢感痴郎刘姥姥哭老太太，凤姐视其为救命之人，托之以己命和女命。宝玉要找紫鹃表白自己的心，紫鹃未开门，宝玉被麝月找回。 第一一四回 王熙凤历幻返金陵 甄应嘉蒙恩还玉阙凤姐死，王仁混闹，要给凤姐大办丧事，嫌弃巧姐；平儿帮贾琏钱。甄应嘉到府托家眷，贾政托应嘉看探春。 第一一五回 惹偏私惜春矢素志 证同类宝玉失相知贾政叫宝玉念书写文章，他要检查。地藏庵姑子来贾府受到宝钗冷遇，激惜春出家。贾宝玉与甄宝玉貌象而异，宝玉呆病发作。和尚送来“宝玉”，宝玉死而复生。和尚要一万银子。 第一一六回 得通灵幻境悟仙缘 送慈柩故乡全孝道宝玉二历幻境。宝玉厌弃功名，看淡儿女情级。 第一一七回 阻超凡佳人双护玉 欣聚党恶子独承家宝玉在还和尚“宝玉”，紫鹃、袭人拉住不放；宝钗接过“宝玉”，要宝玉见和尚，宝玉说他们重玉不重人。贾赦感冒转痨病，贾琏要去看父，将女儿托于王夫人。荣府诸人各顾自己，不管别个，芸、蔷、环等胡作非为。邢大舅说笑话骂贾蔷是看不住家的“假墙”。惜春坚决要出家。 第一一八回 记微嫌舅兄欺弱女 惊谜语妻妾谏痴人惜春出家修行得到邢、王二夫人的应允，紫鹃要陪，宝玉念惜春“判词”。贾环出主意给贾芸、王仁、邢大舅，叫卖巧姐。贾政捎回家书，教宝玉、贾兰准备功课应考。宝玉正看《秋水》，想着出世离群。宝钗以古圣贤以忠孝赤子之心打动宝玉。宝玉点头欲考。宝玉到静室准备应考。宝钗、袭人既为其不信和尚高兴，又怕其恢复与女孩儿打起交道的旧病。 第一一九回 中乡魁宝玉却尘缘 沐息恩贾家延世泽宝玉对王夫人表示以中举报答母恩。宝玉似有疯傻之状离去。邢夫人作主，要卖巧姐，平儿和巧姐儿同去刘姥姥庄上避难。贾兰回来报信，丢了宝玉。探春回家。报信的说宝玉中了第七名举人，贾兰中了一百三十名。贾府复官，赏还了家产。贾琏回家团圆。邢王二夫人“彼此心下相安。” 第一二O回 甄士隐详说太虚情 贾雨村归结红楼梦贾政去金陵安葬贾母，闻喜讯回京，于船中写家书时遇宝玉，僧道与之同去，政追不上。只见白茫茫一片旷野，并无一人。薛蟠回，誓改前非，香菱被扶正。薛姨妈以李纨比宝钗。袭人不得已而嫁蒋玉菡。士隐对雨村说，贾府将来要“兰桂齐芳，家道复初”。","link":"/posts/6854.html"},{"title":"菜穗子と斐波那契题解","text":"题目描述 菜穗子在研究斐波那契数列。 众所周知，斐波那契数列是指前两个数都是$1$，从第三个数起，每一个数都等于它前面两个数的和，把这样的一列数组成的数列${a_n}$称为斐波那契数列。 现在，她想知道，对于她给出的指定的$n$，求出： $$\\sum_{i=1}^{n-1}a_ia_{i+2}-\\sum_{i=2}^{n}a_i^2$$ 分析为求该式 $$\\sum_{i=1}^{n-1}a_ia_{i+2}-\\sum_{i=2}^{n}a_i^2$$ 即求 $$\\sum_{i=1}^{n-1}a_ia_{i+2}-a_{i+1}^2$$ 对于其中每一项,设$f(i)=a_ia_{i+2}-a_{i+1}^2$ $$\\begin{aligned}f(i) &amp; =a_ia_{i+2}-a_{i+1}^2 \\ &amp; = (a_{i+1}+a_{i})a_{i}-(a_{i}+a_{i-1})a_{i+1}\\ &amp; = a_i^2-a_{i+1}a_{i-1}\\ &amp; =a_{i-2}a_i-a_{i-1}^2\\ &amp; =f(i-2)\\end{aligned}$$ $a[]=1,1,2,3,5,8\\dots$代入数据得：$f(1)=1,f(2)=-1$$f(i)=\\begin{cases}1&amp;x \\bmod 2=0\\-1&amp;x\\bmod 2=1\\end{cases}$ AC Code12345678#include&lt;iostream&gt;using namespace std;int main(){ long long n; cin&gt;&gt;n; cout&lt;&lt;!(n&amp;1); return 0;}","link":"/posts/14230.html"},{"title":"解析几何","text":"曲线通式$$Ax^2+By^2+Cxy+Dx+Ey+F=0$$ 记$\\Delta=B^2-4AC$,则$$\\begin{cases}\\Delta &lt; 0 \\ \\text{椭圆} \\\\Delta = 0 \\ \\text{抛物线} \\\\Delta &gt; 0 \\ \\text{双曲线}\\end{cases}$$","link":"/posts/29702.html"},{"title":"线性基","text":"刚认识这个东西，还以为有多么高大上呢 定义OI-Wiki版 称线性空间 $V$ 的一个极大线性无关组为 $V$ 的一组 Hamel 基 或 线性基，简称 基。规定线性空间 ${\\theta}$ 的基为空集。另外，将 $V$ 的 维数 记作 $\\dim V$, 定义为基的元素个数。 更通俗易懂一点的版本 线性基是一个数的集合，并且每个序列都拥有至少一个线性基，取线性基中若干个数异或起来可以得到原序列中的任何一个数。 性质 原序列里面的任意一个数都可以由线性基里面的一些数异或得到 线性基里面的任意一些数异或起来都不能得到$0$ 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的 操作构造（插入一些数并判断）令插入的数为$x$,考虑$x_{(2)}$进制下的最高位$i$ 若线性基的第$i$位为$0$,则直接在该位插入$x$,退出； 若线性基的第$i$位已经有值$a_i$，则$x=x\\bigoplus a_i$，重复以上操作直到$x=0$ 如果退出时$x=0$,则此时线性基已经可以表示原先的$x$了；反之，则说明为了表示$x$，插入了一个新元素。 可以证明，时间空间复杂度均为$O(\\log_2x)$ 12345678910111213141516171819void insert(long long x){ for(int i = max_bit;~i;i--){ if(x&amp;(1LL&lt;&lt;i)){//注意，如果max_bit大于31，一定要写成1ll if(!a[i]){a[i]=x;return;} else x^=a[i]; } } flag=true;//表示当前树数已经能够被线性基表示，也就是说有两个一样的数 //若下方不涉及最值运算，可不记录}bool check(long long x){ for(int i = max_bit;~i;i--){ if(x&amp;(1LL&lt;&lt;i)){ if(!a[i]) return false; else x^=a[i]; } } return true;} 异或最值最小值考虑插入的过程，$x$的二进制最高位必定单调降低，所以不可能插入两个二进制最高位相同的数。而此时，线性基中最小值异或上其他数，必定会增大。所以，直接输出线性基中的最小值即可。 1234567long long qmin(){ long long ans=0; if(flag) return 0; for(int i = 0;i&lt;=max_bit;i++){ if(a[i]) return a[i]; }} 最大值从高到低遍历线性基，考虑到第$i$位时，如果当前答案$ans$的第$i$位为$0$，就将$ans$异或上$a_i$，否则不做操作。这样，每次操作后的答案不会变劣，得到最终答案。 1234567long long qmax(){ long long ans=0; for(int i = max_bit;~i;i--){ ans=max(ans,ans^a[i]); } return ans;} 第$k$小值注意，这里的第k小值是指异或出来的数的第k小 对于每一个$a_i$,枚举$j = i \\ \\ to \\ \\ 1$,如果${d_i}{(2)}$的第$j$位为$1$，那么$d_i = d_i \\bigoplus d{j-1}$ 若$k_{(2)}$的第$i$位为$1$，$ans$就异或上处理后的线性基中第$i$个元素。 123456789101112131415long long k_th(long long k){ long long res=0,cnt=0; k-=flag;if(!k) return 0; for(int i = 0;i&lt;=max_bit;i++){ for(int j=i-1;~j;j--){ if(a[i]&amp;(1LL&lt;&lt;j))a[i]^=a[j]; } if(a[i])tmp[cnt++]=a[i]; } if(k&gt;=(1LL&lt;&lt;cnt)) return -1; for(int i = 0;i&lt;cnt;i++){ if(k&amp;(1LL&lt;&lt;i))res^=tmp[i]; } return res;}","link":"/posts/11495.html"},{"title":"计数原理","text":"排列数公式：$$P^k_n=\\frac{n!}{(n-k)!}$$ 组合数公式：$$P^k_n=\\frac{n!}{k!(n-k)!}$$ 这里规定 $\\color{Red}0!=1$一些比较重要的公式1.$$\\dbinom{n}{k}=\\dbinom{n}{n-k}$$2.$$\\dbinom{n}{k}=\\dbinom{n-1}{k}+\\dbinom{n-1}{k-1}$$3.$$\\dbinom{n}{k}\\dbinom{k}{t}=\\dbinom{n}{t}\\dbinom{n-t}{k-t}$$4.$$\\dbinom{n}{k}={\\sum_{i=k+1}^n k^2}\\dbinom{i-1}{k}$$5.$$\\dbinom{n+m}{k}=\\sum_{i=0}^k\\dbinom{n}{i}\\dbinom{m}{k-i}$$6.$$\\dbinom{n}{a+1+b}=\\sum_{i=a+1}^{n-b}\\dbinom{i-1}{a}\\dbinom{n-i}{b}$$7.$$(a+b)^n=\\sum_{i=0}^n \\dbinom{n}{i} a^i b^{n-i}$$ 组合数取模 $m \\leq n\\leq 1000,p \\leq 10^9$ 利用杨辉三角求解$$\\dbinom{n}{m}=\\dbinom{n-1}{m}+\\dbinom{n-1}{m-1}$$ $m \\leq n\\leq 10^5,p$是质数 先求出阶乘，再求出阶乘的逆元$$\\dbinom{n}{m}=\\dbinom{n}{n-m}$$ 先$O(n)$求出$n!$,然后计算$n!$d的逆元，继而利用$n!$的逆元求出$(n-1)!$等的逆元 复杂度$O(n)-O(1)$。 $m \\leq n\\leq 10^{18},p \\leq 10^5,p$是质数 利用Lucas定理 $$ \\dbinom{n}{m}\\equiv\\dbinom{\\lfloor \\frac{n}{p} \\rfloor}{\\lfloor \\frac{m}{p} \\rfloor}\\dbinom{n \\mod p}{m \\mod p}(\\mod p) $$ 转到方法2 复杂度$O(p)-O(\\log_pn)$ $m \\leq n\\leq 10^{5},p \\leq 10^5$ 利用线性筛分解n!,计算每种质因子出现的次数,快速幕计算。 质数数量为$O(\\frac{n}{\\ln n})$,复杂度为$O(n)$ $m \\leq n\\leq 10^{18},p^c \\leq 10^5,p$是质数$$\\dbinom{n}{m}(\\mod p^c)$$ 由于涉及除法,所以考虑把存成不包含$p$因子的部分和$p$因子出现的次数处理。 考虑每次把不包含$p$因子的部分利用已预处理的阶乘计算,包含$p$因子的部分可以写成公差为$p$的等差数列,所以可以递归子问题,范围缩小为原来的$\\frac{1}{p}$,复杂度为$O(p^c)$ $m \\leq n &lt; p \\leq 10^9$ 关键是计算$n!$,假设$n$是完全平方数,否则暴力计算完全平方数以外的部分。 构造多项式 $$ Q(x)=\\prod_{i=0}^{\\sqrt{n}}(x+i) $$ 那么可得 $$ n!=\\prod_{i=0}^{\\sqrt{n}-1}Q(i\\sqrt{n}) $$ $Q(x)$为$\\sqrt{n}$阶多项式，现需要在$\\sqrt{n}$个点求值 现在的问题是多项式多点求值。 为了描述方便,设给出多项式$F(x)$,求其在$A = (a_o, a_1,\\ldots, a_m)$处的值。 构造多项式 $$ M_0(x)=\\prod_{i=0}^{\\lfloor \\frac{m}{2} \\rfloor}(x-a_i) $$ $$ M_1(x)=\\prod_{i=\\lfloor \\frac{m}{2} \\rfloor+1}^{m}(x-a_i) $$ 那么，设 $$ Q_0(x)=F(x) \\mod M_0(x) $$ $$ Q_1(x)=F(x) \\mod M_1(x) $$ 由于模去了$(x-a_i)$,所以$F(a_i)$的取值是不变的 于是可以得到一个性质 $$ \\forall i \\in [0,\\lfloor \\frac{m}{2} \\rfloor],F(a_i)=Q_0(a_i) $$ $$ \\forall i \\in [\\lfloor \\frac{m}{2} \\rfloor+1,m],F(a_i)=Q_1(a_i) $$ 分治递归解决 于是求解$n!$的复杂度为$O(\\sqrt{n}log^2n)$,问题解决。","link":"/posts/56213.html"},{"title":"调用力：调用事物的能力（万维钢原文）","text":"「调用力」：调用工具的能力 请允许我发明一个新概念，叫「调用力」。当然这个概念不一定真是我首创，但我的确从来没在中英文世界听到过。 调用力的意思是调用工具的能力。 这是一种不同于「使用工具的能力」的新能力。比如老张精通数控机床，他把某一个型号的数控机床玩到了飞起，他无比熟悉这台机床的每一个细节，凡是要用机床的活儿交给他他都能又快又好、甚至特别巧妙地给你做好，这是使用力。 调用力，则是说你让我干个什么活儿，我的情况是这样的。第一，我从来没干过这个活儿，但是我知道现在有什么流行工具能干这个活儿。第二，我手里也没有那些工具，但是我很快就能把那些工具搞到手。第三，我并没用过那些工具，但是我可以现学现用。 那你敢把活儿交给这样的人干吗？当然。我要说的是，可能以后大部分活儿，都得这么干。 咱们先讲个真实的故事 [1,2]，你体会一下。 现在有些地方给女性的常规体检之中，有个「宫颈癌筛查」项目。我不太了解具体的细节，大概的意思是医生在宫颈上取得一个涂片，然后通过分析这个涂片来判断女性是否有宫颈癌的早期症状。大约在2018年，爱尔兰出了一个宫颈癌筛查的事故。有两百多位女性被筛查判断没有癌症，结果却得了癌症。当时舆论大哗。 这个新闻引起了一个叫劳拉·奥沙利文 (Laura O’Sullivan) 的爱尔兰女高中生的兴趣。劳拉意识到，这个所谓的对涂片进行分析，不就是个图像识别问题吗？图像识别不就是AI最擅长的问题吗？她决心用AI做宫颈癌筛查。 请注意，当时劳拉只有十六岁。 劳拉会编程，但是她只会最基本的编程，她参加过中学生编程训练营。AI图像识别并不神秘，已经有很多现成的而且是免费的工具了。劳拉在吴恩达搞的那个Coursera网站和斯坦福大学上过一点关于机器学习和深度学习的在线课程，她知道怎么搭建卷积神经网络，这就够用了。 真正的难点不在于AI工具，而在训练AI用的数据。理想情况下，你需要比如说几万张宫颈涂片的图像，其中有健康的有癌症的，都事先一一标记好，然后你输入给神经网络训练就行。但是当时根本就没有那样的图像集。这也很正常，要有的话别人早就把这个活儿做了。 劳拉联系上丹麦一家医院，他们有个宫颈涂片的开源数据集。这个数据集并不理想，因为其中大部分都是有病变、有癌症的涂片，健康的涂片太少，AI没法直接对比。 但这个难题其实是有解的。2014年，也就是距离劳拉做这个事儿的四年之前，有人发明了一种技术叫「生成对抗网络（Generative Adversarial Network，简称GAN）」。这个新技术可以随机生成一些跟样本相似的数据，然后拿这些自己生成的数据训练自己！我也说不清其中的具体原理，大约可以说是AI会举一反三吧……但是，劳拉把这个东西搞懂了。 当然所谓搞懂也只是大致懂。而这就足够了。劳拉不需要自己写一个生成对抗网络程序，因为GitHub网站有现成的代码。 所以劳拉下载了AI代码，下载了涂片数据集，就开干了。这没有说起来那么容易，你总要对代码进行一定的调试，你需要搞好数据集和代码的接口，你得知道怎么评估训练效果，等等等。不过这也没有听起来那么难，劳拉一边调试代码一边查看结果，在她爸爸那台家用电脑上就把这个事儿做成了。 2019年1月，劳拉在爱尔兰青年科学家大赛中得了奖。这不是鼓励，这是真奖：劳拉训练出来的AI，对宫颈癌判断的准确率超过了人类医生。 我们想想这说明什么。劳拉不是编程天才，更不是计算机科学家。她这个项目整体是一个创新，但是她的每一步操作都不是新的。她只是调用了现成的工具和数据而已。 劳拉之所以能干成这件事，是因为她幸运地生活在一个拥有大量现成的、好用的、免费的、直接能调用的工具的时代。你要愿意下功夫探索，你也能做到。 我曾经看过一个北京的女初中生的音乐视频。她自己作词作曲，自己弹吉他自己演唱，用iPad中的工具编曲配乐，自己录制视频自己剪辑，做出来的效果非常专业。一个人，就是一支乐队。 当然我们应该称赞这些中学生很厉害，但是我们更应该赞叹的是这个时代很厉害。 这是一个技术对人空前友好的时代。 有些需要付费，但更多的是免费的。人们会把有意思的技术给你封装好，变成尽可能标准化的、界面通俗易懂的、拿来就能用的工具。 那些工具在等待着你的召唤。就好像网文追求点击数一样，它们渴望被你用到。 早在秦始皇时代，中国人就已经知道「标准化」的好处。秦军用的弩机，每个配件都是标准化的，坏了随时能拆能换能组合，非常高效。 现代工具的标准化则不但是零件的标准化，而且是不同工具之间交流接口和组合方式的标准化。编程语言是通用的，AI工具包是通用编程语言的通用子程序和库函数，训练AI用的数据集的格式也是通用的。不管你用什么编辑器，视频音频都是通用的。只有这样它们才能互相对话。 它们被设计出来的时候，就希望互相对话。 正因为这样，我们才能轻易地把不同领域的工具组合在一起，去做一件没有人做过的事情。 科技企业家阿泽姆·阿扎尔（Azeem Azhar）在《指数时代》[1] 一书中举了个例子。你要想在晚上也能用上太阳能，就必须把白天太阳能发的电用一种什么方法储存起来。有人发明了一种“起重机储能塔”——白天用太阳能电力把一层一层的砖块升起来，把电能变成势能；晚上借助重力让这些砖块慢慢落下来，在下落过程中发电，把势能变成电能。 这样这个塔就相当于是一个电池。这是一个奇思妙想！但是实现这个妙想的技术都是现成的：起重机、建筑骨架、把势能变成电能的发电机，已经都有了。然后你还可以使用深度学习算法驱动的视觉系统判断起重机和砖块的位置情况。 你不需要发明那些底层技术，你只要有个好想法、有条件实践就行：你可以直接调用那些底层技术。 这就是新时代发明家所做的事情。 当然总要有人做底层，比如说芯片就是现在各种发明都必须依赖的底层。底层技术是最难的技术，往往成本极高，需要大公司大投入。但是底层技术渴望被你使用。他们会把那些技术做得尽可能地通用化，方便你调用。 这就如同有了台积电，就出现了一大堆小的芯片设计公司。通用技术是创新的养料。每多一项通用技术，你的思路就多了一个维度。 君子生非异也，善假于物也。现在「善假于物」与其说是你善于熟练使用某个工具，不如说是你善于想到、拿到、用到现代科技圈提供的任何一个工具。你需要调用力。 那么工程师、发明家、创业者和企业家就不但需要熟练使用自己常用的那几个工具，更要对当前科技圈流行什么新工具、每个工具大致的原理和用途、去哪里找那些工具，有个基本的了解。 而这就要求你对科技圈有一定的「文化自觉」[3]。平时就得多看多问，有什么新鲜的玩法你得知道才好。 如果你做的是一件以前没有人做过、尚未形成固定流程的事情，那么知道现在有哪些新工具可用，比熟练使用一个旧工具，可能会有用得多。 一位老奶奶，对自己家附近的街道特别熟悉，买个什么东西办个什么事都知道去哪，这当然是很好的生活技能。但是现代社会更希望你有另一种技能：到任何一个城市，包括国外，也能打车、坐地铁、办各种事情。可能你每次到一个地方办事都很不熟练，你磕磕碰碰，问问这个人问问那个人，还时不时走一段冤枉路——但是你每次都能把事情办成。你不怕去新地方，你很喜欢去新地方。 老板让你去伦敦办个事儿，问你以前去过没有。你说我没去过，但我可以打听着去。你看这像不像面试中那句经典的「我不会，但我可以学」。 有人说现在面试跟人说「我不会，但我可以学」是敷衍，是不真诚——你要是什么都不会的话确实如此——但是「不会可以学」、现用现学，恰恰是最适合这个时代的工作方式。 我们出生时预装的信息十分有限，但我们的大脑有学习能力，大脑本来就是个现用现学的系统。 我们专栏讲搜索的时候说过 [4]，你已经知道的东西是你的知识，你暂时不知道、但是知道去哪能查到的信息，也可以说是你的知识。在通用性越来越好，用户界面如此友好的时代，各种工具也是这样。 你知道一个工具的存在，约等于你会调用这个工具； 你会调用这个工具，约等于你会学习使用这个工具； 你会学习这个工具，约等于你已经会用这个工具； 所以，你知道工具的存在，约等于你能把这件事做出来。 「会不会」，说的只是一个暂时的状态，其实意义不大。知不知道去哪找解决方案，特别是知不知道在当前技术局面下，科技圈里有没有适合这个问题的方案，这个眼光，才是最重要的。不管什么新工具拿过来就能迅速上手，你们能会我就能会，这个调用力才是最值钱的。 所以大学教技术不应该专门强调某项技术的熟练度，更应该强调快速寻找和调用新技术的能力。那种对照老课本抠细节的学习方式已经过时了，现在应该多搞项目式、分组合作式、开放式的学习。 聪明人在一起做事，完全可以不需要现场任何人“会”做，但是假设我们之中一定有人能迅速找来做这件事的工具，完了大家一起上手，这就够了。 在这个科技迅速进步、新事物急剧变化的时代，搜索高于学习，学习高于熟练。「我听说过」比「我做过」更有用，模模糊糊的观念比对细节的熟悉更能给你掌控感，调用力比使用力更能帮你把事情办成。 注释 [1] Azeem Azhar, The Exponential Age: How Accelerating Technology is Transforming Business, Politics and Society (Diversion Books, 2021). [2] https://www.siliconrepublic.com/innovation/bt-young-scientist-2019-day-3 [3] 精英日课第三季，修炼你的文化自觉 [4] 精英日课第三季，调研是一种什么体验","link":"/posts/53473.html"},{"title":"调用力：调用事物的能力（演讲版）","text":"「调用力」：调用工具的能力 请允许我介绍一个新概念，叫「调用力」 调用力的意思是调用工具的能力。 这是一种不同于「使用工具的能力」的新能力。比如老张精通数控机床，他把某一个型号的数控机床玩到了飞起，他无比熟悉这台机床的每一个细节，凡是要用机床的活儿交给他他都能又快又好、甚至特别巧妙地给你做好，这是使用力。 调用力，则是说你让我干个什么活儿，我的情况是这样的。第一，我从来没干过这个活儿，但是我知道现在有什么流行工具能干这个活儿。第二，我手里也没有那些工具，但是我很快就能把那些工具搞到手。第三，我并没用过那些工具，但是我可以现学现用。 那你敢把活儿交给这样的人干吗？当然。我要说的是，可能以后有很多工作，都可以这么干。 咱们先讲个真实的故事，大家体会一下。 现在有些地方给女性的常规体检之中，有个「宫颈癌筛查」项目。大概的意思是医生在宫颈上取得一个涂片，然后通过分析这个涂片来判断女性是否有宫颈癌的早期症状。大约在2018年，爱尔兰出了一个宫颈癌筛查的事故。有两百多位女性被筛查判断没有癌症，结果却得了癌症。当时舆论大哗。 这个新闻引起了一个叫劳拉·奥沙利文 (Laura O’Sullivan) 的爱尔兰女高中生的兴趣。劳拉意识到，这个所谓的对涂片进行分析，不就是个图像识别问题吗？图像识别不就是AI最擅长的问题吗？她决心用AI做宫颈癌筛查。 请注意，当时 劳拉会编程，但是她只会最基本的编程。AI图像识别并不神秘，已经有很多现成的而且是免费的工具了。劳拉在Coursera网站和斯坦福大学上过一点关于机器学习和深度学习的在线课程，她知道怎么搭建卷积神经网络，这就够用了。 真正的难点不在于AI工具，而在训练AI用的数据。理想情况下，你需要比如说几万张宫颈涂片的图像，其中有健康的有癌症的，都事先一一标记好，然后你输入给神经网络训练就行。但是当时根本就没有那样的图像集。这也很正常，要有的话别人早就把这个活儿做了。 劳拉联系上丹麦一家医院，他们有个宫颈涂片的开源数据集。这个数据集并不理想，因为其中大部分都是有病变、有癌症的涂片，健康的涂片太少，AI没法直接对比。 但这个难题其实是有解的。2014年，也就是距离劳拉做这个事儿的四年之前，有人发明了一种技术叫「生成对抗网络（Generative Adversarial Network，简称GAN）」。这个新技术可以随机生成一些跟样本相似的数据，然后拿这些自己生成的数据训练自己！我也说不清其中的具体原理，大约可以说是AI会举一反三吧……但是，劳拉把这个东西搞懂了。 当然所谓搞懂也只是大致懂。而这就足够了。劳拉不需要自己写一个生成对抗网络程序，因为GitHub网站有现成的代码。 所以劳拉下载了AI代码，下载了涂片数据集，就开干了。这没有说起来那么容易，你总要对代码进行一定的调试，你需要搞好数据集和代码的接口，你得知道怎么评估训练效果，等等等。不过这也没有听起来那么难，劳拉一边调试代码一边查看结果，在她爸爸那台家用电脑上就把这个事儿做成了。 2019年1月，劳拉在爱尔兰青年科学家大赛中得了奖。这不是鼓励，这是真奖：劳拉训练出来的AI，对宫颈癌判断的准确率超过了人类医生。 我们想想这说明什么。劳拉不是编程天才，更不是计算机科学家。她这个项目整体是一个创新，但是她的每一步操作都不是新的。她只是调用了现成的工具和数据而已。 劳拉之所以能干成这件事，是因为她幸运地生活在一个拥有大量现成的、好用的、免费的、直接能调用的工具的时代。你要愿意下功夫探索，你也能做到。 曾经有位北京的女初中生创作的音乐视频。她自己作词作曲，自己弹吉他自己演唱，用iPad中的工具编曲配乐，自己录制视频自己剪辑，做出来的效果非常专业。一个人，就是一支乐队。 当然我们应该称赞这些中学生很厉害，但是我们更应该赞叹的是这个时代很厉害。 这是一个技术对人空前友好的时代。 有些需要付费，但更多的是免费的。人们会把有意思的技术给你封装好，变成尽可能标准化的、界面通俗易懂的、拿来就能用的工具。 那些工具在等待着你的召唤。就好像网文追求点击数一样，它们渴望被你用到。 早在秦始皇时代，中国人就已经知道「标准化」的好处。秦军用的弩机，每个配件都是标准化的，坏了随时能拆能换能组合，非常高效。 现代工具的标准化则不但是零件的标准化，而且是不同工具之间交流接口和组合方式的标准化。编程语言是通用的，AI工具包是通用编程语言的通用子程序和库函数，训练AI用的数据集的格式也是通用的。不管你用什么编辑器，视频音频都是通用的。只有这样它们才能互相对话。 它们被设计出来的时候，就希望互相对话。 正因为这样，我们才能轻易地把不同领域的工具组合在一起，去做一件没有人做过的事情。 你不需要发明那些底层技术，你只要有个好想法、有条件实践就行：你可以直接调用那些底层技术。 这就是新时代发明家所做的事情。 当然总要有人做底层，比如说芯片就是现在各种发明都必须依赖的底层。底层技术是最难的技术，往往成本极高，需要大公司大投入。但是底层技术渴望被你使用。他们会把那些技术做得尽可能地通用化，方便你调用。 这就如同有了台积电，就出现了一大堆小的芯片设计公司。通用技术是创新的养料。每多一项通用技术，你的思路就多了一个维度。 君子生非异也，善假于物也。在座的各位以后可能大多都是科研、工程、医疗岗位的先锋，现在「善假于物」与其说是你善于熟练使用某个工具，不如说是你善于想到、拿到、用到现代科技圈提供的任何一个工具。你需要调用力。 那么工程师、发明家、创业者和企业家就不但需要熟练使用自己常用的那几个工具，更要对当前科技圈流行什么新工具、每个工具大致的原理和用途、去哪里找那些工具，有个基本的了解。 而这就要求你对科技圈有一定的「文化自觉」。平时就得多看多问，有什么新鲜的玩法你得知道才好。 如果你做的是一件以前没有人做过、尚未形成固定流程的事情，那么知道现在有哪些新工具可用，比熟练使用一个旧工具，可能会有用得多。 有人说现在面试跟人说「我不会，但我可以学」是敷衍，是不真诚——你要是什么都不会的话确实如此——但是「不会可以学」、现用现学，恰恰是最适合这个时代的工作方式。 我们出生时预装的信息十分有限，但我们的大脑有学习能力，大脑本来就是个现用现学的系统。 你已经知道的东西是你的知识，你暂时不知道、但是知道去哪能查到的信息，也可以说是你的知识。在通用性越来越好，用户界面如此友好的时代，各种工具也是这样。 你知道一个工具的存在，约等于你会调用这个工具； 你会调用这个工具，约等于你会学习使用这个工具； 你会学习这个工具，约等于你已经会用这个工具； 所以，你知道工具的存在，约等于你能把这件事做出来。 「会不会」，说的只是一个暂时的状态，其实意义不大。知不知道去哪找解决方案，特别是知不知道在当前技术局面下，科技圈里有没有适合这个问题的方案，这个眼光，才是最重要的。不管什么新工具拿过来就能迅速上手，你们能会我就能会，你们不会的我还能会——这个调用力才是最有价值的。 聪明人在一起做事，完全可以不需要现场任何人“会”做，但是假设我们之中一定有人能迅速找来做这件事的工具，完了大家一起上手，这就够了。 在这个科技迅速进步、新事物急剧变化的时代，搜索高于学习，学习高于熟练。「我听说过」比「我做过」更有用，模模糊糊的观念比对细节的熟悉更能给你掌控感，调用力比使用力更能帮你把事情办成。","link":"/posts/53474.html"},{"title":"造数据？拿脚造！","text":"在一切的一切开始之前 优质的随机数？rand() 1234#include&lt;chrono&gt;#include&lt;random&gt;mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());//unsigned long longmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());//unsigned int 简单一点？ 1234#include&lt;random&gt;#include&lt;ctime&gt;mt19937_64 rnd(time(0));//unsigned long longmt19937 rnd(time(0));//unsigned int 需要负数？ 推出我们的梅森旋转引擎 123mt19937_64 egn(time(0));uniform_int_distribution&lt;long long&gt; rnd(l,r);/* 根据范围给出l,r */cout&lt;&lt;rnd(egn)&lt;&lt;' '; 打乱序列？ 1234int a[1024];for(int i=0;i&lt;1024;i++)a[i]=i;srand(time(NULL));random_shuffle(a,a+1024); 高质量的-&gt; 123456789101112#include&lt;chrono&gt;#include&lt;random&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());int main(){ int a[10]; for(int i=0;i&lt;10;i++)a[i]=i; shuffle(a,a+10,rnd); for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;} 在一切开始之前脚本读出？ 造数据的时候可能需要通过命令行脚本.bat如 1234DataMaker.exe num1 num2 &gt; 1.inDataMaker.exe num1 num2 &gt;&gt; 2.inDataMaker.exe num3 num4 &gt; 3.in... 这时候我们需要将main() 123int main(){} 更改为 12345int main(int argc,char* argv[]){ int a = atoi(argv[1]); long long b = atoll(argv[2]); double c = atof(argv[3]);} 文件输入输出？ 12345678910#include&lt;fstream&gt;int main(int argc,char* argv[]){ ifstream fin; ofstream fout; fin.open(&quot;your file&quot;); fout.open(&quot;your file&quot;); int n; fin&gt;&gt;n; fout&lt;&lt;n;} 打开类型 常量 含义 ios_base::in 打开文件，读取 ios_base::out 打开文件，写入 ios_base::ate 打开文件，移到文件尾 ios_base::app 追加到文件尾 ios_base::trunc 如果文件存在，则截断文件 ios_base::binary 二进制文件 上面的fout.open()其实是有三个参数的，第一个是文件的路径，第二个是打开文件的类型，第三个是权限。如果不写的话，会采用默认参数，就是ios_base::out|ios_base::trunc； 开始之前模仿testlib.h(Github) 我们给出一些常用的rand方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mt19937_64 engll(chrono::steady_clock::now().time_since_epoch().count());mt19937 engi(chrono::steady_clock::now().time_since_epoch().count());long long randll(long long l=LLONG_MIN,long long r=LLONG_MAX){ /* generate a random number from [l,r] */ if(l&gt;r)swap(l,r); uniform_int_distribution&lt;long long&gt; rnd(l,r); return rnd(engll);}long long tRandll(long long l=LLONG_MIN,long long r=LLONG_MAX,long long t=0){ /* random abs(t)+1 times and get the max(opposite)/min(negtive) value from [l,r], */ if(l&gt;r)swap(l,r); uniform_int_distribution&lt;long long&gt; rnd(l,r); long long ans; if(t&gt;=0){ ans = l; for(long long i = 1;i&lt;=t+1;i++){ ans=max((long long)rnd(engll),ans); } }else{ t = abs(t); ans = r; for(long long i = 1;i&lt;=t+1;i++){ ans=min((long long)rnd(engll),ans); } } return ans;}int randi(int l=INT32_MIN,int r=INT32_MAX){ /* generate a random number from [l,r] */ if(l&gt;r)swap(l,r); uniform_int_distribution&lt;int&gt; rnd(l,r); return rnd(engi);}int tRandi(int l=INT32_MIN,int r=INT32_MAX,int t=0){ /* random abs(t)+1 times and get the max(opposite)/min(negtive) value from [l,r], */ if(l&gt;r)swap(l,r); uniform_int_distribution&lt;int&gt; rnd(l,r); int ans; if(t&gt;=0){ ans = l; for(int i = 1;i&lt;=t+1;i++){ ans=max((int)rnd(engi),ans); } }else{ t = abs(t); ans = r; for(int i = 1;i&lt;=t+1;i++){ ans=min((int)rnd(engi),ans); } } return ans;} 好戏开场造一棵树普通树（链/菊花）$\\textbf{Code}$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243//tree.cpp/* #define IOFILE *///Optionalint main(int argc,char* argv[]){ int n = atoi(argv[1]); int t = atoi(argv[2]); #ifdef IOFILE ofstream fout; fout.open(argv[3]); #endif vector&lt;int&gt;fa(n); for(int i = 1;i&lt;n;i++){ fa[i] = tRandi(0,i-1,t); } vector&lt;int&gt;id(n); for(int i = 0;i&lt;n;i++)id[i]=i+1; shuffle(id.begin(),id.end(),engi); struct EDGE{int a,b;}; vector&lt;EDGE&gt;edge; for(int i = 1;i&lt;n;i++){ int fat = id[fa[i]],pos=id[i]; if(randi()&gt;0)swap(fat,pos); edge.push_back((EDGE){fat,pos}); } shuffle(edge.begin(),edge.end(),engi); #ifdef IOFILE fout&lt;&lt;n&lt;&lt;&quot;\\n&quot;; for(EDGE i:edge){ fout&lt;&lt;i.a&lt;&lt;&quot; &quot;&lt;&lt;i.b&lt;&lt;&quot;\\n&quot;; } #endif #ifndef IOFILE printf(&quot;%d\\n&quot;,n); for(EDGE i:edge){ printf(&quot;%d %d\\n&quot;,i.a,i.b); } #endif return 0;} $\\textbf{Require}$ 你需要喂给我： 12tree.exe N T F&lt;!-- N节点个数, T随机次数(正的越大越链，负的越小越菊花), F(可选，若在程序中定义了IOFILE，则填入输出文件名) --&gt; 蒲公英造两棵树，一个是链，另一个是菊花把链的端点和菊花的花心连起来 $\\textbf{Code}$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//Dandelion.cppstruct EDGE{int a,b;};vector&lt;EDGE&gt;edge;void makeTree1(int n,int l,vector&lt;int&gt; id){ vector&lt;int&gt;fa(n); for(int i = 2;i&lt;n;i++){ fa[i] = i-1; } edge.push_back((EDGE){id[l],id[0]}); for(int i = 2;i&lt;n;i++){ int fat = id[fa[i]+l-1],pos=id[i+l-1]; if(randi()&gt;0)swap(fat,pos); edge.push_back((EDGE){fat,pos}); }}void makeTree2(int n,int l,vector&lt;int&gt; id){ vector&lt;int&gt;fa(n); for(int i = 1;i&lt;n;i++){ int fat = id[0],pos=id[l+i-1]; if(randi()&gt;0)swap(fat,pos); edge.push_back((EDGE){fat,pos}); }}int main(int argc,char* argv[]){ int n = atoi(argv[1]); int root = atoi(argv[2]); #ifdef IOFILE ofstream fout; fout.open(argv[3]); #endif int lian = randi(1,n); int juhua = n-lian+1; vector&lt;int&gt;id(n); for(int i = 0;i&lt;n;i++)id[i]=i+1; shuffle(id.begin(),id.end(),engi); for(int i = 0;i&lt;n;i++){ if(id[i]==root){ swap(id[i],id[0]); break; } } makeTree1(lian,1,id); makeTree2(juhua,lian,id); shuffle(edge.begin(),edge.end(),engi); #ifdef IOFILE fout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;root&lt;&lt;&quot;\\n&quot;; for(EDGE i:edge){ fout&lt;&lt;i.a&lt;&lt;&quot; &quot;&lt;&lt;i.b&lt;&lt;&quot;\\n&quot;; } #endif #ifndef IOFILE printf(&quot;%d %d\\n&quot;,n,root); for(EDGE i:edge){ printf(&quot;%d %d\\n&quot;,i.a,i.b); } #endif return 0;} $\\textbf{Require}$ 你需要喂给我： 12Dandelion.exe N R F&lt;!-- N节点个数, R(菊花的花心和链的端点), F(可选，若在程序中定义了IOFILE，则填入输出文件名) --&gt; 造一张图","link":"/posts/24146.html"},{"title":"高中常见的泰勒展开","text":"有关ln()$$\\ln{\\dfrac{1+x}{1-x}}=2(x+\\dfrac{1}{3}x^3+\\dfrac{1}{5}x^5+ \\cdots)$$ 当$x\\to0$，即$\\left\\vert x\\right\\vert \\le 0.1$时$$\\ln(1+x)=x-\\dfrac{x^2}{2}+\\dfrac{x^3}{3}-\\dfrac{x^4}{4}+\\cdots$$ 有关三角函数","link":"/posts/42701.html"}],"tags":[{"name":"IT","slug":"IT","link":"/tags/IT/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"语文","slug":"语文","link":"/tags/%E8%AF%AD%E6%96%87/"}],"categories":[],"pages":[{"title":"","text":"@font-face { font-family: 'Consolas'; font-display: swap; src: url('../font/consola.ttf') format(\"truetype\"); } body, button, input, select, textarea { font-family: dhtfr; } code, pre { font-family: Consolas; } article.article .content { font-size: 1.2rem; } body { font-size: 1.1em; } .navbar-main .navbar-item { padding: 0.25rem 0.75rem; } .navbar-logo img { max-height: 2.45rem; } .title.is-3 { font-size: 2.3rem; } @media screen and (min-width: 1104px), print { .column.is-4, .column.is-4-tablet, .is-4-desktop, .is-4-widescreen { width: 25%; max-width: 25rem; } .column.is-8, .column.is-8-tablet, .is-8-desktop, .is-8-widescreen { width: 75%; } } .article { margin-right: 10px; margin-left: 10px; .content a img { margin: auto; display: block; } } .is-2-column { background-image: url(\"../image/background.png\"); background-position: center center; background-repeat: no-repeat; background-attachment: fixed; background-size: cover; } .card { border-radius: 15px; }","link":"/css/font.css"}]}